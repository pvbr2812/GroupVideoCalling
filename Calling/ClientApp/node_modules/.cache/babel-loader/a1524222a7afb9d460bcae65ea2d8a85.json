{"ast":null,"code":"var defaultColor = 'transparent';\n\nvar getPseudoElementStyles = function getPseudoElementStyles(borderEdgeValue, styles) {\n  return Object.assign({\n    content: '\"\"',\n    position: 'absolute',\n    borderStyle: 'solid',\n    pointerEvents: 'none',\n    top: borderEdgeValue,\n    right: borderEdgeValue,\n    bottom: borderEdgeValue,\n    left: borderEdgeValue\n  }, styles);\n};\n/**\n * Returns style object that can be used for styling components on focus state.\n * NOTE: the element where this is used needs to have relative positioning so that the\n * pseudo elements created on focus can be properly positioned.\n */\n\n\nexport var getBorderFocusStyles = function getBorderFocusStyles(args) {\n  var sv = args.variables;\n  var _args$borderWidth = args.borderWidth,\n      borderWidth = _args$borderWidth === void 0 ? sv.borderWidth : _args$borderWidth,\n      _args$borderRadius = args.borderRadius,\n      borderRadius = _args$borderRadius === void 0 ? sv.borderRadius : _args$borderRadius,\n      _args$focusInnerBorde = args.focusInnerBorderColor,\n      focusInnerBorderColor = _args$focusInnerBorde === void 0 ? sv.focusInnerBorderColor || defaultColor : _args$focusInnerBorde,\n      _args$focusOuterBorde = args.focusOuterBorderColor,\n      focusOuterBorderColor = _args$focusOuterBorde === void 0 ? sv.focusOuterBorderColor || defaultColor : _args$focusOuterBorde,\n      borderPadding = args.borderPadding;\n  var afterBorderEdgeValue = borderPadding == null ? \"-\" + borderWidth : \"calc(0px - \" + borderPadding + \" - \" + borderWidth + \")\";\n  var beforeBorderEdgeValue = borderPadding == null ? '0' : \"-\" + borderPadding;\n  return {\n    ':focus': {\n      outline: 0\n    },\n    ':focus-visible': {\n      borderColor: 'transparent',\n      ':before': getPseudoElementStyles(beforeBorderEdgeValue, {\n        zIndex: sv.zIndexes.foreground,\n        borderColor: focusInnerBorderColor,\n        borderWidth: borderWidth,\n        borderRadius: borderRadius\n      }),\n      ':after': getPseudoElementStyles(afterBorderEdgeValue, {\n        zIndex: sv.zIndexes.foreground,\n        borderColor: focusOuterBorderColor,\n        borderWidth: borderWidth,\n        borderRadius: borderRadius\n      })\n    }\n  };\n};","map":{"version":3,"sources":["themes/teams/getBorderFocusStyles.ts"],"names":["defaultColor","getPseudoElementStyles","content","position","borderStyle","pointerEvents","top","right","bottom","left","borderEdgeValue","getBorderFocusStyles","sv","args","borderWidth","borderRadius","focusInnerBorderColor","focusOuterBorderColor","borderPadding","afterBorderEdgeValue","beforeBorderEdgeValue","outline","borderColor","zIndex"],"mappings":"AAqBA,IAAMA,YAAY,GAAlB,aAAA;;AAEA,IAAMC,sBAAsB,GAAG,SAAzBA,sBAAyB,CAAA,eAAA,EAAA,MAAA,EAAmE;AAChG,SAAA,MAAA,CAAA,MAAA,CAAA;AACEC,IAAAA,OAAO,EADT,IAAA;AAEEC,IAAAA,QAAQ,EAFV,UAAA;AAGEC,IAAAA,WAAW,EAHb,OAAA;AAIEC,IAAAA,aAAa,EAJf,MAAA;AAMEC,IAAAA,GAAG,EANL,eAAA;AAOEC,IAAAA,KAAK,EAPP,eAAA;AAQEC,IAAAA,MAAM,EARR,eAAA;AASEC,IAAAA,IAAI,EAAEC;AATR,GAAA,EAAA,MAAA,CAAA;AADF,CAAA;AAgBA;;;;;;;AAKA,OAAO,IAAMC,oBAAoB,GAAG,SAAvBA,oBAAuB,CAAA,IAAA,EAA4C;AAC9E,MAAMC,EAAE,GAAGC,IAAI,CAAf,SAAA;AAD8E,MAAA,iBAAA,GAQ1EA,IAR0E,CAAA,WAAA;AAAA,MAG5EC,WAH4E,GAAA,iBAAA,KAAA,KAAA,CAAA,GAG9DF,EAAE,CAH4D,WAAA,GAAA,iBAAA;AAAA,MAAA,kBAAA,GAQ1EC,IAR0E,CAAA,YAAA;AAAA,MAI5EE,YAJ4E,GAAA,kBAAA,KAAA,KAAA,CAAA,GAI7DH,EAAE,CAJ2D,YAAA,GAAA,kBAAA;AAAA,MAAA,qBAAA,GAQ1EC,IAR0E,CAAA,qBAAA;AAAA,MAK5EG,qBAL4E,GAAA,qBAAA,KAAA,KAAA,CAAA,GAKpDJ,EAAE,CAAFA,qBAAAA,IALoD,YAAA,GAAA,qBAAA;AAAA,MAAA,qBAAA,GAQ1EC,IAR0E,CAAA,qBAAA;AAAA,MAM5EI,qBAN4E,GAAA,qBAAA,KAAA,KAAA,CAAA,GAMpDL,EAAE,CAAFA,qBAAAA,IANoD,YAAA,GAAA,qBAAA;AAAA,MAO5EM,aAP4E,GAQ1EL,IAR0E,CAAA,aAAA;AAU9E,MAAMM,oBAAoB,GACxBD,aAAa,IAAbA,IAAAA,GAAAA,MAAAA,WAAAA,GAAAA,gBAAAA,aAAAA,GAAAA,KAAAA,GAAAA,WAAAA,GADF,GAAA;AAEA,MAAME,qBAAqB,GAAGF,aAAa,IAAbA,IAAAA,GAAAA,GAAAA,GAAAA,MAA9B,aAAA;AAEA,SAAO;AACL,cAAU;AACRG,MAAAA,OAAO,EAAE;AADD,KADL;AAIL,sBAAkB;AAChBC,MAAAA,WAAW,EADK,aAAA;AAGhB,iBAAWrB,sBAAsB,CAAA,qBAAA,EAAwB;AACvDsB,QAAAA,MAAM,EAAEX,EAAE,CAAFA,QAAAA,CAD+C,UAAA;AAEvDU,QAAAA,WAAW,EAF4C,qBAAA;AAGvDR,QAAAA,WAAW,EAH4C,WAAA;AAIvDC,QAAAA,YAAY,EAAZA;AAJuD,OAAxB,CAHjB;AAUhB,gBAAUd,sBAAsB,CAAA,oBAAA,EAAuB;AACrDsB,QAAAA,MAAM,EAAEX,EAAE,CAAFA,QAAAA,CAD6C,UAAA;AAErDU,QAAAA,WAAW,EAF0C,qBAAA;AAGrDR,QAAAA,WAAW,EAH0C,WAAA;AAIrDC,QAAAA,YAAY,EAAZA;AAJqD,OAAvB;AAVhB;AAJb,GAAP;AAdK,CAAA","sourcesContent":["import { ICSSInJSStyle, SiteVariablesPrepared } from '@fluentui/styles';\nimport * as React from 'react';\n\ntype CSSBorderStyles = Pick<ICSSInJSStyle, 'borderWidth' | 'borderRadius'>;\n\ntype BorderFocusStyles = CSSBorderStyles & {\n  variables?:\n    | SiteVariablesPrepared\n    | {\n        borderWidth: string;\n        borderRadius: string;\n        focusInnerBorderColor: string;\n        focusOuterBorderColor: string;\n\n        zIndexes: { foreground: string };\n      };\n  focusInnerBorderColor?: string;\n  focusOuterBorderColor?: string;\n  borderPadding?: React.CSSProperties['padding'];\n};\n\nconst defaultColor = 'transparent';\n\nconst getPseudoElementStyles = (borderEdgeValue: string, styles: ICSSInJSStyle): ICSSInJSStyle => {\n  return {\n    content: '\"\"',\n    position: 'absolute',\n    borderStyle: 'solid',\n    pointerEvents: 'none',\n\n    top: borderEdgeValue,\n    right: borderEdgeValue,\n    bottom: borderEdgeValue,\n    left: borderEdgeValue,\n\n    ...styles,\n  };\n};\n\n/**\n * Returns style object that can be used for styling components on focus state.\n * NOTE: the element where this is used needs to have relative positioning so that the\n * pseudo elements created on focus can be properly positioned.\n */\nexport const getBorderFocusStyles = (args: BorderFocusStyles): ICSSInJSStyle => {\n  const sv = args.variables;\n  const {\n    borderWidth = sv.borderWidth,\n    borderRadius = sv.borderRadius,\n    focusInnerBorderColor = sv.focusInnerBorderColor || defaultColor,\n    focusOuterBorderColor = sv.focusOuterBorderColor || defaultColor,\n    borderPadding,\n  } = args;\n\n  const afterBorderEdgeValue =\n    borderPadding == null ? `-${borderWidth}` : `calc(0px - ${borderPadding} - ${borderWidth})`;\n  const beforeBorderEdgeValue = borderPadding == null ? '0' : `-${borderPadding}`;\n\n  return {\n    ':focus': {\n      outline: 0,\n    },\n    ':focus-visible': {\n      borderColor: 'transparent',\n\n      ':before': getPseudoElementStyles(beforeBorderEdgeValue, {\n        zIndex: sv.zIndexes.foreground,\n        borderColor: focusInnerBorderColor,\n        borderWidth,\n        borderRadius,\n      }),\n\n      ':after': getPseudoElementStyles(afterBorderEdgeValue, {\n        zIndex: sv.zIndexes.foreground,\n        borderColor: focusOuterBorderColor,\n        borderWidth,\n        borderRadius,\n      }),\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"module"}