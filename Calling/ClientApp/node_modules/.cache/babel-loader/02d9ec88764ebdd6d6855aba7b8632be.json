{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __awaiter } from \"tslib\";\nimport { URLBuilder, isNode, BaseRequestPolicy } from \"@azure/core-http\";\nimport { shaHash, shaHMAC } from \"./cryptoUtils\";\n/**\n * Creates an HTTP pipeline policy to authenticate a request using a `KeyCredential`.\n * @hidden\n *\n * @param credential - The key credential.\n */\n\nexport const createCommunicationAccessKeyCredentialPolicy = credential => {\n  return {\n    create: (nextpolicy, options) => {\n      return new CommunicationAccessKeyCredentialPolicy(credential, nextpolicy, options);\n    }\n  };\n};\n/**\n * CommunicationAccessKeyCredentialPolicy provides a means of signing requests made through\n * the SmsClient.\n */\n\nclass CommunicationAccessKeyCredentialPolicy extends BaseRequestPolicy {\n  /**\n   * Initializes a new instance of the CommunicationAccessKeyCredential class\n   * using a base64 encoded key.\n   * @param accessKey - The base64 encoded key to be used for signing.\n   */\n  constructor(accessKey, nextPolicy, options) {\n    super(nextPolicy, options);\n    this.accessKey = accessKey;\n  }\n  /**\n   * Signs a request with the provided access key.\n   *\n   * @param webResource - The WebResource to be signed.\n   */\n\n\n  signRequest(webResource) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const verb = webResource.method.toUpperCase();\n      const utcNow = new Date().toUTCString();\n      const contentHash = yield shaHash(webResource.body || \"\");\n      const dateHeader = isNode ? \"date\" : \"x-ms-date\";\n      const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;\n      const url = URLBuilder.parse(webResource.url);\n      const query = url.getQuery();\n      const urlPathAndQuery = query ? `${url.getPath()}?${query}` : url.getPath();\n      const port = url.getPort();\n      const hostAndPort = port ? `${url.getHost()}:${port}` : url.getHost();\n      const stringToSign = `${verb}\\n${urlPathAndQuery}\\n${utcNow};${hostAndPort};${contentHash}`;\n      const signature = yield shaHMAC(this.accessKey.key, stringToSign);\n\n      if (isNode) {\n        webResource.headers.set(\"Host\", hostAndPort || \"\");\n      }\n\n      webResource.headers.set(dateHeader, utcNow);\n      webResource.headers.set(\"x-ms-content-sha256\", contentHash);\n      webResource.headers.set(\"Authorization\", `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`);\n      return webResource;\n    });\n  }\n  /**\n   * Signs the request and calls the next policy in the factory.\n   */\n\n\n  sendRequest(webResource) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!webResource) {\n        throw new Error(\"webResource cannot be null or undefined\");\n      }\n\n      return this._nextPolicy.sendRequest(yield this.signRequest(webResource));\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/credential/communicationAccessKeyCredentialPolicy.ts"],"names":[],"mappings":"AAAA;AACA;;AAGA,SACE,UADF,EAGE,MAHF,EASE,iBATF,QAUO,kBAVP;AAWA,SAAS,OAAT,EAAkB,OAAlB,QAAiC,eAAjC;AAEA;;;;;AAKG;;AACH,OAAO,MAAM,4CAA4C,GACvD,UAD0D,IAElC;AACxB,SAAO;AACL,IAAA,MAAM,EAAE,CAAC,UAAD,EAA4B,OAA5B,KAAiE;AACvE,aAAO,IAAI,sCAAJ,CAA2C,UAA3C,EAAuD,UAAvD,EAAmE,OAAnE,CAAP;AACD;AAHI,GAAP;AAKD,CARM;AAUP;;;AAGG;;AACH,MAAM,sCAAN,SAAqD,iBAArD,CAAsE;AACpE;;;;AAIG;AACH,EAAA,WAAA,CACmB,SADnB,EAEE,UAFF,EAGE,OAHF,EAGmC;AAEjC,UAAM,UAAN,EAAkB,OAAlB;AAJiB,SAAA,SAAA,GAAA,SAAA;AAKlB;AAED;;;;AAIG;;;AACW,EAAA,WAAW,CAAC,WAAD,EAAyB;;AAChD,YAAM,IAAI,GAAG,WAAW,CAAC,MAAZ,CAAmB,WAAnB,EAAb;AACA,YAAM,MAAM,GAAG,IAAI,IAAJ,GAAW,WAAX,EAAf;AACA,YAAM,WAAW,GAAG,MAAM,OAAO,CAAC,WAAW,CAAC,IAAZ,IAAoB,EAArB,CAAjC;AACA,YAAM,UAAU,GAAG,MAAM,GAAG,MAAH,GAAY,WAArC;AACA,YAAM,aAAa,GAAG,GAAG,UAAU,2BAAnC;AAEA,YAAM,GAAG,GAAG,UAAU,CAAC,KAAX,CAAiB,WAAW,CAAC,GAA7B,CAAZ;AACA,YAAM,KAAK,GAAG,GAAG,CAAC,QAAJ,EAAd;AACA,YAAM,eAAe,GAAG,KAAK,GAAG,GAAG,GAAG,CAAC,OAAJ,EAAa,IAAI,KAAK,EAA5B,GAAiC,GAAG,CAAC,OAAJ,EAA9D;AACA,YAAM,IAAI,GAAG,GAAG,CAAC,OAAJ,EAAb;AACA,YAAM,WAAW,GAAG,IAAI,GAAG,GAAG,GAAG,CAAC,OAAJ,EAAa,IAAI,IAAI,EAA3B,GAAgC,GAAG,CAAC,OAAJ,EAAxD;AAEA,YAAM,YAAY,GAAG,GAAG,IAAI,KAAK,eAAe,KAAK,MAAM,IAAI,WAAW,IAAI,WAAW,EAAzF;AACA,YAAM,SAAS,GAAG,MAAM,OAAO,CAAC,KAAK,SAAL,CAAe,GAAhB,EAAqB,YAArB,CAA/B;;AAEA,UAAI,MAAJ,EAAY;AACV,QAAA,WAAW,CAAC,OAAZ,CAAoB,GAApB,CAAwB,MAAxB,EAAgC,WAAW,IAAI,EAA/C;AACD;;AAED,MAAA,WAAW,CAAC,OAAZ,CAAoB,GAApB,CAAwB,UAAxB,EAAoC,MAApC;AACA,MAAA,WAAW,CAAC,OAAZ,CAAoB,GAApB,CAAwB,qBAAxB,EAA+C,WAA/C;AACA,MAAA,WAAW,CAAC,OAAZ,CAAoB,GAApB,CACE,eADF,EAEE,6BAA6B,aAAa,cAAc,SAAS,EAFnE;AAKA,aAAO,WAAP;AACD,K;AAAA;AAED;;AAEG;;;AACU,EAAA,WAAW,CAAC,WAAD,EAA6B;;AACnD,UAAI,CAAC,WAAL,EAAkB;AAChB,cAAM,IAAI,KAAJ,CAAU,yCAAV,CAAN;AACD;;AAED,aAAO,KAAK,WAAL,CAAiB,WAAjB,CAA6B,MAAM,KAAK,WAAL,CAAiB,WAAjB,CAAnC,CAAP;AACD,K;AAAA;;AA1DmE","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { KeyCredential } from \"@azure/core-auth\";\nimport {\n  URLBuilder,\n  WebResource,\n  isNode,\n  RequestPolicy,\n  RequestPolicyOptionsLike,\n  RequestPolicyFactory,\n  WebResourceLike,\n  HttpOperationResponse,\n  BaseRequestPolicy\n} from \"@azure/core-http\";\nimport { shaHash, shaHMAC } from \"./cryptoUtils\";\n\n/**\n * Creates an HTTP pipeline policy to authenticate a request using a `KeyCredential`.\n * @hidden\n *\n * @param credential - The key credential.\n */\nexport const createCommunicationAccessKeyCredentialPolicy = (\n  credential: KeyCredential\n): RequestPolicyFactory => {\n  return {\n    create: (nextpolicy: RequestPolicy, options: RequestPolicyOptionsLike) => {\n      return new CommunicationAccessKeyCredentialPolicy(credential, nextpolicy, options);\n    }\n  };\n};\n\n/**\n * CommunicationAccessKeyCredentialPolicy provides a means of signing requests made through\n * the SmsClient.\n */\nclass CommunicationAccessKeyCredentialPolicy extends BaseRequestPolicy {\n  /**\n   * Initializes a new instance of the CommunicationAccessKeyCredential class\n   * using a base64 encoded key.\n   * @param accessKey - The base64 encoded key to be used for signing.\n   */\n  constructor(\n    private readonly accessKey: KeyCredential,\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptionsLike\n  ) {\n    super(nextPolicy, options);\n  }\n\n  /**\n   * Signs a request with the provided access key.\n   *\n   * @param webResource - The WebResource to be signed.\n   */\n  private async signRequest(webResource: WebResource): Promise<WebResource> {\n    const verb = webResource.method.toUpperCase();\n    const utcNow = new Date().toUTCString();\n    const contentHash = await shaHash(webResource.body || \"\");\n    const dateHeader = isNode ? \"date\" : \"x-ms-date\";\n    const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;\n\n    const url = URLBuilder.parse(webResource.url);\n    const query = url.getQuery();\n    const urlPathAndQuery = query ? `${url.getPath()}?${query}` : url.getPath();\n    const port = url.getPort();\n    const hostAndPort = port ? `${url.getHost()}:${port}` : url.getHost();\n\n    const stringToSign = `${verb}\\n${urlPathAndQuery}\\n${utcNow};${hostAndPort};${contentHash}`;\n    const signature = await shaHMAC(this.accessKey.key, stringToSign);\n\n    if (isNode) {\n      webResource.headers.set(\"Host\", hostAndPort || \"\");\n    }\n\n    webResource.headers.set(dateHeader, utcNow);\n    webResource.headers.set(\"x-ms-content-sha256\", contentHash);\n    webResource.headers.set(\n      \"Authorization\",\n      `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`\n    );\n\n    return webResource;\n  }\n\n  /**\n   * Signs the request and calls the next policy in the factory.\n   */\n  public async sendRequest(webResource: WebResourceLike): Promise<HttpOperationResponse> {\n    if (!webResource) {\n      throw new Error(\"webResource cannot be null or undefined\");\n    }\n\n    return this._nextPolicy.sendRequest(await this.signRequest(webResource));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}