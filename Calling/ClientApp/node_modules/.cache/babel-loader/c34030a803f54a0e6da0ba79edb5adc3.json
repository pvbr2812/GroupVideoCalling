{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport _keys from \"lodash/keys\";\nimport { EventListener } from '@fluentui/react-component-event-listener';\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport * as PropTypes from 'prop-types';\nimport { getElementType } from '../utils/getElementType';\nimport { getUnhandledProps } from '../utils/getUnhandledProps';\nimport { getNextElement, getFirstTabbable, getLastTabbable, getWindow, getDocument, focusAsync, HIDDEN_FROM_ACC_TREE } from './focusUtilities';\n/** FocusTrapZone is used to trap the focus in any html element placed in body\n *  and hide other elements outside of Focus Trap Zone from accessibility tree.\n *  Pressing tab will circle focus within the inner focusable elements of the FocusTrapZone. */\n\nexport var FocusTrapZone = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(FocusTrapZone, _React$Component);\n\n  function FocusTrapZone() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this._root = {\n      current: null\n    };\n    _this._previouslyFocusedElementOutsideTrapZone = void 0;\n    _this._previouslyFocusedElementInTrapZone = void 0;\n    _this._firstBumper = /*#__PURE__*/React.createRef();\n    _this._lastBumper = /*#__PURE__*/React.createRef();\n    _this._hasFocus = false;\n    _this.windowRef = /*#__PURE__*/React.createRef();\n\n    _this.createRef = function (elem) {\n      _this._root.current = ReactDOM.findDOMNode(elem); // @ts-ignore\n\n      _this.windowRef.current = getWindow(_this._root.current);\n    };\n\n    _this.shouldHandleOutsideClick = function () {\n      return !_this.props.isClickableOutsideFocusTrap || !_this.props.focusTriggerOnOutsideClick;\n    };\n\n    _this._onRootFocus = function (ev) {\n      if (_this.props.onFocus) {\n        _this.props.onFocus(ev);\n      }\n\n      _this._hasFocus = true;\n    };\n\n    _this._onRootBlur = function (ev) {\n      if (_this.props.onBlur) {\n        _this.props.onBlur(ev);\n      }\n\n      var relatedTarget = ev.relatedTarget;\n\n      if (ev.relatedTarget === null) {\n        // In IE11, due to lack of support, event.relatedTarget is always\n        // null making every onBlur call to be \"outside\" of the ComboBox\n        // even when it's not. Using document.activeElement is another way\n        // for us to be able to get what the relatedTarget without relying\n        // on the event\n        var doc = getDocument(_this._root.current); // @ts-ignore\n\n        relatedTarget = doc.activeElement;\n      } // @ts-ignore\n\n\n      if (!_this._root.current.contains(relatedTarget)) {\n        _this._hasFocus = false;\n      }\n    };\n\n    _this._onFirstBumperFocus = function () {\n      _this._onBumperFocus(true);\n    };\n\n    _this._onLastBumperFocus = function () {\n      _this._onBumperFocus(false);\n    };\n\n    _this._onBumperFocus = function (isFirstBumper) {\n      if (!_this._root.current) {\n        return;\n      }\n\n      var currentBumper = isFirstBumper === _this._hasFocus ? _this._lastBumper.current : _this._firstBumper.current;\n      var nextFocusable = isFirstBumper === _this._hasFocus ? getLastTabbable(_this._root.current, currentBumper, true, false) : getFirstTabbable(_this._root.current, currentBumper, true, false);\n\n      if (nextFocusable) {\n        if (_this._isBumper(nextFocusable)) {\n          // This can happen when FTZ contains no tabbable elements. Focus will take care of finding a focusable element in FTZ.\n          _this._findElementAndFocusAsync();\n        } else {\n          nextFocusable.focus();\n        }\n      }\n    };\n\n    _this._enableFocusTrapZone = function () {\n      var _this$props$disabled = _this.props.disabled,\n          disabled = _this$props$disabled === void 0 ? false : _this$props$disabled;\n\n      if (disabled) {\n        return;\n      }\n\n      FocusTrapZone._focusStack.push(_assertThisInitialized(_this));\n\n      _this._bringFocusIntoZone();\n\n      _this._hideContentFromAccessibilityTree();\n    };\n\n    _this._bringFocusIntoZone = function () {\n      var _this$props$disableFi = _this.props.disableFirstFocus,\n          disableFirstFocus = _this$props$disableFi === void 0 ? false : _this$props$disableFi;\n      _this._previouslyFocusedElementOutsideTrapZone = _this._getPreviouslyFocusedElementOutsideTrapZone();\n\n      if ( // @ts-ignore\n      !_this._root.current.contains(_this._previouslyFocusedElementOutsideTrapZone) && !disableFirstFocus) {\n        _this._findElementAndFocusAsync();\n      }\n    };\n\n    _this._releaseFocusTrapZone = function () {\n      var ignoreExternalFocusing = _this.props.ignoreExternalFocusing;\n      FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter(function (value) {\n        return _assertThisInitialized(_this) !== value;\n      }); // try to focus element which triggered FocusTrapZone - prviously focused element outside trap zone\n\n      var doc = getDocument(_this._root.current); // @ts-ignore\n\n      var activeElement = doc.activeElement;\n\n      if (!ignoreExternalFocusing && _this._previouslyFocusedElementOutsideTrapZone && ( // @ts-ignore\n      _this._root.current.contains(activeElement) || activeElement === doc.body)) {\n        _this._focusAsync(_this._previouslyFocusedElementOutsideTrapZone);\n      } // if last active focus trap zone is going to be released - show previously hidden content in accessibility tree\n\n\n      var lastActiveFocusTrap = FocusTrapZone._focusStack.length && FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1];\n\n      if (!lastActiveFocusTrap) {\n        _this._showContentInAccessibilityTree();\n      } else if (lastActiveFocusTrap._root.current && lastActiveFocusTrap._root.current.hasAttribute(HIDDEN_FROM_ACC_TREE)) {\n        lastActiveFocusTrap._root.current.removeAttribute(HIDDEN_FROM_ACC_TREE);\n\n        lastActiveFocusTrap._root.current.removeAttribute('aria-hidden');\n      }\n    };\n\n    _this._findElementAndFocusAsync = function () {\n      if (!_this._root.current) {\n        return;\n      }\n\n      var _this$props = _this.props,\n          focusPreviouslyFocusedInnerElement = _this$props.focusPreviouslyFocusedInnerElement,\n          firstFocusableSelector = _this$props.firstFocusableSelector;\n\n      if (focusPreviouslyFocusedInnerElement && _this._previouslyFocusedElementInTrapZone && _this._root.current.contains(_this._previouslyFocusedElementInTrapZone)) {\n        // focus on the last item that had focus in the zone before we left the zone\n        _this._focusAsync(_this._previouslyFocusedElementInTrapZone);\n\n        return;\n      }\n\n      var focusSelector = firstFocusableSelector && (typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector());\n      var firstFocusableChild = null;\n\n      if (focusSelector) {\n        firstFocusableChild = _this._root.current.querySelector(focusSelector);\n      } // Fall back to first element if query selector did not match any elements.\n\n\n      if (!firstFocusableChild) {\n        firstFocusableChild = getNextElement(_this._root.current, _this._root.current.firstChild, false, false, false, true);\n      }\n\n      firstFocusableChild && _this._focusAsync(firstFocusableChild);\n    };\n\n    _this._onFocusCapture = function (ev) {\n      _this.props.onFocusCapture && _this.props.onFocusCapture(ev);\n\n      if (ev.target !== ev.currentTarget && !_this._isBumper(ev.target)) {\n        // every time focus changes within the trap zone, remember the focused element so that\n        // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n        _this._previouslyFocusedElementInTrapZone = ev.target;\n      }\n    };\n\n    _this._forceFocusInTrap = function (ev, triggeredElement) {\n      if (FocusTrapZone._focusStack.length && _assertThisInitialized(_this) === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n        // @ts-ignore\n        if (!_this._root.current.contains(triggeredElement)) {\n          _this._findElementAndFocusAsync();\n\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    _this._handleOutsideFocus = function (ev) {\n      var doc = getDocument(_this._root.current); // @ts-ignore\n\n      var focusedElement = doc.activeElement;\n      focusedElement && _this._forceFocusInTrap(ev, focusedElement);\n    };\n\n    _this._handleOutsideClick = function (ev) {\n      var clickedElement = ev.target;\n      var _this$props2 = _this.props,\n          isClickableOutsideFocusTrap = _this$props2.isClickableOutsideFocusTrap,\n          focusTriggerOnOutsideClick = _this$props2.focusTriggerOnOutsideClick;\n\n      if (!isClickableOutsideFocusTrap) {\n        clickedElement && _this._forceFocusInTrap(ev, clickedElement);\n      } else if (!focusTriggerOnOutsideClick) {\n        var isOutsideFocusTrapZone = _this._root.current && !_this._root.current.contains(clickedElement);\n        var isOutsideTriggerElement = _this._previouslyFocusedElementOutsideTrapZone && !_this._previouslyFocusedElementOutsideTrapZone.contains(clickedElement);\n\n        if (isOutsideFocusTrapZone && isOutsideTriggerElement) {\n          // set it to NULL, so the trigger will not be focused on componentWillUnmount\n          // @ts-ignore\n          _this._previouslyFocusedElementOutsideTrapZone = null;\n        }\n      }\n    };\n\n    _this._onKeyboardHandler = function (ev) {\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n      } // do not propogate keyboard events outside focus trap zone\n      // https://github.com/microsoft/fluent-ui-react/pull/1180\n\n\n      ev.stopPropagation();\n    };\n\n    _this._getPreviouslyFocusedElementOutsideTrapZone = function () {\n      var elementToFocusOnDismiss = _this.props.elementToFocusOnDismiss;\n      var previouslyFocusedElement = _this._previouslyFocusedElementOutsideTrapZone;\n\n      if (elementToFocusOnDismiss && previouslyFocusedElement !== elementToFocusOnDismiss) {\n        previouslyFocusedElement = elementToFocusOnDismiss;\n      } else if (!previouslyFocusedElement) {\n        var doc = getDocument(_this._root.current); // @ts-ignore\n\n        previouslyFocusedElement = doc.activeElement;\n      }\n\n      return previouslyFocusedElement;\n    };\n\n    _this._hideContentFromAccessibilityTree = function () {\n      var doc = getDocument(_this._root.current); // @ts-ignore\n\n      var bodyChildren = doc.body && doc.body.children || []; // @ts-ignore\n\n      if (bodyChildren.length && !doc.body.contains(_this._root.current)) {\n        // In case popup render options will change\n\n        /* eslint-disable-next-line no-console */\n        console.warn('Body element does not contain trap zone element. Please, ensure the trap zone element is placed inside body, so it will work properly.');\n      }\n\n      for (var index = 0; index < bodyChildren.length; index++) {\n        var currentChild = bodyChildren[index];\n        var isOrHasFocusTrapZone = currentChild === _this._root.current || currentChild.contains(_this._root.current);\n        var isAriaLiveRegion = currentChild.hasAttribute('aria-live');\n\n        if (!isOrHasFocusTrapZone && !isAriaLiveRegion && currentChild.getAttribute('aria-hidden') !== 'true') {\n          currentChild.setAttribute('aria-hidden', 'true');\n          currentChild.setAttribute(HIDDEN_FROM_ACC_TREE, 'true');\n        }\n      }\n    };\n\n    _this._showContentInAccessibilityTree = function () {\n      var doc = getDocument(_this._root.current); // @ts-ignore\n\n      var hiddenElements = doc.querySelectorAll(\"[\" + HIDDEN_FROM_ACC_TREE + \"=\\\"true\\\"]\");\n\n      for (var index = 0; index < hiddenElements.length; index++) {\n        var element = hiddenElements[index];\n        element.removeAttribute('aria-hidden');\n        element.removeAttribute(HIDDEN_FROM_ACC_TREE);\n      }\n    };\n\n    return _this;\n  }\n\n  var _proto = FocusTrapZone.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this._enableFocusTrapZone();\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var _this$props3 = this.props,\n        forceFocusInsideTrapOnComponentUpdate = _this$props3.forceFocusInsideTrapOnComponentUpdate,\n        forceFocusInsideTrapOnOutsideFocus = _this$props3.forceFocusInsideTrapOnOutsideFocus,\n        disabled = _this$props3.disabled;\n    var doc = getDocument(this._root.current); // @ts-ignore\n\n    var activeElement = doc.activeElement; // if after componentDidUpdate focus is not inside the focus trap, bring it back\n\n    if (!disabled && // @ts-ignore\n    !this._root.current.contains(activeElement) && forceFocusInsideTrapOnComponentUpdate) {\n      this._bringFocusIntoZone();\n\n      return;\n    }\n\n    var prevForceFocusInsideTrap = prevProps.forceFocusInsideTrapOnOutsideFocus !== undefined ? prevProps.forceFocusInsideTrapOnOutsideFocus : true;\n    var newForceFocusInsideTrap = forceFocusInsideTrapOnOutsideFocus !== undefined ? forceFocusInsideTrapOnOutsideFocus : true;\n    var prevDisabled = prevProps.disabled !== undefined ? prevProps.disabled : false;\n    var newDisabled = disabled !== undefined ? disabled : false;\n\n    if (!prevForceFocusInsideTrap && newForceFocusInsideTrap || prevDisabled && !newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n      // Emulate what happens when a FocusTrapZone gets mounted.\n      this._enableFocusTrapZone();\n    } else if (prevForceFocusInsideTrap && !newForceFocusInsideTrap || !prevDisabled && newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      // Emulate what happens when a FocusTrapZone gets unmounted.\n      this._releaseFocusTrapZone();\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    // don't handle return focus unless forceFocusInsideTrapOnOutsideFocus is true or focus is still within FocusTrapZone\n    var doc = getDocument(this._root.current);\n\n    if (!this.props.disabled || this.props.forceFocusInsideTrapOnOutsideFocus || // @ts-ignore\n    !this._root.current.contains(doc.activeElement)) {\n      this._releaseFocusTrapZone();\n    } // Dispose of element references so the DOM Nodes can be garbage-collected\n\n\n    delete this._previouslyFocusedElementInTrapZone;\n    delete this._previouslyFocusedElementOutsideTrapZone;\n  };\n\n  _proto.render = function render() {\n    var _this$props4 = this.props,\n        className = _this$props4.className,\n        forceFocusInsideTrapOnOutsideFocus = _this$props4.forceFocusInsideTrapOnOutsideFocus,\n        ariaLabelledBy = _this$props4.ariaLabelledBy,\n        _this$props4$disabled = _this$props4.disabled,\n        disabled = _this$props4$disabled === void 0 ? false : _this$props4$disabled;\n    var unhandledProps = getUnhandledProps(_keys(FocusTrapZone.propTypes), this.props);\n    var ElementType = getElementType(this.props);\n    var bumperProps = {\n      style: {\n        pointerEvents: 'none',\n        position: 'fixed' // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n\n      },\n      tabIndex: disabled ? -1 : 0,\n      // make bumpers tabbable only when enabled\n      'data-is-visible': true\n    };\n    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(ElementType, _extends({}, unhandledProps, {\n      className: className,\n      ref: this.createRef,\n      \"aria-labelledby\": ariaLabelledBy,\n      onKeyDown: this._onKeyboardHandler,\n      onFocusCapture: this._onFocusCapture,\n      onFocus: this._onRootFocus,\n      onBlur: this._onRootBlur\n    }), /*#__PURE__*/React.createElement(\"div\", _extends({}, bumperProps, {\n      ref: this._firstBumper,\n      onFocus: this._onFirstBumperFocus\n    })), this.props.children, /*#__PURE__*/React.createElement(\"div\", _extends({}, bumperProps, {\n      ref: this._lastBumper,\n      onFocus: this._onLastBumperFocus\n    }))), forceFocusInsideTrapOnOutsideFocus && /*#__PURE__*/React.createElement(EventListener, {\n      capture: true,\n      listener: this._handleOutsideFocus,\n      targetRef: this.windowRef,\n      type: \"focus\"\n    }), this.shouldHandleOutsideClick() && /*#__PURE__*/React.createElement(EventListener, {\n      capture: true,\n      listener: this._handleOutsideClick,\n      targetRef: this.windowRef,\n      type: \"click\"\n    }));\n  };\n\n  _proto._isBumper = function _isBumper(element) {\n    return element === this._firstBumper.current || element === this._lastBumper.current;\n  };\n\n  _proto._focusAsync = function _focusAsync(element) {\n    if (!this._isBumper(element)) {\n      focusAsync(element);\n    }\n  };\n\n  return FocusTrapZone;\n}(React.Component);\nFocusTrapZone._focusStack = [];\nFocusTrapZone.propTypes = {\n  as: PropTypes.elementType,\n  className: PropTypes.string,\n  elementToFocusOnDismiss: PropTypes.object,\n  ariaLabelledBy: PropTypes.string,\n  isClickableOutsideFocusTrap: PropTypes.bool,\n  ignoreExternalFocusing: PropTypes.bool,\n  forceFocusInsideTrapOnOutsideFocus: PropTypes.bool,\n  forceFocusInsideTrapOnComponentUpdate: PropTypes.bool,\n  firstFocusableSelector: PropTypes.string,\n  disableFirstFocus: PropTypes.bool,\n  focusPreviouslyFocusedInnerElement: PropTypes.bool,\n  focusTriggerOnOutsideClick: PropTypes.bool\n};\nFocusTrapZone.defaultProps = {\n  as: 'div',\n  isClickableOutsideFocusTrap: true,\n  forceFocusInsideTrapOnOutsideFocus: false\n};","map":{"version":3,"sources":["FocusZone/FocusTrapZone.tsx"],"names":["FocusTrapZone","React","_focusStack","current","ReactDOM","getWindow","propTypes","as","PropTypes","className","elementToFocusOnDismiss","ariaLabelledBy","isClickableOutsideFocusTrap","ignoreExternalFocusing","forceFocusInsideTrapOnOutsideFocus","forceFocusInsideTrapOnComponentUpdate","firstFocusableSelector","disableFirstFocus","focusPreviouslyFocusedInnerElement","focusTriggerOnOutsideClick","bool","defaultProps","componentDidMount","componentDidUpdate","disabled","doc","getDocument","activeElement","prevForceFocusInsideTrap","prevProps","newForceFocusInsideTrap","prevDisabled","newDisabled","componentWillUnmount","render","unhandledProps","getUnhandledProps","ElementType","getElementType","bumperProps","style","pointerEvents","position","tabIndex","_onRootBlur","_onFirstBumperFocus","_onLastBumperFocus","relatedTarget","ev","_isBumper","element","currentBumper","isFirstBumper","nextFocusable","getLastTabbable","getFirstTabbable","_focusAsync","focusAsync","lastActiveFocusTrap","focusSelector","firstFocusableChild","getNextElement","focusedElement","clickedElement","isOutsideFocusTrapZone","isOutsideTriggerElement","previouslyFocusedElement","bodyChildren","console","index","currentChild","isOrHasFocusTrapZone","isAriaLiveRegion","hiddenElements"],"mappings":"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","sourcesContent":["import { EventListener } from '@fluentui/react-component-event-listener';\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport * as PropTypes from 'prop-types';\nimport * as _ from 'lodash';\n\nimport { getElementType } from '../utils/getElementType';\nimport { getUnhandledProps } from '../utils/getUnhandledProps';\nimport {\n  getNextElement,\n  getFirstTabbable,\n  getLastTabbable,\n  getWindow,\n  getDocument,\n  focusAsync,\n  HIDDEN_FROM_ACC_TREE,\n} from './focusUtilities';\nimport { FocusTrapZoneProps } from './FocusTrapZone.types';\n\n/** FocusTrapZone is used to trap the focus in any html element placed in body\n *  and hide other elements outside of Focus Trap Zone from accessibility tree.\n *  Pressing tab will circle focus within the inner focusable elements of the FocusTrapZone. */\nexport class FocusTrapZone extends React.Component<FocusTrapZoneProps, {}> {\n  static _focusStack: FocusTrapZone[] = [];\n\n  _root: { current: HTMLElement | null } = { current: null };\n\n  _previouslyFocusedElementOutsideTrapZone: HTMLElement;\n  _previouslyFocusedElementInTrapZone?: HTMLElement;\n\n  _firstBumper = React.createRef<HTMLDivElement>();\n  _lastBumper = React.createRef<HTMLDivElement>();\n  _hasFocus: boolean = false;\n\n  windowRef = React.createRef<Window>() as React.MutableRefObject<Window>;\n\n  // @ts-ignore\n  createRef = elem => {\n    this._root.current = ReactDOM.findDOMNode(elem) as HTMLElement;\n    // @ts-ignore\n    this.windowRef.current = getWindow(this._root.current);\n  };\n\n  shouldHandleOutsideClick = () => !this.props.isClickableOutsideFocusTrap || !this.props.focusTriggerOnOutsideClick;\n\n  static propTypes = {\n    as: PropTypes.elementType,\n    className: PropTypes.string,\n    elementToFocusOnDismiss: PropTypes.object,\n    ariaLabelledBy: PropTypes.string,\n    isClickableOutsideFocusTrap: PropTypes.bool,\n    ignoreExternalFocusing: PropTypes.bool,\n    forceFocusInsideTrapOnOutsideFocus: PropTypes.bool,\n    forceFocusInsideTrapOnComponentUpdate: PropTypes.bool,\n    firstFocusableSelector: PropTypes.string,\n    disableFirstFocus: PropTypes.bool,\n    focusPreviouslyFocusedInnerElement: PropTypes.bool,\n    focusTriggerOnOutsideClick: PropTypes.bool,\n  };\n\n  static defaultProps: FocusTrapZoneProps = {\n    as: 'div',\n    isClickableOutsideFocusTrap: true,\n    forceFocusInsideTrapOnOutsideFocus: false,\n  };\n\n  componentDidMount(): void {\n    this._enableFocusTrapZone();\n  }\n\n  componentDidUpdate(prevProps: FocusTrapZoneProps): void {\n    const { forceFocusInsideTrapOnComponentUpdate, forceFocusInsideTrapOnOutsideFocus, disabled } = this.props;\n    const doc = getDocument(this._root.current);\n    // @ts-ignore\n    const activeElement = doc.activeElement as HTMLElement;\n\n    // if after componentDidUpdate focus is not inside the focus trap, bring it back\n    if (\n      !disabled &&\n      // @ts-ignore\n      !this._root.current.contains(activeElement) &&\n      forceFocusInsideTrapOnComponentUpdate\n    ) {\n      this._bringFocusIntoZone();\n      return;\n    }\n\n    const prevForceFocusInsideTrap =\n      prevProps.forceFocusInsideTrapOnOutsideFocus !== undefined ? prevProps.forceFocusInsideTrapOnOutsideFocus : true;\n    const newForceFocusInsideTrap =\n      forceFocusInsideTrapOnOutsideFocus !== undefined ? forceFocusInsideTrapOnOutsideFocus : true;\n    const prevDisabled = prevProps.disabled !== undefined ? prevProps.disabled : false;\n    const newDisabled = disabled !== undefined ? disabled : false;\n\n    if ((!prevForceFocusInsideTrap && newForceFocusInsideTrap) || (prevDisabled && !newDisabled)) {\n      // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n      // Emulate what happens when a FocusTrapZone gets mounted.\n      this._enableFocusTrapZone();\n    } else if ((prevForceFocusInsideTrap && !newForceFocusInsideTrap) || (!prevDisabled && newDisabled)) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      // Emulate what happens when a FocusTrapZone gets unmounted.\n      this._releaseFocusTrapZone();\n    }\n  }\n\n  componentWillUnmount(): void {\n    // don't handle return focus unless forceFocusInsideTrapOnOutsideFocus is true or focus is still within FocusTrapZone\n    const doc = getDocument(this._root.current);\n    if (\n      !this.props.disabled ||\n      this.props.forceFocusInsideTrapOnOutsideFocus ||\n      // @ts-ignore\n      !this._root.current.contains(doc.activeElement as HTMLElement)\n    ) {\n      this._releaseFocusTrapZone();\n    }\n\n    // Dispose of element references so the DOM Nodes can be garbage-collected\n    delete this._previouslyFocusedElementInTrapZone;\n    delete this._previouslyFocusedElementOutsideTrapZone;\n  }\n\n  render(): JSX.Element {\n    const { className, forceFocusInsideTrapOnOutsideFocus, ariaLabelledBy, disabled = false } = this.props;\n    const unhandledProps = getUnhandledProps(_.keys(FocusTrapZone.propTypes) as any, this.props);\n    const ElementType = getElementType(this.props);\n\n    const bumperProps = {\n      style: {\n        pointerEvents: 'none',\n        position: 'fixed', // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n      },\n      tabIndex: disabled ? -1 : 0, // make bumpers tabbable only when enabled\n      'data-is-visible': true,\n    } as React.HTMLAttributes<HTMLDivElement>;\n\n    return (\n      <>\n        <ElementType\n          {...unhandledProps}\n          className={className}\n          ref={this.createRef}\n          aria-labelledby={ariaLabelledBy}\n          onKeyDown={this._onKeyboardHandler}\n          onFocusCapture={this._onFocusCapture}\n          onFocus={this._onRootFocus}\n          onBlur={this._onRootBlur}\n        >\n          <div {...bumperProps} ref={this._firstBumper} onFocus={this._onFirstBumperFocus} />\n          {this.props.children}\n          <div {...bumperProps} ref={this._lastBumper} onFocus={this._onLastBumperFocus} />\n        </ElementType>\n\n        {forceFocusInsideTrapOnOutsideFocus && (\n          <EventListener capture listener={this._handleOutsideFocus} targetRef={this.windowRef} type=\"focus\" />\n        )}\n        {this.shouldHandleOutsideClick() && (\n          <EventListener capture listener={this._handleOutsideClick} targetRef={this.windowRef} type=\"click\" />\n        )}\n      </>\n    );\n  }\n\n  _onRootFocus = (ev: React.FocusEvent<HTMLDivElement>) => {\n    if (this.props.onFocus) {\n      this.props.onFocus(ev);\n    }\n\n    this._hasFocus = true;\n  };\n\n  _onRootBlur = (ev: React.FocusEvent<HTMLDivElement>) => {\n    if (this.props.onBlur) {\n      this.props.onBlur(ev);\n    }\n\n    let relatedTarget = ev.relatedTarget;\n    if (ev.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the ComboBox\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      const doc = getDocument(this._root.current);\n      // @ts-ignore\n      relatedTarget = doc.activeElement as Element;\n    }\n\n    // @ts-ignore\n    if (!this._root.current.contains(relatedTarget as HTMLElement)) {\n      this._hasFocus = false;\n    }\n  };\n\n  _onFirstBumperFocus = () => {\n    this._onBumperFocus(true);\n  };\n\n  _onLastBumperFocus = () => {\n    this._onBumperFocus(false);\n  };\n\n  _isBumper(element: HTMLElement): boolean {\n    return element === this._firstBumper.current || element === this._lastBumper.current;\n  }\n\n  _onBumperFocus = (isFirstBumper: boolean) => {\n    if (!this._root.current) {\n      return;\n    }\n\n    const currentBumper = (isFirstBumper === this._hasFocus\n      ? this._lastBumper.current\n      : this._firstBumper.current) as HTMLElement;\n\n    const nextFocusable =\n      isFirstBumper === this._hasFocus\n        ? getLastTabbable(this._root.current, currentBumper, true, false)\n        : getFirstTabbable(this._root.current, currentBumper, true, false);\n\n    if (nextFocusable) {\n      if (this._isBumper(nextFocusable)) {\n        // This can happen when FTZ contains no tabbable elements. Focus will take care of finding a focusable element in FTZ.\n        this._findElementAndFocusAsync();\n      } else {\n        nextFocusable.focus();\n      }\n    }\n  };\n\n  _focusAsync(element: HTMLElement): void {\n    if (!this._isBumper(element)) {\n      focusAsync(element);\n    }\n  }\n\n  _enableFocusTrapZone = () => {\n    const { disabled = false } = this.props;\n    if (disabled) {\n      return;\n    }\n\n    FocusTrapZone._focusStack.push(this);\n\n    this._bringFocusIntoZone();\n    this._hideContentFromAccessibilityTree();\n  };\n\n  _bringFocusIntoZone = () => {\n    const { disableFirstFocus = false } = this.props;\n\n    this._previouslyFocusedElementOutsideTrapZone = this._getPreviouslyFocusedElementOutsideTrapZone();\n\n    if (\n      // @ts-ignore\n      !this._root.current.contains(this._previouslyFocusedElementOutsideTrapZone) &&\n      !disableFirstFocus\n    ) {\n      this._findElementAndFocusAsync();\n    }\n  };\n\n  _releaseFocusTrapZone = () => {\n    const { ignoreExternalFocusing } = this.props;\n\n    FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter((value: FocusTrapZone) => {\n      return this !== value;\n    });\n\n    // try to focus element which triggered FocusTrapZone - prviously focused element outside trap zone\n    const doc = getDocument(this._root.current);\n    // @ts-ignore\n    const activeElement = doc.activeElement as HTMLElement;\n    if (\n      !ignoreExternalFocusing &&\n      this._previouslyFocusedElementOutsideTrapZone &&\n      // @ts-ignore\n      (this._root.current.contains(activeElement) || activeElement === doc.body)\n    ) {\n      this._focusAsync(this._previouslyFocusedElementOutsideTrapZone);\n    }\n\n    // if last active focus trap zone is going to be released - show previously hidden content in accessibility tree\n    const lastActiveFocusTrap =\n      FocusTrapZone._focusStack.length && FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1];\n\n    if (!lastActiveFocusTrap) {\n      this._showContentInAccessibilityTree();\n    } else if (\n      lastActiveFocusTrap._root.current &&\n      lastActiveFocusTrap._root.current.hasAttribute(HIDDEN_FROM_ACC_TREE)\n    ) {\n      lastActiveFocusTrap._root.current.removeAttribute(HIDDEN_FROM_ACC_TREE);\n      lastActiveFocusTrap._root.current.removeAttribute('aria-hidden');\n    }\n  };\n\n  _findElementAndFocusAsync = () => {\n    if (!this._root.current) {\n      return;\n    }\n\n    const { focusPreviouslyFocusedInnerElement, firstFocusableSelector } = this.props;\n\n    if (\n      focusPreviouslyFocusedInnerElement &&\n      this._previouslyFocusedElementInTrapZone &&\n      this._root.current.contains(this._previouslyFocusedElementInTrapZone)\n    ) {\n      // focus on the last item that had focus in the zone before we left the zone\n      this._focusAsync(this._previouslyFocusedElementInTrapZone);\n      return;\n    }\n\n    const focusSelector =\n      firstFocusableSelector &&\n      (typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector());\n\n    let firstFocusableChild: HTMLElement | null = null;\n\n    if (focusSelector) {\n      firstFocusableChild = this._root.current.querySelector(focusSelector);\n    }\n\n    // Fall back to first element if query selector did not match any elements.\n    if (!firstFocusableChild) {\n      firstFocusableChild = getNextElement(\n        this._root.current,\n        this._root.current.firstChild as HTMLElement,\n        false,\n        false,\n        false,\n        true,\n      );\n    }\n\n    firstFocusableChild && this._focusAsync(firstFocusableChild);\n  };\n\n  _onFocusCapture = (ev: React.FocusEvent<HTMLDivElement>) => {\n    this.props.onFocusCapture && this.props.onFocusCapture(ev);\n    if (ev.target !== ev.currentTarget && !this._isBumper(ev.target)) {\n      // every time focus changes within the trap zone, remember the focused element so that\n      // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n      this._previouslyFocusedElementInTrapZone = ev.target as HTMLElement;\n    }\n  };\n\n  _forceFocusInTrap = (ev: Event, triggeredElement: HTMLElement) => {\n    if (FocusTrapZone._focusStack.length && this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n      // @ts-ignore\n      if (!this._root.current.contains(triggeredElement)) {\n        this._findElementAndFocusAsync();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  _handleOutsideFocus = (ev: FocusEvent): void => {\n    const doc = getDocument(this._root.current);\n    // @ts-ignore\n    const focusedElement = doc.activeElement as HTMLElement;\n    focusedElement && this._forceFocusInTrap(ev, focusedElement);\n  };\n\n  _handleOutsideClick = (ev: MouseEvent): void => {\n    const clickedElement = ev.target as HTMLElement;\n    const { isClickableOutsideFocusTrap, focusTriggerOnOutsideClick } = this.props;\n\n    if (!isClickableOutsideFocusTrap) {\n      clickedElement && this._forceFocusInTrap(ev, clickedElement);\n    } else if (!focusTriggerOnOutsideClick) {\n      const isOutsideFocusTrapZone = this._root.current && !this._root.current.contains(clickedElement);\n      const isOutsideTriggerElement =\n        this._previouslyFocusedElementOutsideTrapZone &&\n        !this._previouslyFocusedElementOutsideTrapZone.contains(clickedElement);\n      if (isOutsideFocusTrapZone && isOutsideTriggerElement) {\n        // set it to NULL, so the trigger will not be focused on componentWillUnmount\n        // @ts-ignore\n        this._previouslyFocusedElementOutsideTrapZone = null;\n      }\n    }\n  };\n\n  _onKeyboardHandler = (ev: React.KeyboardEvent<HTMLDivElement>): void => {\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // do not propogate keyboard events outside focus trap zone\n    // https://github.com/microsoft/fluent-ui-react/pull/1180\n    ev.stopPropagation();\n  };\n\n  _getPreviouslyFocusedElementOutsideTrapZone = () => {\n    const { elementToFocusOnDismiss } = this.props;\n    let previouslyFocusedElement = this._previouslyFocusedElementOutsideTrapZone;\n\n    if (elementToFocusOnDismiss && previouslyFocusedElement !== elementToFocusOnDismiss) {\n      previouslyFocusedElement = elementToFocusOnDismiss;\n    } else if (!previouslyFocusedElement) {\n      const doc = getDocument(this._root.current);\n      // @ts-ignore\n      previouslyFocusedElement = doc.activeElement as HTMLElement;\n    }\n\n    return previouslyFocusedElement;\n  };\n\n  _hideContentFromAccessibilityTree = () => {\n    const doc = getDocument(this._root.current);\n    // @ts-ignore\n    const bodyChildren = (doc.body && doc.body.children) || [];\n\n    // @ts-ignore\n    if (bodyChildren.length && !doc.body.contains(this._root.current)) {\n      // In case popup render options will change\n      /* eslint-disable-next-line no-console */\n      console.warn(\n        'Body element does not contain trap zone element. Please, ensure the trap zone element is placed inside body, so it will work properly.',\n      );\n    }\n\n    for (let index = 0; index < bodyChildren.length; index++) {\n      const currentChild = bodyChildren[index] as HTMLElement;\n      const isOrHasFocusTrapZone = currentChild === this._root.current || currentChild.contains(this._root.current);\n      const isAriaLiveRegion = currentChild.hasAttribute('aria-live');\n\n      if (!isOrHasFocusTrapZone && !isAriaLiveRegion && currentChild.getAttribute('aria-hidden') !== 'true') {\n        currentChild.setAttribute('aria-hidden', 'true');\n        currentChild.setAttribute(HIDDEN_FROM_ACC_TREE, 'true');\n      }\n    }\n  };\n\n  _showContentInAccessibilityTree = () => {\n    const doc = getDocument(this._root.current);\n    // @ts-ignore\n    const hiddenElements = doc.querySelectorAll(`[${HIDDEN_FROM_ACC_TREE}=\"true\"]`);\n    for (let index = 0; index < hiddenElements.length; index++) {\n      const element = hiddenElements[index];\n      element.removeAttribute('aria-hidden');\n      element.removeAttribute(HIDDEN_FROM_ACC_TREE);\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}