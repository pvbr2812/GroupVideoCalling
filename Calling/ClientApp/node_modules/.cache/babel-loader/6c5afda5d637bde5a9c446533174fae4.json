{"ast":null,"code":"import _get from \"lodash/get\";\nimport _map from \"lodash/map\";\nimport _debounce from \"lodash/debounce\";\nimport _invoke from \"lodash/invoke\";\nimport _forEachRight from \"lodash/forEachRight\";\nimport { toolbarBehavior, toggleButtonBehavior, IS_FOCUSABLE_ATTRIBUTE } from '@fluentui/accessibility';\nimport { compose, getElementType, getFirstFocusable, useFluentContext, useAccessibility, useStyles, useTelemetry, useUnhandledProps } from '@fluentui/react-bindings';\nimport { EventListener } from '@fluentui/react-component-event-listener';\nimport { handleRef, Ref } from '@fluentui/react-component-ref';\nimport { MoreIcon } from '@fluentui/react-icons-northstar';\nimport * as customPropTypes from '@fluentui/react-proptypes';\nimport * as PropTypes from 'prop-types';\nimport * as React from 'react';\nimport { childrenExist, createShorthand, commonPropTypes } from '../../utils';\nimport { ToolbarCustomItem } from './ToolbarCustomItem';\nimport { ToolbarDivider } from './ToolbarDivider';\nimport { ToolbarItem } from './ToolbarItem';\nimport { ToolbarItemWrapper } from './ToolbarItemWrapper';\nimport { ToolbarItemIcon } from './ToolbarItemIcon';\nimport { ToolbarMenu } from './ToolbarMenu';\nimport { ToolbarMenuDivider } from './ToolbarMenuDivider';\nimport { ToolbarMenuItem } from './ToolbarMenuItem';\nimport { ToolbarMenuRadioGroup } from './ToolbarMenuRadioGroup';\nimport { ToolbarMenuRadioGroupWrapper } from './ToolbarMenuRadioGroupWrapper';\nimport { ToolbarRadioGroup } from './ToolbarRadioGroup';\nimport { ToolbarVariablesProvider } from './toolbarVariablesContext';\nimport { ToolbarMenuItemSubmenuIndicator } from './ToolbarMenuItemSubmenuIndicator';\nimport { ToolbarMenuItemIcon } from './ToolbarMenuItemIcon';\nimport { ToolbarMenuItemActiveIndicator } from './ToolbarMenuItemActiveIndicator';\nimport { ToolbarMenuContextProvider } from './toolbarMenuContext';\nvar WAS_FOCUSABLE_ATTRIBUTE = 'data-was-focusable';\nexport var toolbarClassName = 'ui-toolbar';\n/**\n * A Toolbar is a container for grouping a set of controls, often action controls (e.g. buttons) or input controls (e.g. checkboxes).\n *\n * @accessibility\n *  * Implements [ARIA Toolbar](https://www.w3.org/TR/wai-aria-practices-1.1/#toolbar) design pattern.\n * @accessibilityIssues\n * [Issue 988424: VoiceOver narrates selected for button in toolbar](https://bugs.chromium.org/p/chromium/issues/detail?id=988424)\n */\n\nexport var Toolbar = /*#__PURE__*/function () {\n  var Toolbar = compose(function (props, ref, composeOptions) {\n    var context = useFluentContext();\n\n    var _useTelemetry = useTelemetry(composeOptions.displayName, context.telemetry),\n        setStart = _useTelemetry.setStart,\n        setEnd = _useTelemetry.setEnd;\n\n    setStart();\n    var accessibility = props.accessibility,\n        className = props.className,\n        children = props.children,\n        design = props.design,\n        getOverflowItems = props.getOverflowItems,\n        items = props.items,\n        overflow = props.overflow,\n        overflowItem = props.overflowItem,\n        overflowOpen = props.overflowOpen,\n        styles = props.styles,\n        variables = props.variables;\n    var overflowContainerRef = React.useRef();\n    var overflowItemWrapperRef = React.useRef();\n    var offsetMeasureRef = React.useRef();\n    var containerRef = React.useRef(); // index of the last visible item in Toolbar, the rest goes to overflow menu\n\n    var lastVisibleItemIndex = React.useRef();\n    var animationFrameId = React.useRef();\n    var getA11Props = useAccessibility(accessibility, {\n      debugName: composeOptions.displayName,\n      rtl: context.rtl\n    });\n\n    var _useStyles = useStyles(composeOptions.displayName, {\n      className: toolbarClassName,\n      composeOptions: composeOptions,\n      mapPropsToInlineStyles: function mapPropsToInlineStyles() {\n        return {\n          className: className,\n          design: design,\n          styles: styles,\n          variables: variables\n        };\n      },\n      rtl: context.rtl,\n      unstable_props: props\n    }),\n        classes = _useStyles.classes;\n\n    var ElementType = getElementType(props);\n    var slotProps = composeOptions.resolveSlotProps(props);\n    var unhandledProps = useUnhandledProps(composeOptions.handledProps, props);\n\n    var hide = function hide(el) {\n      if (el.style.visibility === 'hidden') {\n        return;\n      }\n\n      if (context.target.activeElement === el || el.contains(context.target.activeElement)) {\n        if (containerRef.current) {\n          var firstFocusableItem = getFirstFocusable(containerRef.current, containerRef.current.firstElementChild);\n\n          if (firstFocusableItem) {\n            firstFocusableItem.focus();\n          }\n        }\n      }\n\n      el.style.visibility = 'hidden';\n      var wasFocusable = el.getAttribute(IS_FOCUSABLE_ATTRIBUTE);\n\n      if (wasFocusable) {\n        el.setAttribute(WAS_FOCUSABLE_ATTRIBUTE, wasFocusable);\n      }\n\n      el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, 'false');\n    };\n\n    var show = function show(el) {\n      if (el.style.visibility !== 'hidden') {\n        return false;\n      }\n\n      el.style.visibility = '';\n      var wasFocusable = el.getAttribute(WAS_FOCUSABLE_ATTRIBUTE);\n\n      if (wasFocusable) {\n        el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, wasFocusable);\n        el.removeAttribute(WAS_FOCUSABLE_ATTRIBUTE);\n      } else {\n        el.removeAttribute(IS_FOCUSABLE_ATTRIBUTE);\n      }\n\n      return true;\n    };\n    /**\n     * Checks if `item` overflows a `container`.\n     * TODO: check and fix all margin combination\n     */\n\n\n    var isItemOverflowing = function isItemOverflowing(itemBoundingRect, containerBoundingRect) {\n      return itemBoundingRect.right > containerBoundingRect.right || itemBoundingRect.left < containerBoundingRect.left;\n    };\n    /**\n     * Checks if `item` would collide with eventual position of `overflowItem`.\n     */\n\n\n    var wouldItemCollide = function wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, containerBoundingRect) {\n      var actualWindow = context.target.defaultView;\n      var wouldCollide;\n\n      if (context.rtl) {\n        var itemLeftMargin = parseFloat(actualWindow.getComputedStyle($item).marginLeft) || 0;\n        wouldCollide = itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin < containerBoundingRect.left; // console.log('Collision [RTL]', {\n        //   wouldCollide,\n        //   'itemBoundingRect.left': itemBoundingRect.left,\n        //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,\n        //   itemRightMargin: itemLeftMargin,\n        //   sum: itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin,\n        //   'overflowContainerBoundingRect.left': containerBoundingRect.left,\n        // })\n      } else {\n        var itemRightMargin = parseFloat(actualWindow.getComputedStyle($item).marginRight) || 0;\n        wouldCollide = itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin > containerBoundingRect.right; // console.log('Collision', {\n        //   wouldCollide,\n        //   'itemBoundingRect.right': itemBoundingRect.right,\n        //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,\n        //   itemRightMargin,\n        //   sum: itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin,\n        //   'overflowContainerBoundingRect.right': containerBoundingRect.right,\n        // })\n      }\n\n      return wouldCollide;\n    };\n    /**\n     * Positions overflowItem next to lastVisible item\n     * TODO: consider overflowItem margin\n     */\n\n\n    var setOverflowPosition = function setOverflowPosition($overflowItem, $lastVisibleItem, lastVisibleItemRect, containerBoundingRect, absolutePositioningOffset) {\n      var actualWindow = context.target.defaultView;\n\n      if ($lastVisibleItem) {\n        if (context.rtl) {\n          var lastVisibleItemMarginLeft = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginLeft) || 0;\n          $overflowItem.style.right = containerBoundingRect.right - lastVisibleItemRect.left + lastVisibleItemMarginLeft + absolutePositioningOffset.horizontal + \"px\";\n        } else {\n          var lastVisibleItemRightMargin = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginRight) || 0;\n          $overflowItem.style.left = lastVisibleItemRect.right - containerBoundingRect.left + lastVisibleItemRightMargin + absolutePositioningOffset.horizontal + \"px\";\n        }\n      } else {\n        // there is no last visible item -> position the overflow as the first item\n        lastVisibleItemIndex.current = -1;\n\n        if (context.rtl) {\n          $overflowItem.style.right = absolutePositioningOffset.horizontal + \"px\";\n        } else {\n          $overflowItem.style.left = absolutePositioningOffset.horizontal + \"px\";\n        }\n      }\n    };\n\n    var hideOverflowItems = function hideOverflowItems() {\n      var $overflowContainer = overflowContainerRef.current;\n      var $overflowItem = overflowItemWrapperRef.current;\n      var $offsetMeasure = offsetMeasureRef.current;\n\n      if (!$overflowContainer || !$overflowItem || !$offsetMeasure) {\n        return;\n      } // workaround: when resizing window with popup opened the container contents scroll for some reason\n\n\n      if (context.rtl) {\n        $overflowContainer.scrollTo(Number.MAX_SAFE_INTEGER, 0);\n      } else {\n        $overflowContainer.scrollTop = 0;\n        $overflowContainer.scrollLeft = 0;\n      }\n\n      var $items = $overflowContainer.children;\n      var overflowContainerBoundingRect = $overflowContainer.getBoundingClientRect();\n      var overflowItemBoundingRect = $overflowItem.getBoundingClientRect();\n      var offsetMeasureBoundingRect = $offsetMeasure.getBoundingClientRect(); // Absolute positioning offset\n      // Overflow menu is absolutely positioned relative to root slot\n      // If there is padding set on the root slot boundingClientRect computations use inner content box,\n      // but absolute position is relative to root slot's PADDING box.\n      // We compute absolute positioning offset\n      // By measuring position of an offsetMeasure element absolutely positioned to 0,0.\n      // TODO: replace by getComputedStyle('padding')\n\n      var absolutePositioningOffset = {\n        horizontal: context.rtl ? offsetMeasureBoundingRect.right - overflowContainerBoundingRect.right : overflowContainerBoundingRect.left - offsetMeasureBoundingRect.left,\n        vertical: overflowContainerBoundingRect.top - offsetMeasureBoundingRect.top\n      };\n      var isOverflowing = false;\n      var $lastVisibleItem;\n      var lastVisibleItemRect; // check all items from the last one back\n\n      _forEachRight($items, function ($item, i) {\n        if ($item === $overflowItem) {\n          return true;\n        }\n\n        var itemBoundingRect = $item.getBoundingClientRect(); // if the item is out of the crop rectangle, hide it\n\n        if (isItemOverflowing(itemBoundingRect, overflowContainerBoundingRect)) {\n          isOverflowing = true; // console.log('Overflow', i, {\n          //   item: [itemBoundingRect.left, itemBoundingRect.right],\n          //   crop: [\n          //     overflowContainerBoundingRect.left,\n          //     overflowContainerBoundingRect.right,\n          //     overflowContainerBoundingRect.width,\n          //   ],\n          //   container: $overflowContainer,\n          // })\n\n          hide($item);\n          return true;\n        } // if there is an overflow, check collision of remaining items with eventual overflow position\n\n\n        if (isOverflowing && !$lastVisibleItem && wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, overflowContainerBoundingRect)) {\n          hide($item);\n          return true;\n        } // Remember the last visible item\n\n\n        if (!$lastVisibleItem) {\n          $lastVisibleItem = $item;\n          lastVisibleItemRect = itemBoundingRect;\n          lastVisibleItemIndex.current = i;\n        }\n\n        return show($item); // exit the loop when first visible item is found\n      }); // if there is an overflow,  position and show overflow item, otherwise hide it\n\n\n      if (isOverflowing || overflowOpen) {\n        $overflowItem.style.position = 'absolute';\n        setOverflowPosition($overflowItem, $lastVisibleItem, lastVisibleItemRect, overflowContainerBoundingRect, absolutePositioningOffset);\n        show($overflowItem);\n      } else {\n        lastVisibleItemIndex.current = items.length - 1;\n        hide($overflowItem);\n      }\n\n      _invoke(props, 'onOverflow', lastVisibleItemIndex.current + 1);\n    };\n\n    var collectOverflowItems = function collectOverflowItems() {\n      // console.log('getOverflowItems()', items.slice(lastVisibleItemIndex.current + 1))\n      return getOverflowItems ? getOverflowItems(lastVisibleItemIndex.current + 1) : items.slice(lastVisibleItemIndex.current + 1);\n    };\n\n    var getVisibleItems = function getVisibleItems() {\n      // console.log('allItems()', items)\n      var end = overflowOpen ? lastVisibleItemIndex.current + 1 : items.length; // console.log('getVisibleItems()', items.slice(0, end))\n\n      return items.slice(0, end);\n    };\n\n    var handleWindowResize = _debounce(function (e) {\n      hideOverflowItems();\n\n      if (overflowOpen) {\n        _invoke(props, 'onOverflowOpenChange', e, Object.assign({}, props, {\n          overflowOpen: false\n        }));\n      }\n    }, 16);\n\n    var renderItems = function renderItems(items) {\n      return _map(items, function (item) {\n        var kind = _get(item, 'kind', 'item');\n\n        switch (kind) {\n          case 'divider':\n            return createShorthand(composeOptions.slots.divider, item, {\n              defaultProps: function defaultProps() {\n                return slotProps.divider;\n              }\n            });\n\n          case 'group':\n            return createShorthand(composeOptions.slots.group, item, {\n              defaultProps: function defaultProps() {\n                return slotProps.group;\n              }\n            });\n\n          case 'toggle':\n            return createShorthand(composeOptions.slots.toggle, item, {\n              defaultProps: function defaultProps() {\n                return slotProps.toggle;\n              }\n            });\n\n          case 'custom':\n            return createShorthand(composeOptions.slots.customItem, item, {\n              defaultProps: function defaultProps() {\n                return slotProps.customItem;\n              }\n            });\n\n          default:\n            return createShorthand(composeOptions.slots.item, item, {\n              defaultProps: function defaultProps() {\n                return slotProps.item;\n              }\n            });\n        }\n      });\n    };\n\n    var renderOverflowItem = function renderOverflowItem(overflowItem) {\n      return createShorthand(composeOptions.slots.overflowItem, overflowItem, {\n        defaultProps: function defaultProps() {\n          return slotProps.overflowItem;\n        },\n        overrideProps: {\n          menu: {\n            items: overflowOpen ? collectOverflowItems() : [],\n            popper: {\n              positionFixed: true\n            }\n          },\n          menuOpen: overflowOpen,\n          onMenuOpenChange: function onMenuOpenChange(e, _ref) {\n            var menuOpen = _ref.menuOpen;\n\n            _invoke(props, 'onOverflowOpenChange', e, Object.assign({}, props, {\n              overflowOpen: menuOpen\n            }));\n          },\n          wrapper: {\n            ref: overflowItemWrapperRef\n          }\n        }\n      });\n    };\n\n    React.useEffect(function () {\n      var actualWindow = context.target.defaultView;\n      actualWindow.cancelAnimationFrame(animationFrameId.current); // Heads up! There are cases (like opening a portal and rendering the Toolbar there immediately) when rAF is necessary\n\n      animationFrameId.current = actualWindow.requestAnimationFrame(function () {\n        hideOverflowItems();\n      });\n      return function () {\n        if (animationFrameId.current !== undefined) {\n          context.target.defaultView.cancelAnimationFrame(animationFrameId.current);\n          animationFrameId.current = undefined;\n        }\n      };\n    });\n    var element = overflow ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Ref, {\n      innerRef: function innerRef(node) {\n        containerRef.current = node;\n        handleRef(ref, node);\n      }\n    }, getA11Props.unstable_wrapWithFocusZone( /*#__PURE__*/React.createElement(ElementType, getA11Props('root', Object.assign({\n      className: classes.root\n    }, unhandledProps)), /*#__PURE__*/React.createElement(\"div\", {\n      className: classes.overflowContainer,\n      ref: overflowContainerRef\n    }, /*#__PURE__*/React.createElement(ToolbarMenuContextProvider, {\n      value: {\n        slots: {\n          menu: composeOptions.slots.menu\n        }\n      }\n    }, /*#__PURE__*/React.createElement(ToolbarVariablesProvider, {\n      value: variables\n    }, childrenExist(children) ? children : renderItems(getVisibleItems()), renderOverflowItem(overflowItem)))), /*#__PURE__*/React.createElement(\"div\", {\n      className: classes.offsetMeasure,\n      ref: offsetMeasureRef\n    })))), /*#__PURE__*/React.createElement(EventListener, {\n      listener: handleWindowResize,\n      target: context.target.defaultView,\n      type: \"resize\"\n    })) : /*#__PURE__*/React.createElement(Ref, {\n      innerRef: function innerRef(node) {\n        containerRef.current = node;\n        handleRef(ref, node);\n      }\n    }, getA11Props.unstable_wrapWithFocusZone( /*#__PURE__*/React.createElement(ElementType, getA11Props('root', Object.assign({\n      className: classes.root\n    }, unhandledProps)), /*#__PURE__*/React.createElement(ToolbarMenuContextProvider, {\n      value: {\n        slots: {\n          menu: composeOptions.slots.menu\n        }\n      }\n    }, /*#__PURE__*/React.createElement(ToolbarVariablesProvider, {\n      value: variables\n    }, childrenExist(children) ? children : renderItems(items))))));\n    setEnd();\n    return element;\n  }, {\n    className: toolbarClassName,\n    displayName: 'Toolbar',\n    slots: {\n      customItem: ToolbarCustomItem,\n      divider: ToolbarDivider,\n      item: ToolbarItem,\n      group: ToolbarRadioGroup,\n      toggle: ToolbarItem,\n      overflowItem: ToolbarItem,\n      menu: ToolbarMenu\n    },\n    slotProps: function slotProps() {\n      return {\n        toggle: {\n          accessibility: toggleButtonBehavior\n        },\n        overflowItem: {\n          icon: /*#__PURE__*/React.createElement(MoreIcon, {\n            outline: true\n          })\n        }\n      };\n    },\n    shorthandConfig: {\n      mappedProp: 'content'\n    },\n    handledProps: ['accessibility', 'as', 'children', 'className', 'content', 'design', 'getOverflowItems', 'items', 'onOverflow', 'onOverflowOpenChange', 'overflow', 'overflowItem', 'overflowOpen', 'styles', 'variables']\n  });\n  Toolbar.propTypes = Object.assign({}, commonPropTypes.createCommon(), {\n    items: customPropTypes.collectionShorthandWithKindProp(['divider', 'item', 'group', 'toggle', 'custom']),\n    overflow: PropTypes.bool,\n    overflowOpen: PropTypes.bool,\n    overflowItem: customPropTypes.shorthandAllowingChildren,\n    onOverflow: PropTypes.func,\n    onOverflowOpenChange: PropTypes.func,\n    getOverflowItems: PropTypes.func\n  });\n  Toolbar.defaultProps = {\n    accessibility: toolbarBehavior,\n    items: [],\n    overflowItem: {}\n  };\n  Toolbar.CustomItem = ToolbarCustomItem;\n  Toolbar.Divider = ToolbarDivider;\n  Toolbar.Item = ToolbarItem;\n  Toolbar.ItemWrapper = ToolbarItemWrapper;\n  Toolbar.ItemIcon = ToolbarItemIcon;\n  Toolbar.Menu = ToolbarMenu;\n  Toolbar.MenuDivider = ToolbarMenuDivider;\n  Toolbar.MenuItem = ToolbarMenuItem;\n  Toolbar.MenuItemIcon = ToolbarMenuItemIcon;\n  Toolbar.MenuItemSubmenuIndicator = ToolbarMenuItemSubmenuIndicator;\n  Toolbar.MenuItemActiveIndicator = ToolbarMenuItemActiveIndicator;\n  Toolbar.MenuRadioGroup = ToolbarMenuRadioGroup;\n  Toolbar.MenuRadioGroupWrapper = ToolbarMenuRadioGroupWrapper;\n  Toolbar.RadioGroup = ToolbarRadioGroup;\n  return Toolbar;\n}();","map":{"version":3,"sources":["components/Toolbar/Toolbar.tsx"],"names":["WAS_FOCUSABLE_ATTRIBUTE","toolbarClassName","Toolbar","compose","context","useFluentContext","setStart","setEnd","useTelemetry","composeOptions","accessibility","className","children","design","getOverflowItems","items","overflow","overflowItem","overflowOpen","styles","variables","props","overflowContainerRef","React","overflowItemWrapperRef","offsetMeasureRef","containerRef","lastVisibleItemIndex","animationFrameId","getA11Props","useAccessibility","debugName","rtl","classes","useStyles","mapPropsToInlineStyles","unstable_props","ElementType","getElementType","slotProps","unhandledProps","useUnhandledProps","hide","el","firstFocusableItem","getFirstFocusable","wasFocusable","show","isItemOverflowing","itemBoundingRect","containerBoundingRect","wouldItemCollide","actualWindow","itemLeftMargin","parseFloat","wouldCollide","overflowItemBoundingRect","itemRightMargin","setOverflowPosition","lastVisibleItemMarginLeft","$overflowItem","lastVisibleItemRect","absolutePositioningOffset","lastVisibleItemRightMargin","hideOverflowItems","$overflowContainer","$offsetMeasure","Number","$items","overflowContainerBoundingRect","offsetMeasureBoundingRect","horizontal","vertical","top","isOverflowing","$item","$lastVisibleItem","collectOverflowItems","getVisibleItems","end","handleWindowResize","renderItems","kind","createShorthand","defaultProps","renderOverflowItem","overrideProps","menu","popper","positionFixed","menuOpen","onMenuOpenChange","wrapper","ref","element","handleRef","root","slots","childrenExist","displayName","customItem","divider","item","group","toggle","ToolbarMenu","toggleButtonBehavior","icon","shorthandConfig","mappedProp","handledProps","commonPropTypes","customPropTypes","PropTypes","onOverflow","onOverflowOpenChange","func"],"mappings":"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","sourcesContent":["import {\n  Accessibility,\n  toolbarBehavior,\n  ToolbarBehaviorProps,\n  toggleButtonBehavior,\n  IS_FOCUSABLE_ATTRIBUTE,\n} from '@fluentui/accessibility';\nimport {\n  ComponentWithAs,\n  compose,\n  getElementType,\n  getFirstFocusable,\n  useFluentContext,\n  useAccessibility,\n  useStyles,\n  useTelemetry,\n  useUnhandledProps,\n} from '@fluentui/react-bindings';\nimport { EventListener } from '@fluentui/react-component-event-listener';\nimport { handleRef, Ref } from '@fluentui/react-component-ref';\nimport { MoreIcon } from '@fluentui/react-icons-northstar';\nimport * as customPropTypes from '@fluentui/react-proptypes';\nimport * as _ from 'lodash';\nimport * as PropTypes from 'prop-types';\nimport * as React from 'react';\n\nimport { ComponentEventHandler, ShorthandCollection, ShorthandValue } from '../../types';\nimport {\n  childrenExist,\n  createShorthand,\n  UIComponentProps,\n  ContentComponentProps,\n  ChildrenComponentProps,\n  commonPropTypes,\n  ColorComponentProps,\n} from '../../utils';\nimport { ToolbarCustomItem, ToolbarCustomItemProps } from './ToolbarCustomItem';\nimport { ToolbarDivider, ToolbarDividerProps } from './ToolbarDivider';\nimport { ToolbarItem, ToolbarItemProps } from './ToolbarItem';\nimport { ToolbarItemWrapper } from './ToolbarItemWrapper';\nimport { ToolbarItemIcon } from './ToolbarItemIcon';\nimport { ToolbarMenu, ToolbarMenuProps } from './ToolbarMenu';\nimport { ToolbarMenuDivider } from './ToolbarMenuDivider';\nimport { ToolbarMenuItem } from './ToolbarMenuItem';\nimport { ToolbarMenuRadioGroup, ToolbarMenuRadioGroupProps } from './ToolbarMenuRadioGroup';\nimport { ToolbarMenuRadioGroupWrapper } from './ToolbarMenuRadioGroupWrapper';\nimport { ToolbarRadioGroup } from './ToolbarRadioGroup';\nimport { ToolbarVariablesProvider } from './toolbarVariablesContext';\nimport { ToolbarMenuItemSubmenuIndicator } from './ToolbarMenuItemSubmenuIndicator';\nimport { ToolbarMenuItemIcon } from './ToolbarMenuItemIcon';\nimport { ToolbarMenuItemActiveIndicator } from './ToolbarMenuItemActiveIndicator';\nimport { ToolbarMenuContextProvider } from './toolbarMenuContext';\n\nexport type ToolbarItemShorthandKinds = {\n  item: ToolbarItemProps;\n  divider: ToolbarDividerProps;\n  group: ToolbarMenuRadioGroupProps;\n  toggle: ToolbarItemProps;\n  custom: ToolbarCustomItemProps;\n};\n\ntype PositionOffset = {\n  vertical: number;\n  horizontal: number;\n};\n\nconst WAS_FOCUSABLE_ATTRIBUTE = 'data-was-focusable';\n\nexport interface ToolbarProps\n  extends UIComponentProps,\n    ContentComponentProps,\n    ChildrenComponentProps,\n    ColorComponentProps {\n  /** Accessibility behavior if overridden by the user. */\n  accessibility?: Accessibility<ToolbarBehaviorProps>;\n\n  /** Shorthand array of props for Toolbar. */\n  items?: ShorthandCollection<ToolbarItemProps, ToolbarItemShorthandKinds>;\n\n  /**\n   *  Automatically move overflow items to overflow menu.\n   *  For automatic overflow to work correctly, toolbar items including overflowMenuItem\n   *  must NOT change their size! If you need to change item's size, rerender the Toolbar.\n   */\n  overflow?: boolean;\n\n  /** Indicates if the overflow menu is open. Only valid if `overflow` is enabled and regular items do not fit. */\n  overflowOpen?: boolean;\n\n  /**\n   * Shorthand for the overflow item which is displayed when `overflow` is enabled and regular toolbar items do not fit.\n   * Do not set any menu on this item, Toolbar overrides it.\n   */\n  overflowItem?: ShorthandValue<ToolbarItemProps>;\n\n  /**\n   * Called when overflow is recomputed (after render, update or window resize). Even if all items fit.\n   * @param itemsVisible - number of items visible\n   */\n  onOverflow?: (itemsVisible: number) => void;\n\n  /**\n   * Event for request to change 'overflowOpen' value.\n   * @param event - React's original SyntheticEvent.\n   * @param data - All props and proposed value.\n   */\n  onOverflowOpenChange?: ComponentEventHandler<ToolbarProps>;\n\n  /**\n   * Callback to get items to be rendered in overflow menu.\n   * Called when overflow menu is rendered opened.\n   * @param startIndex - Index of the first item to be displayed in the overflow menu (the first item which does not fit the toolbar).\n   */\n  getOverflowItems?: (startIndex: number) => ToolbarItemProps['menu'];\n}\n\nexport type ToolbarStylesProps = never;\n\nexport const toolbarClassName = 'ui-toolbar';\n\n/**\n * A Toolbar is a container for grouping a set of controls, often action controls (e.g. buttons) or input controls (e.g. checkboxes).\n *\n * @accessibility\n *  * Implements [ARIA Toolbar](https://www.w3.org/TR/wai-aria-practices-1.1/#toolbar) design pattern.\n * @accessibilityIssues\n * [Issue 988424: VoiceOver narrates selected for button in toolbar](https://bugs.chromium.org/p/chromium/issues/detail?id=988424)\n */\nexport const Toolbar = compose<'div', ToolbarProps, ToolbarStylesProps, {}, {}>(\n  (props, ref, composeOptions) => {\n    const context = useFluentContext();\n    const { setStart, setEnd } = useTelemetry(composeOptions.displayName, context.telemetry);\n    setStart();\n\n    const {\n      accessibility,\n      className,\n      children,\n      design,\n      getOverflowItems,\n      items,\n      overflow,\n      overflowItem,\n      overflowOpen,\n      styles,\n      variables,\n    } = props;\n\n    const overflowContainerRef = React.useRef<HTMLDivElement>();\n    const overflowItemWrapperRef = React.useRef<HTMLElement>();\n    const offsetMeasureRef = React.useRef<HTMLDivElement>();\n    const containerRef = React.useRef<HTMLElement>();\n\n    // index of the last visible item in Toolbar, the rest goes to overflow menu\n    const lastVisibleItemIndex = React.useRef<number>();\n    const animationFrameId = React.useRef<number>();\n\n    const getA11Props = useAccessibility(accessibility, {\n      debugName: composeOptions.displayName,\n      rtl: context.rtl,\n    });\n    const { classes } = useStyles<ToolbarStylesProps>(composeOptions.displayName, {\n      className: toolbarClassName,\n      composeOptions,\n      mapPropsToInlineStyles: () => ({\n        className,\n        design,\n        styles,\n        variables,\n      }),\n      rtl: context.rtl,\n      unstable_props: props,\n    });\n\n    const ElementType = getElementType(props);\n    const slotProps = composeOptions.resolveSlotProps<ToolbarProps>(props);\n    const unhandledProps = useUnhandledProps(composeOptions.handledProps, props);\n\n    const hide = (el: HTMLElement) => {\n      if (el.style.visibility === 'hidden') {\n        return;\n      }\n\n      if (context.target.activeElement === el || el.contains(context.target.activeElement)) {\n        if (containerRef.current) {\n          const firstFocusableItem = getFirstFocusable(\n            containerRef.current,\n            containerRef.current.firstElementChild as HTMLElement,\n          );\n\n          if (firstFocusableItem) {\n            firstFocusableItem.focus();\n          }\n        }\n      }\n\n      el.style.visibility = 'hidden';\n      const wasFocusable = el.getAttribute(IS_FOCUSABLE_ATTRIBUTE);\n      if (wasFocusable) {\n        el.setAttribute(WAS_FOCUSABLE_ATTRIBUTE, wasFocusable);\n      }\n      el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, 'false');\n    };\n\n    const show = (el: HTMLElement) => {\n      if (el.style.visibility !== 'hidden') {\n        return false;\n      }\n\n      el.style.visibility = '';\n      const wasFocusable = el.getAttribute(WAS_FOCUSABLE_ATTRIBUTE);\n      if (wasFocusable) {\n        el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, wasFocusable);\n        el.removeAttribute(WAS_FOCUSABLE_ATTRIBUTE);\n      } else {\n        el.removeAttribute(IS_FOCUSABLE_ATTRIBUTE);\n      }\n\n      return true;\n    };\n\n    /**\n     * Checks if `item` overflows a `container`.\n     * TODO: check and fix all margin combination\n     */\n    const isItemOverflowing = (itemBoundingRect: ClientRect, containerBoundingRect: ClientRect) => {\n      return itemBoundingRect.right > containerBoundingRect.right || itemBoundingRect.left < containerBoundingRect.left;\n    };\n\n    /**\n     * Checks if `item` would collide with eventual position of `overflowItem`.\n     */\n    const wouldItemCollide = (\n      $item: Element,\n      itemBoundingRect: ClientRect,\n      overflowItemBoundingRect: ClientRect,\n      containerBoundingRect: ClientRect,\n    ) => {\n      const actualWindow: Window = context.target.defaultView;\n      let wouldCollide;\n\n      if (context.rtl) {\n        const itemLeftMargin = parseFloat(actualWindow.getComputedStyle($item).marginLeft) || 0;\n        wouldCollide =\n          itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin < containerBoundingRect.left;\n\n        // console.log('Collision [RTL]', {\n        //   wouldCollide,\n        //   'itemBoundingRect.left': itemBoundingRect.left,\n        //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,\n        //   itemRightMargin: itemLeftMargin,\n        //   sum: itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin,\n        //   'overflowContainerBoundingRect.left': containerBoundingRect.left,\n        // })\n      } else {\n        const itemRightMargin = parseFloat(actualWindow.getComputedStyle($item).marginRight) || 0;\n        wouldCollide =\n          itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin > containerBoundingRect.right;\n\n        // console.log('Collision', {\n        //   wouldCollide,\n        //   'itemBoundingRect.right': itemBoundingRect.right,\n        //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,\n        //   itemRightMargin,\n        //   sum: itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin,\n        //   'overflowContainerBoundingRect.right': containerBoundingRect.right,\n        // })\n      }\n\n      return wouldCollide;\n    };\n\n    /**\n     * Positions overflowItem next to lastVisible item\n     * TODO: consider overflowItem margin\n     */\n    const setOverflowPosition = (\n      $overflowItem: HTMLElement,\n      $lastVisibleItem: HTMLElement | undefined,\n      lastVisibleItemRect: ClientRect | undefined,\n      containerBoundingRect: ClientRect,\n      absolutePositioningOffset: PositionOffset,\n    ) => {\n      const actualWindow: Window = context.target.defaultView;\n\n      if ($lastVisibleItem) {\n        if (context.rtl) {\n          const lastVisibleItemMarginLeft = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginLeft) || 0;\n\n          $overflowItem.style.right = `${containerBoundingRect.right -\n            lastVisibleItemRect.left +\n            lastVisibleItemMarginLeft +\n            absolutePositioningOffset.horizontal}px`;\n        } else {\n          const lastVisibleItemRightMargin =\n            parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginRight) || 0;\n\n          $overflowItem.style.left = `${lastVisibleItemRect.right -\n            containerBoundingRect.left +\n            lastVisibleItemRightMargin +\n            absolutePositioningOffset.horizontal}px`;\n        }\n      } else {\n        // there is no last visible item -> position the overflow as the first item\n        lastVisibleItemIndex.current = -1;\n        if (context.rtl) {\n          $overflowItem.style.right = `${absolutePositioningOffset.horizontal}px`;\n        } else {\n          $overflowItem.style.left = `${absolutePositioningOffset.horizontal}px`;\n        }\n      }\n    };\n\n    const hideOverflowItems = () => {\n      const $overflowContainer = overflowContainerRef.current;\n      const $overflowItem = overflowItemWrapperRef.current;\n      const $offsetMeasure = offsetMeasureRef.current;\n      if (!$overflowContainer || !$overflowItem || !$offsetMeasure) {\n        return;\n      }\n\n      // workaround: when resizing window with popup opened the container contents scroll for some reason\n      if (context.rtl) {\n        $overflowContainer.scrollTo(Number.MAX_SAFE_INTEGER, 0);\n      } else {\n        $overflowContainer.scrollTop = 0;\n        $overflowContainer.scrollLeft = 0;\n      }\n\n      const $items = $overflowContainer.children;\n\n      const overflowContainerBoundingRect = $overflowContainer.getBoundingClientRect();\n      const overflowItemBoundingRect = $overflowItem.getBoundingClientRect();\n      const offsetMeasureBoundingRect = $offsetMeasure.getBoundingClientRect();\n\n      // Absolute positioning offset\n      // Overflow menu is absolutely positioned relative to root slot\n      // If there is padding set on the root slot boundingClientRect computations use inner content box,\n      // but absolute position is relative to root slot's PADDING box.\n      // We compute absolute positioning offset\n      // By measuring position of an offsetMeasure element absolutely positioned to 0,0.\n      // TODO: replace by getComputedStyle('padding')\n      const absolutePositioningOffset: PositionOffset = {\n        horizontal: context.rtl\n          ? offsetMeasureBoundingRect.right - overflowContainerBoundingRect.right\n          : overflowContainerBoundingRect.left - offsetMeasureBoundingRect.left,\n        vertical: overflowContainerBoundingRect.top - offsetMeasureBoundingRect.top,\n      };\n\n      let isOverflowing = false;\n      let $lastVisibleItem;\n      let lastVisibleItemRect;\n\n      // check all items from the last one back\n      _.forEachRight($items, ($item: HTMLElement, i: number) => {\n        if ($item === $overflowItem) {\n          return true;\n        }\n\n        const itemBoundingRect = $item.getBoundingClientRect();\n\n        // if the item is out of the crop rectangle, hide it\n        if (isItemOverflowing(itemBoundingRect, overflowContainerBoundingRect)) {\n          isOverflowing = true;\n          // console.log('Overflow', i, {\n          //   item: [itemBoundingRect.left, itemBoundingRect.right],\n          //   crop: [\n          //     overflowContainerBoundingRect.left,\n          //     overflowContainerBoundingRect.right,\n          //     overflowContainerBoundingRect.width,\n          //   ],\n          //   container: $overflowContainer,\n          // })\n          hide($item);\n          return true;\n        }\n\n        // if there is an overflow, check collision of remaining items with eventual overflow position\n        if (\n          isOverflowing &&\n          !$lastVisibleItem &&\n          wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, overflowContainerBoundingRect)\n        ) {\n          hide($item);\n          return true;\n        }\n\n        // Remember the last visible item\n        if (!$lastVisibleItem) {\n          $lastVisibleItem = $item;\n          lastVisibleItemRect = itemBoundingRect;\n          lastVisibleItemIndex.current = i;\n        }\n\n        return show($item); // exit the loop when first visible item is found\n      });\n\n      // if there is an overflow,  position and show overflow item, otherwise hide it\n      if (isOverflowing || overflowOpen) {\n        $overflowItem.style.position = 'absolute';\n        setOverflowPosition(\n          $overflowItem,\n          $lastVisibleItem,\n          lastVisibleItemRect,\n          overflowContainerBoundingRect,\n          absolutePositioningOffset,\n        );\n        show($overflowItem);\n      } else {\n        lastVisibleItemIndex.current = items.length - 1;\n        hide($overflowItem);\n      }\n\n      _.invoke(props, 'onOverflow', lastVisibleItemIndex.current + 1);\n    };\n\n    const collectOverflowItems = (): ToolbarItemProps['menu'] => {\n      // console.log('getOverflowItems()', items.slice(lastVisibleItemIndex.current + 1))\n      return getOverflowItems\n        ? getOverflowItems(lastVisibleItemIndex.current + 1)\n        : items.slice(lastVisibleItemIndex.current + 1);\n    };\n\n    const getVisibleItems = () => {\n      // console.log('allItems()', items)\n      const end = overflowOpen ? lastVisibleItemIndex.current + 1 : items.length;\n      // console.log('getVisibleItems()', items.slice(0, end))\n      return items.slice(0, end);\n    };\n\n    const handleWindowResize = _.debounce((e: UIEvent) => {\n      hideOverflowItems();\n\n      if (overflowOpen) {\n        _.invoke(props, 'onOverflowOpenChange', e, { ...props, overflowOpen: false });\n      }\n    }, 16);\n\n    const renderItems = (items: ToolbarProps['items']) =>\n      _.map(items, item => {\n        const kind = _.get(item, 'kind', 'item');\n\n        switch (kind) {\n          case 'divider':\n            return createShorthand(composeOptions.slots.divider, item, {\n              defaultProps: () => slotProps.divider,\n            });\n          case 'group':\n            return createShorthand(composeOptions.slots.group, item, {\n              defaultProps: () => slotProps.group,\n            });\n          case 'toggle':\n            return createShorthand(composeOptions.slots.toggle, item, {\n              defaultProps: () => slotProps.toggle,\n            });\n          case 'custom':\n            return createShorthand(composeOptions.slots.customItem, item, {\n              defaultProps: () => slotProps.customItem,\n            });\n          default:\n            return createShorthand(composeOptions.slots.item, item, {\n              defaultProps: () => slotProps.item,\n            });\n        }\n      });\n\n    const renderOverflowItem = overflowItem =>\n      createShorthand(composeOptions.slots.overflowItem, overflowItem, {\n        defaultProps: () => slotProps.overflowItem,\n        overrideProps: {\n          menu: {\n            items: overflowOpen ? (collectOverflowItems() as ToolbarMenuProps['items']) : [],\n            popper: { positionFixed: true },\n          },\n          menuOpen: overflowOpen,\n          onMenuOpenChange: (e, { menuOpen }) => {\n            _.invoke(props, 'onOverflowOpenChange', e, { ...props, overflowOpen: menuOpen });\n          },\n          wrapper: {\n            ref: overflowItemWrapperRef,\n          },\n        },\n      });\n\n    React.useEffect(() => {\n      const actualWindow: Window = context.target.defaultView;\n\n      actualWindow.cancelAnimationFrame(animationFrameId.current);\n      // Heads up! There are cases (like opening a portal and rendering the Toolbar there immediately) when rAF is necessary\n      animationFrameId.current = actualWindow.requestAnimationFrame(() => {\n        hideOverflowItems();\n      });\n\n      return () => {\n        if (animationFrameId.current !== undefined) {\n          context.target.defaultView.cancelAnimationFrame(animationFrameId.current);\n          animationFrameId.current = undefined;\n        }\n      };\n    });\n\n    const element = overflow ? (\n      <>\n        <Ref\n          innerRef={(node: HTMLDivElement) => {\n            containerRef.current = node;\n            handleRef(ref, node);\n          }}\n        >\n          {getA11Props.unstable_wrapWithFocusZone(\n            <ElementType {...getA11Props('root', { className: classes.root, ...unhandledProps })}>\n              <div className={classes.overflowContainer} ref={overflowContainerRef}>\n                <ToolbarMenuContextProvider value={{ slots: { menu: composeOptions.slots.menu } }}>\n                  <ToolbarVariablesProvider value={variables}>\n                    {childrenExist(children) ? children : renderItems(getVisibleItems())}\n                    {renderOverflowItem(overflowItem)}\n                  </ToolbarVariablesProvider>\n                </ToolbarMenuContextProvider>\n              </div>\n              <div className={classes.offsetMeasure} ref={offsetMeasureRef} />\n            </ElementType>,\n          )}\n        </Ref>\n        <EventListener listener={handleWindowResize} target={context.target.defaultView} type=\"resize\" />\n      </>\n    ) : (\n      <Ref\n        innerRef={(node: HTMLDivElement) => {\n          containerRef.current = node;\n          handleRef(ref, node);\n        }}\n      >\n        {getA11Props.unstable_wrapWithFocusZone(\n          <ElementType {...getA11Props('root', { className: classes.root, ...unhandledProps })}>\n            <ToolbarMenuContextProvider value={{ slots: { menu: composeOptions.slots.menu } }}>\n              <ToolbarVariablesProvider value={variables}>\n                {childrenExist(children) ? children : renderItems(items)}\n              </ToolbarVariablesProvider>\n            </ToolbarMenuContextProvider>\n          </ElementType>,\n        )}\n      </Ref>\n    );\n    setEnd();\n\n    return element;\n  },\n  {\n    className: toolbarClassName,\n    displayName: 'Toolbar',\n\n    slots: {\n      customItem: ToolbarCustomItem,\n      divider: ToolbarDivider,\n      item: ToolbarItem,\n      group: ToolbarRadioGroup,\n      toggle: ToolbarItem,\n      overflowItem: ToolbarItem,\n      menu: ToolbarMenu,\n    },\n    slotProps: () => ({\n      toggle: {\n        accessibility: toggleButtonBehavior,\n      },\n      overflowItem: {\n        icon: <MoreIcon outline />,\n      },\n    }),\n\n    shorthandConfig: { mappedProp: 'content' },\n    handledProps: [\n      'accessibility',\n      'as',\n      'children',\n      'className',\n      'content',\n      'design',\n      'getOverflowItems',\n      'items',\n      'onOverflow',\n      'onOverflowOpenChange',\n      'overflow',\n      'overflowItem',\n      'overflowOpen',\n      'styles',\n      'variables',\n    ],\n  },\n) as ComponentWithAs<'div', ToolbarProps> & {\n  CustomItem: typeof ToolbarCustomItem;\n  Divider: typeof ToolbarDivider;\n  Item: typeof ToolbarItem;\n  ItemWrapper: typeof ToolbarItemWrapper;\n  ItemIcon: typeof ToolbarItemIcon;\n  Menu: typeof ToolbarMenu;\n  MenuDivider: typeof ToolbarMenuDivider;\n  MenuItem: typeof ToolbarMenuItem;\n  MenuItemIcon: typeof ToolbarMenuItemIcon;\n  MenuItemSubmenuIndicator: typeof ToolbarMenuItemSubmenuIndicator;\n  MenuItemActiveIndicator: typeof ToolbarMenuItemActiveIndicator;\n  MenuRadioGroup: typeof ToolbarMenuRadioGroup;\n  MenuRadioGroupWrapper: typeof ToolbarMenuRadioGroupWrapper;\n  RadioGroup: typeof ToolbarRadioGroup;\n};\n\nToolbar.propTypes = {\n  ...commonPropTypes.createCommon(),\n  items: customPropTypes.collectionShorthandWithKindProp(['divider', 'item', 'group', 'toggle', 'custom']),\n  overflow: PropTypes.bool,\n  overflowOpen: PropTypes.bool,\n  overflowItem: customPropTypes.shorthandAllowingChildren,\n  onOverflow: PropTypes.func,\n  onOverflowOpenChange: PropTypes.func,\n  getOverflowItems: PropTypes.func,\n};\nToolbar.defaultProps = {\n  accessibility: toolbarBehavior,\n  items: [],\n  overflowItem: {},\n};\n\nToolbar.CustomItem = ToolbarCustomItem;\nToolbar.Divider = ToolbarDivider;\nToolbar.Item = ToolbarItem;\nToolbar.ItemWrapper = ToolbarItemWrapper;\nToolbar.ItemIcon = ToolbarItemIcon;\nToolbar.Menu = ToolbarMenu;\nToolbar.MenuDivider = ToolbarMenuDivider;\nToolbar.MenuItem = ToolbarMenuItem;\nToolbar.MenuItemIcon = ToolbarMenuItemIcon;\nToolbar.MenuItemSubmenuIndicator = ToolbarMenuItemSubmenuIndicator;\nToolbar.MenuItemActiveIndicator = ToolbarMenuItemActiveIndicator;\nToolbar.MenuRadioGroup = ToolbarMenuRadioGroup;\nToolbar.MenuRadioGroupWrapper = ToolbarMenuRadioGroupWrapper;\nToolbar.RadioGroup = ToolbarRadioGroup;\n"]},"metadata":{},"sourceType":"module"}