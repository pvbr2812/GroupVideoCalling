{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __awaiter, __extends, __generator } from \"tslib\";\nimport { BaseRequestPolicy } from \"../policies/requestPolicy\";\nimport { Constants } from \"../util/constants\";\nimport { HttpHeaders } from \"../httpHeaders\";\nimport { ExpiringAccessTokenCache } from \"../credentials/accessTokenCache\";\nimport { AccessTokenRefresher } from \"../credentials/accessTokenRefresher\";\n/**\n * The automated token refresh will only start to happen at the\n * expiration date minus the value of timeBetweenRefreshAttemptsInMs,\n * which is by default 30 seconds.\n */\n\nvar timeBetweenRefreshAttemptsInMs = 30000;\n/**\n * Creates a new BearerTokenAuthenticationPolicy factory.\n *\n * @param credential - The TokenCredential implementation that can supply the bearer token.\n * @param scopes - The scopes for which the bearer token applies.\n */\n\nexport function bearerTokenAuthenticationPolicy(credential, scopes) {\n  var tokenCache = new ExpiringAccessTokenCache();\n  var tokenRefresher = new AccessTokenRefresher(credential, scopes, timeBetweenRefreshAttemptsInMs);\n  return {\n    create: function (nextPolicy, options) {\n      return new BearerTokenAuthenticationPolicy(nextPolicy, options, tokenCache, tokenRefresher);\n    }\n  };\n}\n/**\n *\n * Provides a RequestPolicy that can request a token from a TokenCredential\n * implementation and then apply it to the Authorization header of a request\n * as a Bearer token.\n *\n */\n\nvar BearerTokenAuthenticationPolicy =\n/** @class */\nfunction (_super) {\n  __extends(BearerTokenAuthenticationPolicy, _super);\n  /**\n   * Creates a new BearerTokenAuthenticationPolicy object.\n   *\n   * @param nextPolicy - The next RequestPolicy in the request pipeline.\n   * @param options - Options for this RequestPolicy.\n   * @param credential - The TokenCredential implementation that can supply the bearer token.\n   * @param scopes - The scopes for which the bearer token applies.\n   * @param tokenCache - The cache for the most recent AccessToken returned from the TokenCredential.\n   */\n\n\n  function BearerTokenAuthenticationPolicy(nextPolicy, options, tokenCache, tokenRefresher) {\n    var _this = _super.call(this, nextPolicy, options) || this;\n\n    _this.tokenCache = tokenCache;\n    _this.tokenRefresher = tokenRefresher;\n    return _this;\n  }\n  /**\n   * Applies the Bearer token to the request through the Authorization header.\n   */\n\n\n  BearerTokenAuthenticationPolicy.prototype.sendRequest = function (webResource) {\n    return __awaiter(this, void 0, void 0, function () {\n      var token;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!webResource.headers) webResource.headers = new HttpHeaders();\n            return [4\n            /*yield*/\n            , this.getToken({\n              abortSignal: webResource.abortSignal,\n              tracingOptions: {\n                spanOptions: webResource.spanOptions\n              }\n            })];\n\n          case 1:\n            token = _a.sent();\n            webResource.headers.set(Constants.HeaderConstants.AUTHORIZATION, \"Bearer \" + token);\n            return [2\n            /*return*/\n            , this._nextPolicy.sendRequest(webResource)];\n        }\n      });\n    });\n  };\n  /**\n   * Attempts a token update if any other time related conditionals have been reached based on the tokenRefresher class.\n   */\n\n\n  BearerTokenAuthenticationPolicy.prototype.updateTokenIfNeeded = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var accessToken;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.tokenRefresher.isReady()) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.tokenRefresher.refresh(options)];\n\n          case 1:\n            accessToken = _a.sent();\n            this.tokenCache.setCachedToken(accessToken);\n            _a.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  BearerTokenAuthenticationPolicy.prototype.getToken = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var accessToken;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            accessToken = this.tokenCache.getCachedToken();\n            if (!(accessToken === undefined)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.tokenRefresher.refresh(options)];\n\n          case 1:\n            // Waiting for the next refresh only if the cache is unable to retrieve the access token,\n            // which means that it has expired, or it has never been set.\n            accessToken = _a.sent();\n            this.tokenCache.setCachedToken(accessToken);\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            // If we still have a cached access token,\n            // And any other time related conditionals have been reached based on the tokenRefresher class,\n            // then attempt to refresh without waiting.\n            this.updateTokenIfNeeded(options);\n            _a.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            , accessToken ? accessToken.token : undefined];\n        }\n      });\n    });\n  };\n\n  return BearerTokenAuthenticationPolicy;\n}(BaseRequestPolicy);\n\nexport { BearerTokenAuthenticationPolicy };","map":{"version":3,"sources":["../../../src/policies/bearerTokenAuthenticationPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TokenCredential, GetTokenOptions } from \"@azure/core-auth\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyOptions,\n  RequestPolicyFactory\n} from \"../policies/requestPolicy\";\nimport { Constants } from \"../util/constants\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { HttpHeaders } from \"../httpHeaders\";\nimport { WebResourceLike } from \"../webResource\";\nimport { AccessTokenCache, ExpiringAccessTokenCache } from \"../credentials/accessTokenCache\";\nimport { AccessTokenRefresher } from \"../credentials/accessTokenRefresher\";\n\n/**\n * The automated token refresh will only start to happen at the\n * expiration date minus the value of timeBetweenRefreshAttemptsInMs,\n * which is by default 30 seconds.\n */\nconst timeBetweenRefreshAttemptsInMs = 30000;\n\n/**\n * Creates a new BearerTokenAuthenticationPolicy factory.\n *\n * @param credential - The TokenCredential implementation that can supply the bearer token.\n * @param scopes - The scopes for which the bearer token applies.\n */\nexport function bearerTokenAuthenticationPolicy(\n  credential: TokenCredential,\n  scopes: string | string[]\n): RequestPolicyFactory {\n  const tokenCache: AccessTokenCache = new ExpiringAccessTokenCache();\n  const tokenRefresher = new AccessTokenRefresher(\n    credential,\n    scopes,\n    timeBetweenRefreshAttemptsInMs\n  );\n\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new BearerTokenAuthenticationPolicy(nextPolicy, options, tokenCache, tokenRefresher);\n    }\n  };\n}\n\n/**\n *\n * Provides a RequestPolicy that can request a token from a TokenCredential\n * implementation and then apply it to the Authorization header of a request\n * as a Bearer token.\n *\n */\nexport class BearerTokenAuthenticationPolicy extends BaseRequestPolicy {\n  /**\n   * Creates a new BearerTokenAuthenticationPolicy object.\n   *\n   * @param nextPolicy - The next RequestPolicy in the request pipeline.\n   * @param options - Options for this RequestPolicy.\n   * @param credential - The TokenCredential implementation that can supply the bearer token.\n   * @param scopes - The scopes for which the bearer token applies.\n   * @param tokenCache - The cache for the most recent AccessToken returned from the TokenCredential.\n   */\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    private tokenCache: AccessTokenCache,\n    private tokenRefresher: AccessTokenRefresher\n  ) {\n    super(nextPolicy, options);\n  }\n\n  /**\n   * Applies the Bearer token to the request through the Authorization header.\n   */\n  public async sendRequest(webResource: WebResourceLike): Promise<HttpOperationResponse> {\n    if (!webResource.headers) webResource.headers = new HttpHeaders();\n    const token = await this.getToken({\n      abortSignal: webResource.abortSignal,\n      tracingOptions: {\n        spanOptions: webResource.spanOptions\n      }\n    });\n    webResource.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${token}`);\n    return this._nextPolicy.sendRequest(webResource);\n  }\n\n  /**\n   * Attempts a token update if any other time related conditionals have been reached based on the tokenRefresher class.\n   */\n  private async updateTokenIfNeeded(options: GetTokenOptions): Promise<void> {\n    if (this.tokenRefresher.isReady()) {\n      const accessToken = await this.tokenRefresher.refresh(options);\n      this.tokenCache.setCachedToken(accessToken);\n    }\n  }\n\n  private async getToken(options: GetTokenOptions): Promise<string | undefined> {\n    let accessToken = this.tokenCache.getCachedToken();\n    if (accessToken === undefined) {\n      // Waiting for the next refresh only if the cache is unable to retrieve the access token,\n      // which means that it has expired, or it has never been set.\n      accessToken = await this.tokenRefresher.refresh(options);\n      this.tokenCache.setCachedToken(accessToken);\n    } else {\n      // If we still have a cached access token,\n      // And any other time related conditionals have been reached based on the tokenRefresher class,\n      // then attempt to refresh without waiting.\n      this.updateTokenIfNeeded(options);\n    }\n\n    return accessToken ? accessToken.token : undefined;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}