{"ast":null,"code":"\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NOOP_BATCH_OBSERVER_METRIC = exports.NOOP_SUM_OBSERVER_METRIC = exports.NOOP_UP_DOWN_SUM_OBSERVER_METRIC = exports.NOOP_VALUE_OBSERVER_METRIC = exports.NOOP_BOUND_BASE_OBSERVER = exports.NOOP_VALUE_RECORDER_METRIC = exports.NOOP_BOUND_VALUE_RECORDER = exports.NOOP_COUNTER_METRIC = exports.NOOP_BOUND_COUNTER = exports.NOOP_METER = exports.NoopBoundBaseObserver = exports.NoopBoundValueRecorder = exports.NoopBoundCounter = exports.NoopBatchObserverMetric = exports.NoopBaseObserverMetric = exports.NoopValueRecorderMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = void 0;\n/**\n * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses\n * constant NoopMetrics for all of its methods.\n */\n\nvar NoopMeter =\n/** @class */\nfunction () {\n  function NoopMeter() {}\n  /**\n   * Returns constant noop value recorder.\n   * @param name the name of the metric.\n   * @param [options] the metric options.\n   */\n\n\n  NoopMeter.prototype.createValueRecorder = function (name, options) {\n    return exports.NOOP_VALUE_RECORDER_METRIC;\n  };\n  /**\n   * Returns a constant noop counter.\n   * @param name the name of the metric.\n   * @param [options] the metric options.\n   */\n\n\n  NoopMeter.prototype.createCounter = function (name, options) {\n    return exports.NOOP_COUNTER_METRIC;\n  };\n  /**\n   * Returns a constant noop UpDownCounter.\n   * @param name the name of the metric.\n   * @param [options] the metric options.\n   */\n\n\n  NoopMeter.prototype.createUpDownCounter = function (name, options) {\n    return exports.NOOP_COUNTER_METRIC;\n  };\n  /**\n   * Returns constant noop value observer.\n   * @param name the name of the metric.\n   * @param [options] the metric options.\n   * @param [callback] the value observer callback\n   */\n\n\n  NoopMeter.prototype.createValueObserver = function (name, options, callback) {\n    return exports.NOOP_VALUE_OBSERVER_METRIC;\n  };\n  /**\n   * Returns constant noop batch observer.\n   * @param name the name of the metric.\n   * @param callback the batch observer callback\n   */\n\n\n  NoopMeter.prototype.createBatchObserver = function (name, callback) {\n    return exports.NOOP_BATCH_OBSERVER_METRIC;\n  };\n\n  return NoopMeter;\n}();\n\nexports.NoopMeter = NoopMeter;\n\nvar NoopMetric =\n/** @class */\nfunction () {\n  function NoopMetric(instrument) {\n    this._instrument = instrument;\n  }\n  /**\n   * Returns a Bound Instrument associated with specified Labels.\n   * It is recommended to keep a reference to the Bound Instrument instead of\n   * always calling this method for every operations.\n   * @param labels key-values pairs that are associated with a specific metric\n   *     that you want to record.\n   */\n\n\n  NoopMetric.prototype.bind = function (labels) {\n    return this._instrument;\n  };\n  /**\n   * Removes the Binding from the metric, if it is present.\n   * @param labels key-values pairs that are associated with a specific metric.\n   */\n\n\n  NoopMetric.prototype.unbind = function (labels) {\n    return;\n  };\n  /**\n   * Clears all timeseries from the Metric.\n   */\n\n\n  NoopMetric.prototype.clear = function () {\n    return;\n  };\n\n  return NoopMetric;\n}();\n\nexports.NoopMetric = NoopMetric;\n\nvar NoopCounterMetric =\n/** @class */\nfunction (_super) {\n  __extends(NoopCounterMetric, _super);\n\n  function NoopCounterMetric() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  NoopCounterMetric.prototype.add = function (value, labels) {\n    this.bind(labels).add(value);\n  };\n\n  return NoopCounterMetric;\n}(NoopMetric);\n\nexports.NoopCounterMetric = NoopCounterMetric;\n\nvar NoopValueRecorderMetric =\n/** @class */\nfunction (_super) {\n  __extends(NoopValueRecorderMetric, _super);\n\n  function NoopValueRecorderMetric() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  NoopValueRecorderMetric.prototype.record = function (value, labels, correlationContext, spanContext) {\n    if (typeof correlationContext === 'undefined') {\n      this.bind(labels).record(value);\n    } else if (typeof spanContext === 'undefined') {\n      this.bind(labels).record(value, correlationContext);\n    } else {\n      this.bind(labels).record(value, correlationContext, spanContext);\n    }\n  };\n\n  return NoopValueRecorderMetric;\n}(NoopMetric);\n\nexports.NoopValueRecorderMetric = NoopValueRecorderMetric;\n\nvar NoopBaseObserverMetric =\n/** @class */\nfunction (_super) {\n  __extends(NoopBaseObserverMetric, _super);\n\n  function NoopBaseObserverMetric() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  NoopBaseObserverMetric.prototype.observation = function () {\n    return {\n      observer: this,\n      value: 0\n    };\n  };\n\n  return NoopBaseObserverMetric;\n}(NoopMetric);\n\nexports.NoopBaseObserverMetric = NoopBaseObserverMetric;\n\nvar NoopBatchObserverMetric =\n/** @class */\nfunction (_super) {\n  __extends(NoopBatchObserverMetric, _super);\n\n  function NoopBatchObserverMetric() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return NoopBatchObserverMetric;\n}(NoopMetric);\n\nexports.NoopBatchObserverMetric = NoopBatchObserverMetric;\n\nvar NoopBoundCounter =\n/** @class */\nfunction () {\n  function NoopBoundCounter() {}\n\n  NoopBoundCounter.prototype.add = function (value) {\n    return;\n  };\n\n  return NoopBoundCounter;\n}();\n\nexports.NoopBoundCounter = NoopBoundCounter;\n\nvar NoopBoundValueRecorder =\n/** @class */\nfunction () {\n  function NoopBoundValueRecorder() {}\n\n  NoopBoundValueRecorder.prototype.record = function (value, correlationContext, spanContext) {\n    return;\n  };\n\n  return NoopBoundValueRecorder;\n}();\n\nexports.NoopBoundValueRecorder = NoopBoundValueRecorder;\n\nvar NoopBoundBaseObserver =\n/** @class */\nfunction () {\n  function NoopBoundBaseObserver() {}\n\n  NoopBoundBaseObserver.prototype.update = function (value) {};\n\n  return NoopBoundBaseObserver;\n}();\n\nexports.NoopBoundBaseObserver = NoopBoundBaseObserver;\nexports.NOOP_METER = new NoopMeter();\nexports.NOOP_BOUND_COUNTER = new NoopBoundCounter();\nexports.NOOP_COUNTER_METRIC = new NoopCounterMetric(exports.NOOP_BOUND_COUNTER);\nexports.NOOP_BOUND_VALUE_RECORDER = new NoopBoundValueRecorder();\nexports.NOOP_VALUE_RECORDER_METRIC = new NoopValueRecorderMetric(exports.NOOP_BOUND_VALUE_RECORDER);\nexports.NOOP_BOUND_BASE_OBSERVER = new NoopBoundBaseObserver();\nexports.NOOP_VALUE_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);\nexports.NOOP_UP_DOWN_SUM_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);\nexports.NOOP_SUM_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);\nexports.NOOP_BATCH_OBSERVER_METRIC = new NoopBatchObserverMetric();","map":{"version":3,"sources":["../../../src/metrics/NoopMeter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NOOP_BATCH_OBSERVER_METRIC = exports.NOOP_SUM_OBSERVER_METRIC = exports.NOOP_UP_DOWN_SUM_OBSERVER_METRIC = exports.NOOP_VALUE_OBSERVER_METRIC = exports.NOOP_BOUND_BASE_OBSERVER = exports.NOOP_VALUE_RECORDER_METRIC = exports.NOOP_BOUND_VALUE_RECORDER = exports.NOOP_COUNTER_METRIC = exports.NOOP_BOUND_COUNTER = exports.NOOP_METER = exports.NoopBoundBaseObserver = exports.NoopBoundValueRecorder = exports.NoopBoundCounter = exports.NoopBatchObserverMetric = exports.NoopBaseObserverMetric = exports.NoopValueRecorderMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = void 0;\n/**\n * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses\n * constant NoopMetrics for all of its methods.\n */\nvar NoopMeter = /** @class */ (function () {\n    function NoopMeter() {\n    }\n    /**\n     * Returns constant noop value recorder.\n     * @param name the name of the metric.\n     * @param [options] the metric options.\n     */\n    NoopMeter.prototype.createValueRecorder = function (name, options) {\n        return exports.NOOP_VALUE_RECORDER_METRIC;\n    };\n    /**\n     * Returns a constant noop counter.\n     * @param name the name of the metric.\n     * @param [options] the metric options.\n     */\n    NoopMeter.prototype.createCounter = function (name, options) {\n        return exports.NOOP_COUNTER_METRIC;\n    };\n    /**\n     * Returns a constant noop UpDownCounter.\n     * @param name the name of the metric.\n     * @param [options] the metric options.\n     */\n    NoopMeter.prototype.createUpDownCounter = function (name, options) {\n        return exports.NOOP_COUNTER_METRIC;\n    };\n    /**\n     * Returns constant noop value observer.\n     * @param name the name of the metric.\n     * @param [options] the metric options.\n     * @param [callback] the value observer callback\n     */\n    NoopMeter.prototype.createValueObserver = function (name, options, callback) {\n        return exports.NOOP_VALUE_OBSERVER_METRIC;\n    };\n    /**\n     * Returns constant noop batch observer.\n     * @param name the name of the metric.\n     * @param callback the batch observer callback\n     */\n    NoopMeter.prototype.createBatchObserver = function (name, callback) {\n        return exports.NOOP_BATCH_OBSERVER_METRIC;\n    };\n    return NoopMeter;\n}());\nexports.NoopMeter = NoopMeter;\nvar NoopMetric = /** @class */ (function () {\n    function NoopMetric(instrument) {\n        this._instrument = instrument;\n    }\n    /**\n     * Returns a Bound Instrument associated with specified Labels.\n     * It is recommended to keep a reference to the Bound Instrument instead of\n     * always calling this method for every operations.\n     * @param labels key-values pairs that are associated with a specific metric\n     *     that you want to record.\n     */\n    NoopMetric.prototype.bind = function (labels) {\n        return this._instrument;\n    };\n    /**\n     * Removes the Binding from the metric, if it is present.\n     * @param labels key-values pairs that are associated with a specific metric.\n     */\n    NoopMetric.prototype.unbind = function (labels) {\n        return;\n    };\n    /**\n     * Clears all timeseries from the Metric.\n     */\n    NoopMetric.prototype.clear = function () {\n        return;\n    };\n    return NoopMetric;\n}());\nexports.NoopMetric = NoopMetric;\nvar NoopCounterMetric = /** @class */ (function (_super) {\n    __extends(NoopCounterMetric, _super);\n    function NoopCounterMetric() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoopCounterMetric.prototype.add = function (value, labels) {\n        this.bind(labels).add(value);\n    };\n    return NoopCounterMetric;\n}(NoopMetric));\nexports.NoopCounterMetric = NoopCounterMetric;\nvar NoopValueRecorderMetric = /** @class */ (function (_super) {\n    __extends(NoopValueRecorderMetric, _super);\n    function NoopValueRecorderMetric() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoopValueRecorderMetric.prototype.record = function (value, labels, correlationContext, spanContext) {\n        if (typeof correlationContext === 'undefined') {\n            this.bind(labels).record(value);\n        }\n        else if (typeof spanContext === 'undefined') {\n            this.bind(labels).record(value, correlationContext);\n        }\n        else {\n            this.bind(labels).record(value, correlationContext, spanContext);\n        }\n    };\n    return NoopValueRecorderMetric;\n}(NoopMetric));\nexports.NoopValueRecorderMetric = NoopValueRecorderMetric;\nvar NoopBaseObserverMetric = /** @class */ (function (_super) {\n    __extends(NoopBaseObserverMetric, _super);\n    function NoopBaseObserverMetric() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoopBaseObserverMetric.prototype.observation = function () {\n        return {\n            observer: this,\n            value: 0,\n        };\n    };\n    return NoopBaseObserverMetric;\n}(NoopMetric));\nexports.NoopBaseObserverMetric = NoopBaseObserverMetric;\nvar NoopBatchObserverMetric = /** @class */ (function (_super) {\n    __extends(NoopBatchObserverMetric, _super);\n    function NoopBatchObserverMetric() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return NoopBatchObserverMetric;\n}(NoopMetric));\nexports.NoopBatchObserverMetric = NoopBatchObserverMetric;\nvar NoopBoundCounter = /** @class */ (function () {\n    function NoopBoundCounter() {\n    }\n    NoopBoundCounter.prototype.add = function (value) {\n        return;\n    };\n    return NoopBoundCounter;\n}());\nexports.NoopBoundCounter = NoopBoundCounter;\nvar NoopBoundValueRecorder = /** @class */ (function () {\n    function NoopBoundValueRecorder() {\n    }\n    NoopBoundValueRecorder.prototype.record = function (value, correlationContext, spanContext) {\n        return;\n    };\n    return NoopBoundValueRecorder;\n}());\nexports.NoopBoundValueRecorder = NoopBoundValueRecorder;\nvar NoopBoundBaseObserver = /** @class */ (function () {\n    function NoopBoundBaseObserver() {\n    }\n    NoopBoundBaseObserver.prototype.update = function (value) { };\n    return NoopBoundBaseObserver;\n}());\nexports.NoopBoundBaseObserver = NoopBoundBaseObserver;\nexports.NOOP_METER = new NoopMeter();\nexports.NOOP_BOUND_COUNTER = new NoopBoundCounter();\nexports.NOOP_COUNTER_METRIC = new NoopCounterMetric(exports.NOOP_BOUND_COUNTER);\nexports.NOOP_BOUND_VALUE_RECORDER = new NoopBoundValueRecorder();\nexports.NOOP_VALUE_RECORDER_METRIC = new NoopValueRecorderMetric(exports.NOOP_BOUND_VALUE_RECORDER);\nexports.NOOP_BOUND_BASE_OBSERVER = new NoopBoundBaseObserver();\nexports.NOOP_VALUE_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);\nexports.NOOP_UP_DOWN_SUM_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);\nexports.NOOP_SUM_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);\nexports.NOOP_BATCH_OBSERVER_METRIC = new NoopBatchObserverMetric();\n//# sourceMappingURL=NoopMeter.js.map"]},"metadata":{},"sourceType":"script"}