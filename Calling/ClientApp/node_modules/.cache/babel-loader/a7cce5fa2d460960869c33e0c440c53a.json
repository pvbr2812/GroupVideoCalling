{"ast":null,"code":"import { serializeStyles } from '@emotion/serialize';\nimport cx from 'classnames'; // @ts-ignore\n\nimport _Stylis from 'stylis'; // @ts-ignore No typings :(\n\nimport focusVisiblePlugin from '@quid/stylis-plugin-focus-visible'; // @ts-ignore No typings :(\n\nimport rtlPlugin from 'stylis-plugin-rtl';\nimport { useFluentContext } from '../context'; //\n// Types\n//\n// Inline keyframe definitions are not supported by useCSS() hook\n//\n// Definitions\n//\n// SPECIFICITY_CLASSNAME is used to increase the specificity of produced CSS to win over other defined classes.\n// \"css\" used for production to decrease DOM size.\n\nvar SPECIFICITY_CLASSNAME = process.env.NODE_ENV === 'production' ? 'css' : 'use-css';\nvar CLASSNAME_PREFIX = 'f'; // `stylis@3` is a CJS library, there are known issues with them:\n// https://github.com/rollup/rollup/issues/1267#issuecomment-446681320\n\nvar Stylis = _Stylis.default || _Stylis;\nvar stylisOptions = {\n  cascade: true,\n  compress: false,\n  global: false,\n  keyframe: false,\n  preserve: false,\n  semicolon: false\n}; // Two separate instances are requires as we can't call Stylis plugins conditionally\n\nvar stylis = new Stylis(stylisOptions);\nstylis.use(focusVisiblePlugin);\nvar rtlStylis = new Stylis(stylisOptions);\nrtlStylis.use(focusVisiblePlugin);\nrtlStylis.use(rtlPlugin); // Stores a mapping between hashed string and cssified styles object\n\nvar stylesCache = {}; //\n// Hook\n//\n\nexport function useCSS() {\n  var _useFluentContext = useFluentContext(),\n      theme = _useFluentContext.theme,\n      renderer = _useFluentContext.renderer,\n      rtl = _useFluentContext.rtl;\n\n  for (var _len = arguments.length, styles = new Array(_len), _key = 0; _key < _len; _key++) {\n    styles[_key] = arguments[_key];\n  }\n\n  if (styles.length === 0) {\n    return '';\n  } // This resolution allows to map passed classnames to actual styles that can be used on next styles\n\n\n  var resolvedStyles = styles.reduce(function (acc, style) {\n    if (typeof style === 'string') {\n      style.split(' ').forEach(function (className) {\n        if (stylesCache[className] !== undefined) {\n          acc.push(stylesCache[className]);\n        }\n      });\n    } else {\n      acc.push(style);\n    }\n\n    return acc;\n  }, []); // serializeStyles() will concat all passed styles and will resolve functions\n\n  var serializedStyles = serializeStyles(resolvedStyles, stylesCache, theme); // \".name\" is not a valid CSS classname as it can start from a digit\n  //  \"r\" prefix is used to avoid collision between LTR and RTL styles\n\n  var serializedClassName = \"\" + (rtl ? 'r' : '') + CLASSNAME_PREFIX + serializedStyles.name;\n  stylesCache[serializedClassName] = serializedStyles.styles; // Selector should include specificity className to have higher specificity than other passed classes\n\n  var selector = \".\" + SPECIFICITY_CLASSNAME + \".\" + serializedClassName; // Stylis performs transform of nested selectors and \":focus-visible\"\n\n  var css = rtl ? rtlStylis(selector, serializedStyles.styles) : stylis(selector, serializedStyles.styles);\n  renderer.renderGlobal(css);\n  return cx(SPECIFICITY_CLASSNAME, serializedClassName);\n}","map":{"version":3,"sources":["hooks/useCSS.ts"],"names":["SPECIFICITY_CLASSNAME","process","CLASSNAME_PREFIX","Stylis","_Stylis","stylisOptions","cascade","compress","global","keyframe","preserve","semicolon","stylis","rtlStylis","stylesCache","styles","theme","renderer","rtl","useFluentContext","resolvedStyles","style","acc","serializedStyles","serializeStyles","serializedClassName","selector","css","cx"],"mappings":"AAAA,SAAA,eAAA,QAAA,oBAAA;AAEA,OAAA,EAAA,MAAA,YAAA,C,CACA;;AACA,OAAA,OAAA,MAAA,QAAA,C,CACA;;AACA,OAAA,kBAAA,MAAA,mCAAA,C,CACA;;AACA,OAAA,SAAA,MAAA,mBAAA;AAEA,SAAA,gBAAA,QAAA,YAAA,C,CAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;;AACA,IAAMA,qBAAqB,GAAGC,OAAO,CAAPA,GAAAA,CAAAA,QAAAA,KAAAA,YAAAA,GAAAA,KAAAA,GAA9B,SAAA;AACA,IAAMC,gBAAgB,GAAtB,GAAA,C,CAEA;AACA;;AACA,IAAMC,MAAM,GAAIC,OAAD,CAAA,OAACA,IAAhB,OAAA;AACA,IAAMC,aAAa,GAAG;AACpBC,EAAAA,OAAO,EADa,IAAA;AAEpBC,EAAAA,QAAQ,EAFY,KAAA;AAGpBC,EAAAA,MAAM,EAHc,KAAA;AAIpBC,EAAAA,QAAQ,EAJY,KAAA;AAKpBC,EAAAA,QAAQ,EALY,KAAA;AAMpBC,EAAAA,SAAS,EAAE;AANS,CAAtB,C,CASA;;AACA,IAAMC,MAAM,GAAG,IAAA,MAAA,CAAf,aAAe,CAAf;AACAA,MAAM,CAANA,GAAAA,CAAAA,kBAAAA;AAEA,IAAMC,SAAS,GAAG,IAAA,MAAA,CAAlB,aAAkB,CAAlB;AACAA,SAAS,CAATA,GAAAA,CAAAA,kBAAAA;AACAA,SAAS,CAATA,GAAAA,CAAAA,SAAAA,E,CAEA;;AACA,IAAMC,WAAmC,GAAzC,EAAA,C,CAEA;AACA;AACA;;AAEA,OAAO,SAAA,MAAA,GAA+C;AAAA,MAAA,iBAAA,GACnBK,gBADmB,EAAA;AAAA,MAC5CH,KAD4C,GAAA,iBAAA,CAAA,KAAA;AAAA,MACrCC,QADqC,GAAA,iBAAA,CAAA,QAAA;AAAA,MAC3BC,GAD2B,GAAA,iBAAA,CAAA,GAAA;;AAAA,OAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAA5BH,MAA4B,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AAA5BA,IAAAA,MAA4B,CAAA,IAAA,CAA5BA,GAA4B,SAAA,CAAA,IAAA,CAA5BA;AAA4B;;AAGpD,MAAIA,MAAM,CAANA,MAAAA,KAAJ,CAAA,EAAyB;AACvB,WAAA,EAAA;AAJkD,GAAA,CAOpD;;;AACA,MAAMK,cAAc,GAAG,MAAM,CAAN,MAAA,CAAkC,UAAA,GAAA,EAAA,KAAA,EAAgB;AACvE,QAAI,OAAA,KAAA,KAAJ,QAAA,EAA+B;AAC7BC,MAAAA,KAAK,CAALA,KAAAA,CAAAA,GAAAA,EAAAA,OAAAA,CAAyB,UAAA,SAAA,EAAa;AACpC,YAAIP,WAAW,CAAXA,SAAW,CAAXA,KAAJ,SAAA,EAA0C;AACxCQ,UAAAA,GAAG,CAAHA,IAAAA,CAASR,WAAW,CAApBQ,SAAoB,CAApBA;AACD;AAHHD,OAAAA;AADF,KAAA,MAMO;AACLC,MAAAA,GAAG,CAAHA,IAAAA,CAAAA,KAAAA;AACD;;AAED,WAAA,GAAA;AAXqB,GAAA,EAR6B,EAQ7B,CAAvB,CARoD,CAsBpD;;AACA,MAAMC,gBAAgB,GAAGC,eAAe,CAAA,cAAA,EAAA,WAAA,EAvBY,KAuBZ,CAAxC,CAvBoD,CAwBpD;AACA;;AACA,MAAMC,mBAAmB,GAAA,MAAMP,GAAG,GAAA,GAAA,GAAT,EAAA,IAAA,gBAAA,GAA0CK,gBAAgB,CAAnF,IAAA;AAEAT,EAAAA,WAAW,CAAXA,mBAAW,CAAXA,GAAmCS,gBAAgB,CA5BC,MA4BpDT,CA5BoD,CA8BpD;;AACA,MAAMY,QAAQ,GAAA,MAAA,qBAAA,GAAA,GAAA,GA/BsC,mBA+BpD,CA/BoD,CAiCpD;;AACA,MAAMC,GAAG,GAAGT,GAAG,GAAGL,SAAS,CAAA,QAAA,EAAWU,gBAAgB,CAAvC,MAAY,CAAZ,GAAkDX,MAAM,CAAA,QAAA,EAAWW,gBAAgB,CAAlG,MAAuE,CAAvE;AAEAN,EAAAA,QAAQ,CAARA,YAAAA,CAAAA,GAAAA;AAEA,SAAOW,EAAE,CAAA,qBAAA,EAAT,mBAAS,CAAT;AACD","sourcesContent":["import { serializeStyles } from '@emotion/serialize';\nimport { ICSSInJSStyle, ThemePrepared } from '@fluentui/styles';\nimport cx from 'classnames';\n// @ts-ignore\nimport _Stylis from 'stylis';\n// @ts-ignore No typings :(\nimport focusVisiblePlugin from '@quid/stylis-plugin-focus-visible';\n// @ts-ignore No typings :(\nimport rtlPlugin from 'stylis-plugin-rtl';\n\nimport { useFluentContext } from '../context';\n\n//\n// Types\n//\n\n// Inline keyframe definitions are not supported by useCSS() hook\nexport type UseCSSStyle = Omit<ICSSInJSStyle, 'animationName'> & { animationName?: string };\nexport type UseCSSStyleInput = string | UseCSSStyle | ((theme: ThemePrepared) => UseCSSStyle);\n\n//\n// Definitions\n//\n\n// SPECIFICITY_CLASSNAME is used to increase the specificity of produced CSS to win over other defined classes.\n// \"css\" used for production to decrease DOM size.\nconst SPECIFICITY_CLASSNAME = process.env.NODE_ENV === 'production' ? 'css' : 'use-css';\nconst CLASSNAME_PREFIX = 'f';\n\n// `stylis@3` is a CJS library, there are known issues with them:\n// https://github.com/rollup/rollup/issues/1267#issuecomment-446681320\nconst Stylis = (_Stylis as any).default || _Stylis;\nconst stylisOptions = {\n  cascade: true,\n  compress: false,\n  global: false,\n  keyframe: false,\n  preserve: false,\n  semicolon: false,\n};\n\n// Two separate instances are requires as we can't call Stylis plugins conditionally\nconst stylis = new Stylis(stylisOptions);\nstylis.use(focusVisiblePlugin);\n\nconst rtlStylis = new Stylis(stylisOptions);\nrtlStylis.use(focusVisiblePlugin);\nrtlStylis.use(rtlPlugin);\n\n// Stores a mapping between hashed string and cssified styles object\nconst stylesCache: Record<string, string> = {};\n\n//\n// Hook\n//\n\nexport function useCSS(...styles: UseCSSStyleInput[]) {\n  const { theme, renderer, rtl } = useFluentContext();\n\n  if (styles.length === 0) {\n    return '';\n  }\n\n  // This resolution allows to map passed classnames to actual styles that can be used on next styles\n  const resolvedStyles = styles.reduce<UseCSSStyleInput[]>((acc, style) => {\n    if (typeof style === 'string') {\n      style.split(' ').forEach(className => {\n        if (stylesCache[className] !== undefined) {\n          acc.push(stylesCache[className]);\n        }\n      });\n    } else {\n      acc.push(style);\n    }\n\n    return acc;\n  }, []);\n\n  // serializeStyles() will concat all passed styles and will resolve functions\n  const serializedStyles = serializeStyles(resolvedStyles, stylesCache, theme);\n  // \".name\" is not a valid CSS classname as it can start from a digit\n  //  \"r\" prefix is used to avoid collision between LTR and RTL styles\n  const serializedClassName = `${rtl ? 'r' : ''}${CLASSNAME_PREFIX}${serializedStyles.name}`;\n\n  stylesCache[serializedClassName] = serializedStyles.styles;\n\n  // Selector should include specificity className to have higher specificity than other passed classes\n  const selector = `.${SPECIFICITY_CLASSNAME}.${serializedClassName}`;\n\n  // Stylis performs transform of nested selectors and \":focus-visible\"\n  const css = rtl ? rtlStylis(selector, serializedStyles.styles) : stylis(selector, serializedStyles.styles);\n\n  renderer.renderGlobal(css);\n\n  return cx(SPECIFICITY_CLASSNAME, serializedClassName);\n}\n"]},"metadata":{},"sourceType":"module"}