{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nexport var DEFAULT_CLIENT_RETRY_COUNT = 3; // intervals are in ms\n\nexport var DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\nexport var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\nexport var DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;\nexport function isNumber(n) {\n  return typeof n === \"number\";\n}\n/**\n * @internal\n * Determines if the operation should be retried.\n *\n * @param retryLimit - Specifies the max number of retries.\n * @param predicate - Initial chekck on whether to retry based on given responses or errors\n * @param retryData -  The retry data.\n * @returns True if the operation qualifies for a retry; false otherwise.\n */\n\nexport function shouldRetry(retryLimit, predicate, retryData, response, error) {\n  if (!predicate(response, error)) {\n    return false;\n  }\n\n  return retryData.retryCount < retryLimit;\n}\n/**\n * @internal\n * Updates the retry data for the next attempt.\n *\n * @param retryOptions - specifies retry interval, and its lower bound and upper bound.\n * @param retryData -  The retry data.\n * @param err - The operation\"s error, if any.\n */\n\nexport function updateRetryData(retryOptions, retryData, err) {\n  if (retryData === void 0) {\n    retryData = {\n      retryCount: 0,\n      retryInterval: 0\n    };\n  }\n\n  if (err) {\n    if (retryData.error) {\n      err.innerError = retryData.error;\n    }\n\n    retryData.error = err;\n  } // Adjust retry count\n\n\n  retryData.retryCount++; // Adjust retry interval\n\n  var incrementDelta = Math.pow(2, retryData.retryCount - 1) - 1;\n  var boundedRandDelta = retryOptions.retryInterval * 0.8 + Math.floor(Math.random() * (retryOptions.retryInterval * 0.4));\n  incrementDelta *= boundedRandDelta;\n  retryData.retryInterval = Math.min(retryOptions.minRetryInterval + incrementDelta, retryOptions.maxRetryInterval);\n  return retryData;\n}","map":{"version":3,"sources":["../../../src/util/exponentialBackoffStrategy.ts"],"names":[],"mappings":"AAAA;AACA;AAIA,OAAO,IAAM,0BAA0B,GAAG,CAAnC,C,CACP;;AACA,OAAO,IAAM,6BAA6B,GAAG,OAAO,EAA7C;AACP,OAAO,IAAM,iCAAiC,GAAG,OAAO,EAAjD;AACP,OAAO,IAAM,iCAAiC,GAAG,OAAO,CAAjD;AAEP,OAAM,SAAU,QAAV,CAAmB,CAAnB,EAA6B;AACjC,SAAO,OAAO,CAAP,KAAa,QAApB;AACD;AAaD;;;;;;;;AAQG;;AACH,OAAM,SAAU,WAAV,CACJ,UADI,EAEJ,SAFI,EAGJ,SAHI,EAIJ,QAJI,EAKJ,KALI,EAKc;AAElB,MAAI,CAAC,SAAS,CAAC,QAAD,EAAW,KAAX,CAAd,EAAiC;AAC/B,WAAO,KAAP;AACD;;AAED,SAAO,SAAS,CAAC,UAAV,GAAuB,UAA9B;AACD;AAED;;;;;;;AAOG;;AACH,OAAM,SAAU,eAAV,CACJ,YADI,EAEJ,SAFI,EAGJ,GAHI,EAGY;AADhB,MAAA,SAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,SAAA,GAAA;AAAyB,MAAA,UAAU,EAAE,CAArC;AAAwC,MAAA,aAAa,EAAE;AAAvD,KAAA;AAA0D;;AAG1D,MAAI,GAAJ,EAAS;AACP,QAAI,SAAS,CAAC,KAAd,EAAqB;AACnB,MAAA,GAAG,CAAC,UAAJ,GAAiB,SAAS,CAAC,KAA3B;AACD;;AAED,IAAA,SAAS,CAAC,KAAV,GAAkB,GAAlB;AACD,GARe,CAUhB;;;AACA,EAAA,SAAS,CAAC,UAAV,GAXgB,CAahB;;AACA,MAAI,cAAc,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,SAAS,CAAC,UAAV,GAAuB,CAAnC,IAAwC,CAA7D;AACA,MAAM,gBAAgB,GACpB,YAAY,CAAC,aAAb,GAA6B,GAA7B,GACA,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,MAAL,MAAiB,YAAY,CAAC,aAAb,GAA6B,GAA9C,CAAX,CAFF;AAGA,EAAA,cAAc,IAAI,gBAAlB;AAEA,EAAA,SAAS,CAAC,aAAV,GAA0B,IAAI,CAAC,GAAL,CACxB,YAAY,CAAC,gBAAb,GAAgC,cADR,EAExB,YAAY,CAAC,gBAFW,CAA1B;AAKA,SAAO,SAAP;AACD","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpOperationResponse } from \"../coreHttp\";\n\nexport const DEFAULT_CLIENT_RETRY_COUNT = 3;\n// intervals are in ms\nexport const DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\nexport const DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\nexport const DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;\n\nexport function isNumber(n: unknown): n is number {\n  return typeof n === \"number\";\n}\nexport interface RetryData {\n  retryCount: number;\n  retryInterval: number;\n  error?: RetryError;\n}\n\nexport interface RetryError extends Error {\n  message: string;\n  code?: string;\n  innerError?: RetryError;\n}\n\n/**\n * @internal\n * Determines if the operation should be retried.\n *\n * @param retryLimit - Specifies the max number of retries.\n * @param predicate - Initial chekck on whether to retry based on given responses or errors\n * @param retryData -  The retry data.\n * @returns True if the operation qualifies for a retry; false otherwise.\n */\nexport function shouldRetry(\n  retryLimit: number,\n  predicate: (response?: HttpOperationResponse, error?: RetryError) => boolean,\n  retryData: RetryData,\n  response?: HttpOperationResponse,\n  error?: RetryError\n): boolean {\n  if (!predicate(response, error)) {\n    return false;\n  }\n\n  return retryData.retryCount < retryLimit;\n}\n\n/**\n * @internal\n * Updates the retry data for the next attempt.\n *\n * @param retryOptions - specifies retry interval, and its lower bound and upper bound.\n * @param retryData -  The retry data.\n * @param err - The operation\"s error, if any.\n */\nexport function updateRetryData(\n  retryOptions: { retryInterval: number; minRetryInterval: number; maxRetryInterval: number },\n  retryData: RetryData = { retryCount: 0, retryInterval: 0 },\n  err?: RetryError\n): RetryData {\n  if (err) {\n    if (retryData.error) {\n      err.innerError = retryData.error;\n    }\n\n    retryData.error = err;\n  }\n\n  // Adjust retry count\n  retryData.retryCount++;\n\n  // Adjust retry interval\n  let incrementDelta = Math.pow(2, retryData.retryCount - 1) - 1;\n  const boundedRandDelta =\n    retryOptions.retryInterval * 0.8 +\n    Math.floor(Math.random() * (retryOptions.retryInterval * 0.4));\n  incrementDelta *= boundedRandDelta;\n\n  retryData.retryInterval = Math.min(\n    retryOptions.minRetryInterval + incrementDelta,\n    retryOptions.maxRetryInterval\n  );\n\n  return retryData;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}