{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { IS_FOCUSABLE_ATTRIBUTE } from '@fluentui/accessibility';\nimport { getParent, getWindow } from '@uifabric/utilities';\nexport var IS_VISIBLE_ATTRIBUTE = 'data-is-visible';\nexport var FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nexport var FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';\nexport var HIDDEN_FROM_ACC_TREE = 'data-is-hidden-from-acc-tree';\nexport { getDocument, getParent, getWindow } from '@uifabric/utilities';\n/**\n * Gets the first focusable element.\n *\n * @public\n */\n\nexport function getFirstFocusable(rootElement, currentElement, includeElementsInFocusZones) {\n  return getNextElement(rootElement, currentElement, true\n  /* checkNode */\n  , false\n  /* suppressParentTraversal */\n  , false\n  /* suppressChildTraversal */\n  , includeElementsInFocusZones);\n}\n/**\n * Gets the last focusable element.\n *\n * @public\n */\n\nexport function getLastFocusable(rootElement, currentElement, includeElementsInFocusZones) {\n  return getPreviousElement(rootElement, currentElement, true\n  /* checkNode */\n  , false\n  /* suppressParentTraversal */\n  , true\n  /* traverseChildren */\n  , includeElementsInFocusZones);\n}\n/**\n * Gets the first tabbable element.\n * The difference between focusable and tabbable is that tabbable elements are focusable elements that also have tabIndex != -1.\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues forward.  Typical use passes rootElement.firstChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @public\n */\n\nexport function getFirstTabbable(rootElement, currentElement, includeElementsInFocusZones, checkNode) {\n  return getNextElement(rootElement, currentElement, checkNode, false\n  /* suppressParentTraversal */\n  , false\n  /* suppressChildTraversal */\n  , includeElementsInFocusZones, true\n  /* tabbable */\n  );\n}\n/**\n * Gets the last tabbable element.\n * The difference between focusable and tabbable is that tabbable elements are focusable elements that also have tabIndex != -1.\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues in reverse.  Typical use passes rootElement.lastChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @public\n */\n\nexport function getLastTabbable(rootElement, currentElement, includeElementsInFocusZones, checkNode) {\n  return getPreviousElement(rootElement, currentElement, checkNode, false\n  /* suppressParentTraversal */\n  , true\n  /* traverseChildren */\n  , includeElementsInFocusZones, true\n  /* tabbable */\n  );\n}\n/**\n * Traverse to find the previous element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n */\n\nexport function getPreviousElement(rootElement, currentElement, checkNode, suppressParentTraversal, traverseChildren, includeElementsInFocusZones, tabbable) {\n  if (!currentElement || currentElement === rootElement) {\n    return null;\n  }\n\n  var isCurrentElementVisible = isElementVisible(currentElement); // Check its children.\n\n  if (traverseChildren && isCurrentElementVisible && (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {\n    var childMatch = getPreviousElement(rootElement, currentElement.lastElementChild, true, true, true, includeElementsInFocusZones, tabbable);\n\n    if (childMatch) {\n      if (tabbable && isElementTabbable(childMatch, true) || !tabbable) {\n        return childMatch;\n      }\n\n      var childMatchSiblingMatch = getPreviousElement(rootElement, childMatch.previousElementSibling, true, true, true, includeElementsInFocusZones, tabbable);\n\n      if (childMatchSiblingMatch) {\n        return childMatchSiblingMatch;\n      }\n\n      var childMatchParent = childMatch.parentElement; // At this point if we have not found any potential matches\n      // start looking at the rest of the subtree under the currentParent.\n      // NOTE: We do not want to recurse here because doing so could\n      // cause elements to get skipped.\n\n      while (childMatchParent && childMatchParent !== currentElement) {\n        var childMatchParentMatch = getPreviousElement(rootElement, childMatchParent.previousElementSibling, true, true, true, includeElementsInFocusZones, tabbable);\n\n        if (childMatchParentMatch) {\n          return childMatchParentMatch;\n        }\n\n        childMatchParent = childMatchParent.parentElement;\n      }\n    }\n  } // Check the current node, if it's not the first traversal.\n\n\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\n    return currentElement;\n  } // Check its previous sibling.\n\n\n  var siblingMatch = getPreviousElement(rootElement, currentElement.previousElementSibling, true, true, true, includeElementsInFocusZones, tabbable);\n\n  if (siblingMatch) {\n    return siblingMatch;\n  } // Check its parent.\n\n\n  if (!suppressParentTraversal) {\n    return getPreviousElement(rootElement, currentElement.parentElement, true, false, false, includeElementsInFocusZones, tabbable);\n  }\n\n  return null;\n}\n/**\n * Traverse to find the next focusable element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n */\n\nexport function getNextElement(rootElement, currentElement, checkNode, suppressParentTraversal, suppressChildTraversal, includeElementsInFocusZones, tabbable) {\n  if (!currentElement || currentElement === rootElement && suppressChildTraversal) {\n    return null;\n  }\n\n  var isCurrentElementVisible = isElementVisible(currentElement); // Check the current node, if it's not the first traversal.\n\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\n    return currentElement;\n  } // Check its children.\n\n\n  if (!suppressChildTraversal && isCurrentElementVisible && (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {\n    var childMatch = getNextElement(rootElement, currentElement.firstElementChild, true, true, false, includeElementsInFocusZones, tabbable);\n\n    if (childMatch) {\n      return childMatch;\n    }\n  }\n\n  if (currentElement === rootElement) {\n    return null;\n  } // Check its sibling.\n\n\n  var siblingMatch = getNextElement(rootElement, currentElement.nextElementSibling, true, true, false, includeElementsInFocusZones, tabbable);\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  if (!suppressParentTraversal) {\n    return getNextElement(rootElement, currentElement.parentElement, false, false, true, includeElementsInFocusZones, tabbable);\n  }\n\n  return null;\n}\n/**\n * Determines if an element is visible.\n *\n * @public\n */\n\nexport function isElementVisible(element) {\n  // If the element is not valid, return false.\n  if (!element || !element.getAttribute) {\n    return false;\n  }\n\n  var visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE); // If the element is explicitly marked with the visibility attribute, return that value as boolean.\n\n  if (visibilityAttribute !== null && visibilityAttribute !== undefined) {\n    return visibilityAttribute === 'true';\n  } // Fallback to other methods of determining actual visibility.\n\n\n  return element.offsetHeight !== 0 || element.offsetParent !== null || // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  element.isVisible === true; // used as a workaround for testing.\n}\n/**\n * Determines if an element can receive focus programmatically or via a mouse click.\n * If checkTabIndex is true, additionally checks to ensure the element can be focused with the tab key, meaning tabIndex != -1.\n *\n * @public\n */\n\nexport function isElementTabbable(element, checkTabIndex) {\n  // If this element is null or is disabled, it is not considered tabbable.\n  if (!element || element.disabled) {\n    return false;\n  }\n\n  var tabIndex = 0;\n  var tabIndexAttributeValue = null;\n\n  if (element && element.getAttribute) {\n    tabIndexAttributeValue = element.getAttribute('tabIndex');\n\n    if (tabIndexAttributeValue) {\n      tabIndex = parseInt(tabIndexAttributeValue, 10);\n    }\n  }\n\n  var isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;\n  var isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;\n  var result = !!element && isFocusableAttribute !== 'false' && (element.tagName === 'A' || element.tagName === 'BUTTON' || element.tagName === 'INPUT' || element.tagName === 'TEXTAREA' || isFocusableAttribute === 'true' || isTabIndexSet || element.getAttribute && element.getAttribute('role') === 'button');\n  return checkTabIndex ? tabIndex !== -1 && result : result;\n}\n/**\n * Determines if a given element is a focus zone.\n *\n * @public\n */\n\nexport function isElementFocusZone(element) {\n  return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));\n}\n/**\n * Determines if a given element is a focus sub zone.\n *\n * @public\n */\n\nexport function isElementFocusSubZone(element) {\n  return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');\n}\nvar targetToFocusOnNextRepaint = undefined;\n/**\n * Sets focus to an element asynchronously. The focus will be set at the next browser repaint,\n * meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame,\n * only the latest called focusAsync element will actually be focused\n * @param element - The element to focus\n */\n\nexport function focusAsync(element) {\n  if (element) {\n    // An element was already queued to be focused, so replace that one with the new element\n    if (targetToFocusOnNextRepaint) {\n      targetToFocusOnNextRepaint = element;\n      return;\n    }\n\n    targetToFocusOnNextRepaint = element;\n    var win = getWindow(element);\n\n    if (win) {\n      // element.focus() is a no-op if the element is no longer in the DOM, meaning this is always safe\n      win.requestAnimationFrame(function () {\n        targetToFocusOnNextRepaint && targetToFocusOnNextRepaint.focus(); // We are done focusing for this frame, so reset the queued focus element\n\n        targetToFocusOnNextRepaint = undefined;\n      });\n    }\n  }\n}\n/**\n * Finds the closest focusable element via an index path from a parent. See\n * `getElementIndexPath` for getting an index path from an element to a child.\n */\n\nexport function getFocusableByIndexPath(parent, path) {\n  var element = parent;\n\n  for (var _iterator = _createForOfIteratorHelperLoose(path), _step; !(_step = _iterator()).done;) {\n    var index = _step.value;\n    var nextChild = element.children[Math.min(index, element.children.length - 1)];\n\n    if (!nextChild) {\n      break;\n    }\n\n    element = nextChild;\n  }\n\n  element = isElementTabbable(element) && isElementVisible(element) ? element : getNextElement(parent, element, true) || getPreviousElement(parent, element);\n  return element;\n}\n/**\n * Finds the element index path from a parent element to a child element.\n *\n * If you had this node structure: \"A has children [B, C] and C has child D\",\n * the index path from A to D would be [1, 0], or `parent.chidren[1].children[0]`.\n */\n\nexport function getElementIndexPath(fromElement, toElement) {\n  var path = [];\n  var currentElement = toElement;\n\n  while (currentElement && fromElement && currentElement !== fromElement) {\n    var parent = getParent(currentElement, false);\n\n    if (parent === null) {\n      return [];\n    }\n\n    path.unshift(Array.prototype.indexOf.call(parent.children, currentElement));\n    currentElement = parent;\n  }\n\n  return path;\n}","map":{"version":3,"sources":["FocusZone/focusUtilities.ts"],"names":["IS_VISIBLE_ATTRIBUTE","FOCUSZONE_ID_ATTRIBUTE","FOCUSZONE_SUB_ATTRIBUTE","HIDDEN_FROM_ACC_TREE","getNextElement","getPreviousElement","currentElement","isCurrentElementVisible","isElementVisible","traverseChildren","includeElementsInFocusZones","isElementFocusZone","isElementFocusSubZone","childMatch","tabbable","isElementTabbable","childMatchSiblingMatch","childMatchParent","childMatchParentMatch","checkNode","siblingMatch","element","visibilityAttribute","tabIndex","tabIndexAttributeValue","parseInt","isFocusableAttribute","isTabIndexSet","result","checkTabIndex","targetToFocusOnNextRepaint","win","getWindow","index","nextChild","Math","path","parent","getParent","Array"],"mappings":"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","sourcesContent":["import { IS_FOCUSABLE_ATTRIBUTE } from '@fluentui/accessibility';\nimport { getParent, getWindow } from '@uifabric/utilities';\n\nexport const IS_VISIBLE_ATTRIBUTE = 'data-is-visible';\nexport const FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nexport const FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';\nexport const HIDDEN_FROM_ACC_TREE = 'data-is-hidden-from-acc-tree';\n\nexport { getDocument, getParent, getWindow } from '@uifabric/utilities';\n\n/**\n * Gets the first focusable element.\n *\n * @public\n */\nexport function getFirstFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n): HTMLElement | null {\n  return getNextElement(\n    rootElement,\n    currentElement,\n    true /* checkNode */,\n    false /* suppressParentTraversal */,\n    false /* suppressChildTraversal */,\n    includeElementsInFocusZones,\n  );\n}\n\n/**\n * Gets the last focusable element.\n *\n * @public\n */\nexport function getLastFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n): HTMLElement | null {\n  return getPreviousElement(\n    rootElement,\n    currentElement,\n    true /* checkNode */,\n    false /* suppressParentTraversal */,\n    true /* traverseChildren */,\n    includeElementsInFocusZones,\n  );\n}\n\n/**\n * Gets the first tabbable element.\n * The difference between focusable and tabbable is that tabbable elements are focusable elements that also have tabIndex != -1.\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues forward.  Typical use passes rootElement.firstChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @public\n */\nexport function getFirstTabbable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  checkNode?: boolean,\n): HTMLElement | null {\n  return getNextElement(\n    rootElement,\n    currentElement,\n    checkNode,\n    false /* suppressParentTraversal */,\n    false /* suppressChildTraversal */,\n    includeElementsInFocusZones,\n    true /* tabbable */,\n  );\n}\n\n/**\n * Gets the last tabbable element.\n * The difference between focusable and tabbable is that tabbable elements are focusable elements that also have tabIndex != -1.\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues in reverse.  Typical use passes rootElement.lastChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @public\n */\nexport function getLastTabbable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  checkNode?: boolean,\n): HTMLElement | null {\n  return getPreviousElement(\n    rootElement,\n    currentElement,\n    checkNode,\n    false /* suppressParentTraversal */,\n    true /* traverseChildren */,\n    includeElementsInFocusZones,\n    true /* tabbable */,\n  );\n}\n\n/**\n * Traverse to find the previous element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n */\nexport function getPreviousElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement | null,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  traverseChildren?: boolean,\n  includeElementsInFocusZones?: boolean,\n  tabbable?: boolean,\n): HTMLElement | null {\n  if (!currentElement || currentElement === rootElement) {\n    return null;\n  }\n\n  const isCurrentElementVisible = isElementVisible(currentElement);\n\n  // Check its children.\n  if (\n    traverseChildren &&\n    isCurrentElementVisible &&\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))\n  ) {\n    const childMatch = getPreviousElement(\n      rootElement,\n      currentElement.lastElementChild as HTMLElement,\n      true,\n      true,\n      true,\n      includeElementsInFocusZones,\n      tabbable,\n    );\n\n    if (childMatch) {\n      if ((tabbable && isElementTabbable(childMatch, true)) || !tabbable) {\n        return childMatch;\n      }\n\n      const childMatchSiblingMatch = getPreviousElement(\n        rootElement,\n        childMatch.previousElementSibling as HTMLElement,\n        true,\n        true,\n        true,\n        includeElementsInFocusZones,\n        tabbable,\n      );\n      if (childMatchSiblingMatch) {\n        return childMatchSiblingMatch;\n      }\n\n      let childMatchParent = childMatch.parentElement;\n\n      // At this point if we have not found any potential matches\n      // start looking at the rest of the subtree under the currentParent.\n      // NOTE: We do not want to recurse here because doing so could\n      // cause elements to get skipped.\n      while (childMatchParent && childMatchParent !== currentElement) {\n        const childMatchParentMatch = getPreviousElement(\n          rootElement,\n          childMatchParent.previousElementSibling as HTMLElement,\n          true,\n          true,\n          true,\n          includeElementsInFocusZones,\n          tabbable,\n        );\n\n        if (childMatchParentMatch) {\n          return childMatchParentMatch;\n        }\n\n        childMatchParent = childMatchParent.parentElement;\n      }\n    }\n  }\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\n    return currentElement;\n  }\n\n  // Check its previous sibling.\n  const siblingMatch = getPreviousElement(\n    rootElement,\n    currentElement.previousElementSibling as HTMLElement,\n    true,\n    true,\n    true,\n    includeElementsInFocusZones,\n    tabbable,\n  );\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  // Check its parent.\n  if (!suppressParentTraversal) {\n    return getPreviousElement(\n      rootElement,\n      currentElement.parentElement,\n      true,\n      false,\n      false,\n      includeElementsInFocusZones,\n      tabbable,\n    );\n  }\n\n  return null;\n}\n\n/**\n * Traverse to find the next focusable element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n */\nexport function getNextElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement | null,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  suppressChildTraversal?: boolean,\n  includeElementsInFocusZones?: boolean,\n  tabbable?: boolean,\n): HTMLElement | null {\n  if (!currentElement || (currentElement === rootElement && suppressChildTraversal)) {\n    return null;\n  }\n\n  const isCurrentElementVisible = isElementVisible(currentElement);\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\n    return currentElement;\n  }\n\n  // Check its children.\n  if (\n    !suppressChildTraversal &&\n    isCurrentElementVisible &&\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))\n  ) {\n    const childMatch = getNextElement(\n      rootElement,\n      currentElement.firstElementChild as HTMLElement,\n      true,\n      true,\n      false,\n      includeElementsInFocusZones,\n      tabbable,\n    );\n\n    if (childMatch) {\n      return childMatch;\n    }\n  }\n\n  if (currentElement === rootElement) {\n    return null;\n  }\n\n  // Check its sibling.\n  const siblingMatch = getNextElement(\n    rootElement,\n    currentElement.nextElementSibling as HTMLElement,\n    true,\n    true,\n    false,\n    includeElementsInFocusZones,\n    tabbable,\n  );\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  if (!suppressParentTraversal) {\n    return getNextElement(\n      rootElement,\n      currentElement.parentElement,\n      false,\n      false,\n      true,\n      includeElementsInFocusZones,\n      tabbable,\n    );\n  }\n\n  return null;\n}\n\n/**\n * Determines if an element is visible.\n *\n * @public\n */\nexport function isElementVisible(element: HTMLElement | undefined | null): boolean {\n  // If the element is not valid, return false.\n  if (!element || !element.getAttribute) {\n    return false;\n  }\n\n  const visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);\n\n  // If the element is explicitly marked with the visibility attribute, return that value as boolean.\n  if (visibilityAttribute !== null && visibilityAttribute !== undefined) {\n    return visibilityAttribute === 'true';\n  }\n\n  // Fallback to other methods of determining actual visibility.\n  return (\n    element.offsetHeight !== 0 ||\n    element.offsetParent !== null ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (element as any).isVisible === true\n  ); // used as a workaround for testing.\n}\n\n/**\n * Determines if an element can receive focus programmatically or via a mouse click.\n * If checkTabIndex is true, additionally checks to ensure the element can be focused with the tab key, meaning tabIndex != -1.\n *\n * @public\n */\nexport function isElementTabbable(element: HTMLElement, checkTabIndex?: boolean): boolean {\n  // If this element is null or is disabled, it is not considered tabbable.\n  if (!element || (element as HTMLButtonElement).disabled) {\n    return false;\n  }\n\n  let tabIndex = 0;\n  let tabIndexAttributeValue: string | null = null;\n\n  if (element && element.getAttribute) {\n    tabIndexAttributeValue = element.getAttribute('tabIndex');\n\n    if (tabIndexAttributeValue) {\n      tabIndex = parseInt(tabIndexAttributeValue, 10);\n    }\n  }\n\n  const isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;\n  const isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;\n\n  const result =\n    !!element &&\n    isFocusableAttribute !== 'false' &&\n    (element.tagName === 'A' ||\n      element.tagName === 'BUTTON' ||\n      element.tagName === 'INPUT' ||\n      element.tagName === 'TEXTAREA' ||\n      isFocusableAttribute === 'true' ||\n      isTabIndexSet ||\n      (element.getAttribute && element.getAttribute('role') === 'button'));\n\n  return checkTabIndex ? tabIndex !== -1 && result : result;\n}\n\n/**\n * Determines if a given element is a focus zone.\n *\n * @public\n */\nexport function isElementFocusZone(element?: HTMLElement): boolean {\n  return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));\n}\n\n/**\n * Determines if a given element is a focus sub zone.\n *\n * @public\n */\nexport function isElementFocusSubZone(element?: HTMLElement): boolean {\n  return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');\n}\n\nlet targetToFocusOnNextRepaint: HTMLElement | { focus: () => void } | null | undefined = undefined;\n\n/**\n * Sets focus to an element asynchronously. The focus will be set at the next browser repaint,\n * meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame,\n * only the latest called focusAsync element will actually be focused\n * @param element - The element to focus\n */\nexport function focusAsync(element: HTMLElement | { focus: () => void } | undefined | null): void {\n  if (element) {\n    // An element was already queued to be focused, so replace that one with the new element\n    if (targetToFocusOnNextRepaint) {\n      targetToFocusOnNextRepaint = element;\n      return;\n    }\n\n    targetToFocusOnNextRepaint = element;\n\n    const win = getWindow(element as Element);\n\n    if (win) {\n      // element.focus() is a no-op if the element is no longer in the DOM, meaning this is always safe\n      win.requestAnimationFrame(() => {\n        targetToFocusOnNextRepaint && targetToFocusOnNextRepaint.focus();\n\n        // We are done focusing for this frame, so reset the queued focus element\n        targetToFocusOnNextRepaint = undefined;\n      });\n    }\n  }\n}\n\n/**\n * Finds the closest focusable element via an index path from a parent. See\n * `getElementIndexPath` for getting an index path from an element to a child.\n */\nexport function getFocusableByIndexPath(parent: HTMLElement, path: number[]): HTMLElement | undefined {\n  let element = parent;\n\n  for (const index of path) {\n    const nextChild = element.children[Math.min(index, element.children.length - 1)] as HTMLElement;\n\n    if (!nextChild) {\n      break;\n    }\n    element = nextChild;\n  }\n\n  element =\n    isElementTabbable(element) && isElementVisible(element)\n      ? element\n      : getNextElement(parent, element, true) || getPreviousElement(parent, element)!;\n\n  return element as HTMLElement;\n}\n\n/**\n * Finds the element index path from a parent element to a child element.\n *\n * If you had this node structure: \"A has children [B, C] and C has child D\",\n * the index path from A to D would be [1, 0], or `parent.chidren[1].children[0]`.\n */\nexport function getElementIndexPath(fromElement: HTMLElement, toElement: HTMLElement): number[] {\n  const path: number[] = [];\n  let currentElement: HTMLElement = toElement;\n\n  while (currentElement && fromElement && currentElement !== fromElement) {\n    const parent = getParent(currentElement, false);\n\n    if (parent === null) {\n      return [];\n    }\n\n    path.unshift(Array.prototype.indexOf.call(parent.children, currentElement));\n    currentElement = parent;\n  }\n\n  return path;\n}\n"]},"metadata":{},"sourceType":"module"}