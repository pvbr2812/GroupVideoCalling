{"ast":null,"code":"var isObject = function isObject(o) {\n  return o !== null && typeof o === 'object' && !Array.isArray(o);\n};\n\nvar isValid = function isValid(k) {\n  return k !== '__proto__' && k !== 'prototype' && k !== 'constructor';\n}; // Heads Up!\n// Changes here need to consider breaking all object references.\n// Merging should result in a themes that are non-mutated and have broken references.\n\n\nexport var deepmerge = function deepmerge() {\n  var inner = function inner(target, source) {\n    Object.keys(source).forEach(function (k) {\n      if (isValid(k)) {\n        if (isObject(source[k])) {\n          if (!isObject(target[k])) {\n            target[k] = {};\n          }\n\n          inner(target[k], source[k]);\n        } else {\n          target[k] = source[k]; // TODO: do deep clone for arrays? We currently do not have any deep arrays in variables\n        }\n      }\n    });\n    return target;\n  };\n\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n\n  return sources.filter(Boolean).reduce(function (acc, src) {\n    return inner(acc, src);\n  }, {});\n};","map":{"version":3,"sources":["deepmerge.ts"],"names":["isObject","o","Array","isValid","k","deepmerge","sources","inner","Object","source","target"],"mappings":"AAAA,IAAMA,QAAQ,GAAG,SAAXA,QAAW,CAAA,CAAA,EAAC;AAAA,SAAIC,CAAC,KAADA,IAAAA,IAAc,OAAA,CAAA,KAAdA,QAAAA,IAAuC,CAACC,KAAK,CAALA,OAAAA,CAA5C,CAA4CA,CAA5C;AAAlB,CAAA;;AACA,IAAMC,OAAO,GAAG,SAAVA,OAAU,CAAA,CAAA,EAAC;AAAA,SAAIC,CAAC,KAADA,WAAAA,IAAqBA,CAAC,KAAtBA,WAAAA,IAA0CA,CAAC,KAA/C,aAAA;AAAjB,CAAA,C,CAEA;AACA;AACA;;;AACA,OAAO,IAAMC,SAAS,GAAG,SAAZA,SAAY,GAAgB;AACvC,MAAME,KAAK,GAAG,SAARA,KAAQ,CAAA,MAAA,EAAA,MAAA,EAAoB;AAChCC,IAAAA,MAAM,CAANA,IAAAA,CAAAA,MAAAA,EAAAA,OAAAA,CAA4B,UAAA,CAAA,EAAK;AAC/B,UAAIL,OAAO,CAAX,CAAW,CAAX,EAAgB;AACd,YAAIH,QAAQ,CAACS,MAAM,CAAnB,CAAmB,CAAP,CAAZ,EAAyB;AACvB,cAAI,CAACT,QAAQ,CAACU,MAAM,CAApB,CAAoB,CAAP,CAAb,EAA0B;AACxBA,YAAAA,MAAM,CAANA,CAAM,CAANA,GAAAA,EAAAA;AACD;;AAEDH,UAAAA,KAAK,CAACG,MAAM,CAAP,CAAO,CAAP,EAAYD,MAAM,CAAvBF,CAAuB,CAAlB,CAALA;AALF,SAAA,MAMO;AACLG,UAAAA,MAAM,CAANA,CAAM,CAANA,GAAYD,MAAM,CADb,CACa,CAAlBC,CADK,CACkB;AACxB;AACF;AAXHF,KAAAA;AAaA,WAAA,MAAA;AAdF,GAAA;;AADuC,OAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAAZF,OAAY,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AAAZA,IAAAA,OAAY,CAAA,IAAA,CAAZA,GAAY,SAAA,CAAA,IAAA,CAAZA;AAAY;;AAiBvC,SAAO,OAAO,CAAP,MAAA,CAAA,OAAA,EAAA,MAAA,CAA+B,UAAA,GAAA,EAAA,GAAA,EAAA;AAAA,WAAcC,KAAK,CAAA,GAAA,EAAnB,GAAmB,CAAnB;AAA/B,GAAA,EAAP,EAAO,CAAP;AAjBK,CAAA","sourcesContent":["const isObject = o => o !== null && typeof o === 'object' && !Array.isArray(o);\nconst isValid = k => k !== '__proto__' && k !== 'prototype' && k !== 'constructor';\n\n// Heads Up!\n// Changes here need to consider breaking all object references.\n// Merging should result in a themes that are non-mutated and have broken references.\nexport const deepmerge = (...sources) => {\n  const inner = (target, source) => {\n    Object.keys(source).forEach(k => {\n      if (isValid(k)) {\n        if (isObject(source[k])) {\n          if (!isObject(target[k])) {\n            target[k] = {};\n          }\n\n          inner(target[k], source[k]);\n        } else {\n          target[k] = source[k]; // TODO: do deep clone for arrays? We currently do not have any deep arrays in variables\n        }\n      }\n    });\n    return target;\n  };\n  return sources.filter(Boolean).reduce((acc, src) => inner(acc, src), {});\n};\n"]},"metadata":{},"sourceType":"module"}