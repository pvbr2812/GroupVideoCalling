{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport * as React from 'react';\nimport { defaultMappedProps } from './defaultMappedProps';\nimport { mergeSlotProp } from './mergeSlotProp';\nexport var NullRender = function () {\n  return null;\n};\n/**\n * Helper utility which resolves the slots and slot props derived from user input.\n */\n\nexport function resolveSlotProps(result, options) {\n  var state = result.state,\n      slots = result.slots,\n      slotProps = result.slotProps; // Derive the default slot props from the config, if provided.\n\n  options.slotProps.forEach(function (definition) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var nextSlotProps = definition(state);\n    Object.keys(nextSlotProps).forEach(function (key) {\n      slotProps[key] = __assign(__assign({}, slotProps[key]), nextSlotProps[key]);\n    });\n  }); //  Mix unrecognized props onto root, appropriate, excluding the handled props.\n\n  assignToMapObject(slotProps, 'root', getUnhandledProps(state, options)); // Iterate through slots and resolve shorthand values.\n\n  Object.keys(slots).forEach(function (slotName) {\n    var slot = slots[slotName]; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    var slotProp = state[slotName];\n\n    if (slot && slotProp !== undefined && slotProp !== null) {\n      var mergedSlotProp = mergeSlotProp(slotProp, slotProps[slotName], slot && slot.shorthandConfig && slot.shorthandConfig.mappedProp || defaultMappedProps[slot]);\n\n      if (typeof mergedSlotProp.children === 'function') {\n        var children = slotProp.children,\n            restProps = __rest(slotProp, [\"children\"]); // If the children is a function, replace the slot.\n\n\n        slots[slotName] = React.Fragment;\n        slotProps[slotName] = {\n          children: slotProp.children(slot, __assign(__assign({}, slotProps[slotName]), restProps))\n        };\n      } else {\n        slotProps[slotName] = mergedSlotProp;\n      }\n    } // Ensure no slots are falsey\n\n\n    if (!slots[slotName] || slotProp === null) {\n      slots[slotName] = NullRender;\n    }\n  });\n  return result;\n}\n\nfunction assignToMapObject(map, key, value) {\n  if (value) {\n    if (!map[key]) {\n      map[key] = {};\n    }\n\n    map[key] = __assign(__assign({}, map[key]), value);\n  }\n}\n\nfunction getUnhandledProps(props, options) {\n  var unhandledProps = {};\n  var slots = Object.keys(options.slots);\n\n  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\n    var key = _a[_i];\n\n    if (key !== 'className' && key !== 'as' && options.handledProps.indexOf(key) === -1 && slots.indexOf(key) === -1) {\n      unhandledProps[key] = props[key];\n    }\n  }\n\n  return unhandledProps;\n}","map":{"version":3,"sources":["resolveSlotProps.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { defaultMappedProps } from './defaultMappedProps';\nimport { ComposePreparedOptions, GenericDictionary, MergePropsResult } from './types';\nimport { mergeSlotProp } from './mergeSlotProp';\n\nexport const NullRender = () => null;\n\n/**\n * Helper utility which resolves the slots and slot props derived from user input.\n */\nexport function resolveSlotProps<TProps, TState = TProps>(\n  result: MergePropsResult<TState>,\n  options: ComposePreparedOptions<TProps, TState>,\n): MergePropsResult<TState> {\n  const { state, slots, slotProps } = result;\n\n  // Derive the default slot props from the config, if provided.\n  options.slotProps.forEach(definition => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const nextSlotProps = definition(state as any);\n\n    Object.keys(nextSlotProps).forEach(key => {\n      slotProps[key] = { ...slotProps[key], ...nextSlotProps[key] };\n    });\n  });\n\n  //  Mix unrecognized props onto root, appropriate, excluding the handled props.\n  assignToMapObject(slotProps, 'root', getUnhandledProps(state, options));\n\n  // Iterate through slots and resolve shorthand values.\n  Object.keys(slots).forEach((slotName: string) => {\n    const slot = slots[slotName];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const slotProp = (state as any)[slotName];\n\n    if (slot && slotProp !== undefined && slotProp !== null) {\n      const mergedSlotProp = mergeSlotProp(\n        slotProp,\n        slotProps[slotName],\n        (slot && slot.shorthandConfig && slot.shorthandConfig.mappedProp) || defaultMappedProps[slot],\n      );\n\n      if (typeof mergedSlotProp.children === 'function') {\n        const { children, ...restProps } = slotProp;\n        // If the children is a function, replace the slot.\n        slots[slotName] = React.Fragment;\n        slotProps[slotName] = {\n          children: slotProp.children(slot, { ...slotProps[slotName], ...restProps }),\n        };\n      } else {\n        slotProps[slotName] = mergedSlotProp;\n      }\n    }\n\n    // Ensure no slots are falsey\n    if (!slots[slotName] || slotProp === null) {\n      slots[slotName] = NullRender;\n    }\n  });\n\n  return result;\n}\n\nfunction assignToMapObject(map: Record<string, {}>, key: string, value: {}) {\n  if (value) {\n    if (!map[key]) {\n      map[key] = {};\n    }\n    map[key] = { ...map[key], ...value };\n  }\n}\n\nfunction getUnhandledProps<TProps, TState>(\n  props: GenericDictionary,\n  options: ComposePreparedOptions<TProps, TState>,\n): GenericDictionary {\n  const unhandledProps: GenericDictionary = {};\n  const slots = Object.keys(options.slots);\n\n  for (const key of Object.keys(props)) {\n    if (\n      key !== 'className' &&\n      key !== 'as' &&\n      options.handledProps.indexOf(key as keyof TProps) === -1 &&\n      slots.indexOf(key) === -1\n    ) {\n      unhandledProps[key] = props[key];\n    }\n  }\n\n  return unhandledProps;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}