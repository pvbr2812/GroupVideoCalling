{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nimport { RULE_TYPE, generateDeclarationReference } from 'fela-utils';\nimport generateCacheEntry from './generateCacheEntry';\nvar DECL_REGEX = /[.]([0-9a-z_-]+)([^{]+)?{([^:]+):([^}]+)}/gi;\nexport default function rehydrateRules(css) {\n  var media = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var support = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var cache = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var decl = void 0; // This excellent parsing implementation was originally taken from Styletron and modified to fit Fela\n  // https://github.com/rtsao/styletron/blob/master/packages/styletron-client/src/index.js#L47\n\n  /* eslint-disable no-unused-vars,no-cond-assign */\n\n  while (decl = DECL_REGEX.exec(css)) {\n    // $FlowFixMe\n    var _decl = decl,\n        _decl2 = _slicedToArray(_decl, 5),\n        ruleSet = _decl2[0],\n        className = _decl2[1],\n        pseudo = _decl2[2],\n        property = _decl2[3],\n        value = _decl2[4];\n    /* eslint-enable */\n\n\n    var declarationReference = generateDeclarationReference(property, value, pseudo, media, support);\n    cache[declarationReference] = generateCacheEntry(RULE_TYPE, className, property, value, pseudo, media, support);\n  }\n\n  return cache;\n}","map":{"version":3,"sources":["C:/Users/VISHWANATH REDDY/Documents/VSCODE2/communication-services-web-calling-hero/Calling/ClientApp/node_modules/fela-dom/es/dom/rehydration/rehydrateRules.js"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","RULE_TYPE","generateDeclarationReference","generateCacheEntry","DECL_REGEX","rehydrateRules","css","media","arguments","support","cache","decl","exec","_decl","_decl2","ruleSet","className","pseudo","property","declarationReference"],"mappings":"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","sourcesContent":["var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nimport { RULE_TYPE, generateDeclarationReference } from 'fela-utils';\n\nimport generateCacheEntry from './generateCacheEntry';\n\nvar DECL_REGEX = /[.]([0-9a-z_-]+)([^{]+)?{([^:]+):([^}]+)}/gi;\n\nexport default function rehydrateRules(css) {\n  var media = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var support = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var cache = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var decl = void 0;\n\n  // This excellent parsing implementation was originally taken from Styletron and modified to fit Fela\n  // https://github.com/rtsao/styletron/blob/master/packages/styletron-client/src/index.js#L47\n  /* eslint-disable no-unused-vars,no-cond-assign */\n  while (decl = DECL_REGEX.exec(css)) {\n    // $FlowFixMe\n    var _decl = decl,\n        _decl2 = _slicedToArray(_decl, 5),\n        ruleSet = _decl2[0],\n        className = _decl2[1],\n        pseudo = _decl2[2],\n        property = _decl2[3],\n        value = _decl2[4];\n    /* eslint-enable */\n\n    var declarationReference = generateDeclarationReference(property, value, pseudo, media, support);\n\n    cache[declarationReference] = generateCacheEntry(RULE_TYPE, className, property, value, pseudo, media, support);\n  }\n\n  return cache;\n}"]},"metadata":{},"sourceType":"module"}