{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __awaiter, __extends, __generator } from \"tslib\";\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { Constants } from \"../util/constants\";\nimport { delay } from \"../util/utils\";\nvar StatusCodes = Constants.HttpConstants.StatusCodes;\nexport function throttlingRetryPolicy() {\n  return {\n    create: function (nextPolicy, options) {\n      return new ThrottlingRetryPolicy(nextPolicy, options);\n    }\n  };\n}\n/**\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n */\n\nvar ThrottlingRetryPolicy =\n/** @class */\nfunction (_super) {\n  __extends(ThrottlingRetryPolicy, _super);\n\n  function ThrottlingRetryPolicy(nextPolicy, options, _handleResponse) {\n    var _this = _super.call(this, nextPolicy, options) || this;\n\n    _this._handleResponse = _handleResponse || _this._defaultResponseHandler;\n    return _this;\n  }\n\n  ThrottlingRetryPolicy.prototype.sendRequest = function (httpRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this._nextPolicy.sendRequest(httpRequest.clone()).then(function (response) {\n          if (response.status !== StatusCodes.TooManyRequests) {\n            return response;\n          } else {\n            return _this._handleResponse(httpRequest, response);\n          }\n        })];\n      });\n    });\n  };\n\n  ThrottlingRetryPolicy.prototype._defaultResponseHandler = function (httpRequest, httpResponse) {\n    return __awaiter(this, void 0, void 0, function () {\n      var retryAfterHeader, delayInMs;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        retryAfterHeader = httpResponse.headers.get(Constants.HeaderConstants.RETRY_AFTER);\n\n        if (retryAfterHeader) {\n          delayInMs = ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterHeader);\n\n          if (delayInMs) {\n            return [2\n            /*return*/\n            , delay(delayInMs).then(function (_) {\n              return _this._nextPolicy.sendRequest(httpRequest);\n            })];\n          }\n        }\n\n        return [2\n        /*return*/\n        , httpResponse];\n      });\n    });\n  };\n\n  ThrottlingRetryPolicy.parseRetryAfterHeader = function (headerValue) {\n    var retryAfterInSeconds = Number(headerValue);\n\n    if (Number.isNaN(retryAfterInSeconds)) {\n      return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);\n    } else {\n      return retryAfterInSeconds * 1000;\n    }\n  };\n\n  ThrottlingRetryPolicy.parseDateRetryAfterHeader = function (headerValue) {\n    try {\n      var now = Date.now();\n      var date = Date.parse(headerValue);\n      var diff = date - now;\n      return Number.isNaN(diff) ? undefined : diff;\n    } catch (error) {\n      return undefined;\n    }\n  };\n\n  return ThrottlingRetryPolicy;\n}(BaseRequestPolicy);\n\nexport { ThrottlingRetryPolicy };","map":{"version":3,"sources":["../../../src/policies/throttlingRetryPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyOptions,\n  RequestPolicyFactory\n} from \"./requestPolicy\";\nimport { WebResourceLike } from \"../webResource\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { Constants } from \"../util/constants\";\nimport { delay } from \"../util/utils\";\n\ntype ResponseHandler = (\n  httpRequest: WebResourceLike,\n  response: HttpOperationResponse\n) => Promise<HttpOperationResponse>;\nconst StatusCodes = Constants.HttpConstants.StatusCodes;\n\nexport function throttlingRetryPolicy(): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new ThrottlingRetryPolicy(nextPolicy, options);\n    }\n  };\n}\n\n/**\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n */\nexport class ThrottlingRetryPolicy extends BaseRequestPolicy {\n  private _handleResponse: ResponseHandler;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    _handleResponse?: ResponseHandler\n  ) {\n    super(nextPolicy, options);\n    this._handleResponse = _handleResponse || this._defaultResponseHandler;\n  }\n\n  public async sendRequest(httpRequest: WebResourceLike): Promise<HttpOperationResponse> {\n    return this._nextPolicy.sendRequest(httpRequest.clone()).then((response) => {\n      if (response.status !== StatusCodes.TooManyRequests) {\n        return response;\n      } else {\n        return this._handleResponse(httpRequest, response);\n      }\n    });\n  }\n\n  private async _defaultResponseHandler(\n    httpRequest: WebResourceLike,\n    httpResponse: HttpOperationResponse\n  ): Promise<HttpOperationResponse> {\n    const retryAfterHeader: string | undefined = httpResponse.headers.get(\n      Constants.HeaderConstants.RETRY_AFTER\n    );\n\n    if (retryAfterHeader) {\n      const delayInMs: number | undefined = ThrottlingRetryPolicy.parseRetryAfterHeader(\n        retryAfterHeader\n      );\n      if (delayInMs) {\n        return delay(delayInMs).then((_: any) => this._nextPolicy.sendRequest(httpRequest));\n      }\n    }\n\n    return httpResponse;\n  }\n\n  public static parseRetryAfterHeader(headerValue: string): number | undefined {\n    const retryAfterInSeconds = Number(headerValue);\n    if (Number.isNaN(retryAfterInSeconds)) {\n      return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);\n    } else {\n      return retryAfterInSeconds * 1000;\n    }\n  }\n\n  public static parseDateRetryAfterHeader(headerValue: string): number | undefined {\n    try {\n      const now: number = Date.now();\n      const date: number = Date.parse(headerValue);\n      const diff = date - now;\n\n      return Number.isNaN(diff) ? undefined : diff;\n    } catch (error) {\n      return undefined;\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}