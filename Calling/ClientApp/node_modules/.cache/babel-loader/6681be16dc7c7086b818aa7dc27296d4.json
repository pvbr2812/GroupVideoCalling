{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __assign, __awaiter, __extends, __generator } from \"tslib\";\nimport { getTracer, getTraceParentHeader } from \"@azure/core-tracing\";\nimport { SpanKind } from \"@opentelemetry/api\";\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { URLBuilder } from \"../url\";\nexport function tracingPolicy(tracingOptions) {\n  if (tracingOptions === void 0) {\n    tracingOptions = {};\n  }\n\n  return {\n    create: function (nextPolicy, options) {\n      return new TracingPolicy(nextPolicy, options, tracingOptions);\n    }\n  };\n}\n\nvar TracingPolicy =\n/** @class */\nfunction (_super) {\n  __extends(TracingPolicy, _super);\n\n  function TracingPolicy(nextPolicy, options, tracingOptions) {\n    var _this = _super.call(this, nextPolicy, options) || this;\n\n    _this.userAgent = tracingOptions.userAgent;\n    return _this;\n  }\n\n  TracingPolicy.prototype.sendRequest = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var tracer, spanOptions, path, span, spanContext, traceParentHeader, traceState, response, serviceRequestId, err_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!request.spanOptions || !request.spanOptions.parent) {\n              return [2\n              /*return*/\n              , this._nextPolicy.sendRequest(request)];\n            }\n\n            tracer = getTracer();\n            spanOptions = __assign(__assign({}, request.spanOptions), {\n              kind: SpanKind.CLIENT\n            });\n            path = URLBuilder.parse(request.url).getPath() || \"/\";\n            span = tracer.startSpan(path, spanOptions);\n            span.setAttributes({\n              \"http.method\": request.method,\n              \"http.url\": request.url,\n              requestId: request.requestId\n            });\n\n            if (this.userAgent) {\n              span.setAttribute(\"http.user_agent\", this.userAgent);\n            }\n\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            spanContext = span.context();\n            traceParentHeader = getTraceParentHeader(spanContext);\n\n            if (traceParentHeader) {\n              request.headers.set(\"traceparent\", traceParentHeader);\n              traceState = spanContext.traceState && spanContext.traceState.serialize(); // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n\n              if (traceState) {\n                request.headers.set(\"tracestate\", traceState);\n              }\n            }\n\n            return [4\n            /*yield*/\n            , this._nextPolicy.sendRequest(request)];\n\n          case 2:\n            response = _a.sent();\n            span.setAttribute(\"http.status_code\", response.status);\n            serviceRequestId = response.headers.get(\"x-ms-request-id\");\n\n            if (serviceRequestId) {\n              span.setAttribute(\"serviceRequestId\", serviceRequestId);\n            }\n\n            span.end();\n            return [2\n            /*return*/\n            , response];\n\n          case 3:\n            err_1 = _a.sent();\n            span.end();\n            throw err_1;\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return TracingPolicy;\n}(BaseRequestPolicy);\n\nexport { TracingPolicy };","map":{"version":3,"sources":["../../../src/policies/tracingPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { getTracer, getTraceParentHeader } from \"@azure/core-tracing\";\nimport { SpanOptions, SpanKind } from \"@opentelemetry/api\";\nimport {\n  RequestPolicyFactory,\n  RequestPolicy,\n  RequestPolicyOptions,\n  BaseRequestPolicy\n} from \"./requestPolicy\";\nimport { WebResourceLike } from \"../webResource\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { URLBuilder } from \"../url\";\n\nexport interface TracingPolicyOptions {\n  userAgent?: string;\n}\n\nexport function tracingPolicy(tracingOptions: TracingPolicyOptions = {}): RequestPolicyFactory {\n  return {\n    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions) {\n      return new TracingPolicy(nextPolicy, options, tracingOptions);\n    }\n  };\n}\n\nexport class TracingPolicy extends BaseRequestPolicy {\n  private userAgent?: string;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    tracingOptions: TracingPolicyOptions\n  ) {\n    super(nextPolicy, options);\n    this.userAgent = tracingOptions.userAgent;\n  }\n\n  public async sendRequest(request: WebResourceLike): Promise<HttpOperationResponse> {\n    if (!request.spanOptions || !request.spanOptions.parent) {\n      return this._nextPolicy.sendRequest(request);\n    }\n\n    // create a new span\n    const tracer = getTracer();\n    const spanOptions: SpanOptions = {\n      ...request.spanOptions,\n      kind: SpanKind.CLIENT\n    };\n    const path = URLBuilder.parse(request.url).getPath() || \"/\";\n    const span = tracer.startSpan(path, spanOptions);\n    span.setAttributes({\n      \"http.method\": request.method,\n      \"http.url\": request.url,\n      requestId: request.requestId\n    });\n\n    if (this.userAgent) {\n      span.setAttribute(\"http.user_agent\", this.userAgent);\n    }\n\n    try {\n      // set headers\n      const spanContext = span.context();\n      const traceParentHeader = getTraceParentHeader(spanContext);\n      if (traceParentHeader) {\n        request.headers.set(\"traceparent\", traceParentHeader);\n        const traceState = spanContext.traceState && spanContext.traceState.serialize();\n        // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n        if (traceState) {\n          request.headers.set(\"tracestate\", traceState);\n        }\n      }\n\n      const response = await this._nextPolicy.sendRequest(request);\n      span.setAttribute(\"http.status_code\", response.status);\n      const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n      if (serviceRequestId) {\n        span.setAttribute(\"serviceRequestId\", serviceRequestId);\n      }\n      span.end();\n      return response;\n    } catch (err) {\n      span.end();\n      throw err;\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}