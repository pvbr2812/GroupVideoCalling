{"ast":null,"code":"import { CallClient } from '@azure/communication-calling';\nimport { utils } from '../Utils/Utils';\nimport { callAdded, callRemoved, setCallState, setParticipants, setCallAgent } from './actions/calls';\nimport { setMic, setShareScreen } from './actions/controls';\nimport { setAudioDeviceInfo, setAudioDeviceList, setCameraPermission, setMicrophonePermission, setVideoDeviceInfo, setVideoDeviceList, setDeviceManager } from './actions/devices';\nimport { addScreenShareStream, removeScreenShareStream } from './actions/streams';\nimport { setLogLevel } from '@azure/logger';\nimport RemoteStreamSelector from './RemoteStreamSelector';\nimport { Constants } from './constants';\nimport { setCallClient, setUserId } from './actions/sdk';\nexport const setMicrophone = mic => {\n  return async (dispatch, getState) => {\n    const state = getState();\n\n    if (state === undefined || state.calls.call === undefined) {\n      console.error('state or state.controls.mic is null');\n      return;\n    }\n\n    try {\n      if (!state.controls.mic) {\n        await state.calls.call.unmute();\n      } else {\n        await state.calls.call.mute();\n      }\n\n      dispatch(setMic(mic));\n    } catch (e) {\n      console.error(e);\n    }\n  };\n};\nexport const setShareUnshareScreen = shareScreen => {\n  return async (dispatch, getState) => {\n    const state = getState();\n\n    if (state === undefined || state.calls.call === undefined) {\n      console.error('state or state.controls.shareScreen is null');\n      return;\n    }\n\n    try {\n      if (!state.controls.shareScreen) {\n        await state.calls.call.startScreenSharing();\n      } else {\n        await state.calls.call.stopScreenSharing();\n      }\n\n      dispatch(setShareScreen(shareScreen));\n    } catch (e) {\n      console.error(e);\n    }\n  };\n};\n\nconst subscribeToParticipant = (participant, call, dispatch) => {\n  const remoteStreamSelector = RemoteStreamSelector.getInstance(Constants.DOMINANT_PARTICIPANTS_COUNT, dispatch);\n  participant.on('stateChanged', () => {\n    var _participant$displayN;\n\n    remoteStreamSelector.participantStateChanged(utils.getId(participant.identifier), (_participant$displayN = participant.displayName) !== null && _participant$displayN !== void 0 ? _participant$displayN : '', participant.state, !participant.isMuted, participant.videoStreams[0].isAvailable);\n    dispatch(setParticipants([...call.remoteParticipants.values()]));\n  });\n  participant.on('isMutedChanged', () => {\n    remoteStreamSelector.participantAudioChanged(utils.getId(participant.identifier), !participant.isMuted);\n  });\n  participant.on('isSpeakingChanged', () => {\n    dispatch(setParticipants([...call.remoteParticipants.values()]));\n  });\n  participant.on('videoStreamsUpdated', e => {\n    e.added.forEach(addedStream => {\n      if (addedStream.mediaStreamType === 'ScreenSharing') {\n        addedStream.on('isAvailableChanged', () => {\n          if (addedStream.isAvailable) {\n            dispatch(addScreenShareStream(addedStream, participant));\n          } else {\n            dispatch(removeScreenShareStream(addedStream, participant));\n          }\n        });\n\n        if (addedStream.isAvailable) {\n          dispatch(addScreenShareStream(addedStream, participant));\n        }\n      } else if (addedStream.mediaStreamType === 'Video') {\n        addedStream.on('isAvailableChanged', () => {\n          remoteStreamSelector.participantVideoChanged(utils.getId(participant.identifier), addedStream.isAvailable);\n        });\n      }\n    });\n    dispatch(setParticipants([...call.remoteParticipants.values()]));\n  });\n};\n\nconst updateAudioDevices = async (deviceManager, dispatch, getState) => {\n  const microphoneList = await deviceManager.getMicrophones();\n  dispatch(setAudioDeviceList(microphoneList));\n  const state = getState();\n\n  if (state.devices.audioDeviceInfo === undefined && microphoneList.length > 0) {\n    dispatch(setAudioDeviceInfo(microphoneList[0]));\n    deviceManager.selectMicrophone(microphoneList[0]);\n  } else if (state.devices.audioDeviceInfo && !utils.isSelectedAudioDeviceInList(state.devices.audioDeviceInfo, microphoneList)) {\n    deviceManager.selectMicrophone(state.devices.audioDeviceInfo);\n  }\n};\n\nconst updateVideoDevices = async (deviceManager, dispatch, getState) => {\n  const cameraList = await deviceManager.getCameras();\n  dispatch(setVideoDeviceList(cameraList));\n  const state = getState();\n\n  if (state.devices.videoDeviceInfo === undefined) {\n    dispatch(setVideoDeviceInfo(cameraList[0]));\n  } else if (state.devices.videoDeviceInfo && !utils.isSelectedVideoDeviceInList(state.devices.videoDeviceInfo, cameraList)) {\n    dispatch(setVideoDeviceInfo(state.devices.videoDeviceInfo));\n  }\n};\n\nconst subscribeToDeviceManager = async (deviceManager, dispatch, getState) => {\n  // listen for any new events\n  deviceManager.on('videoDevicesUpdated', async () => {\n    updateVideoDevices(deviceManager, dispatch, getState);\n  });\n  deviceManager.on('audioDevicesUpdated', async () => {\n    updateAudioDevices(deviceManager, dispatch, getState);\n  });\n  deviceManager.askDevicePermission({\n    audio: true,\n    video: true\n  }).then(e => {\n    if (e.audio !== undefined) {\n      if (e.audio) {\n        dispatch(setMicrophonePermission('Granted'));\n        updateAudioDevices(deviceManager, dispatch, getState);\n      } else {\n        dispatch(setMicrophonePermission('Denied'));\n      }\n    }\n\n    if (e.video !== undefined) {\n      if (e.video) {\n        dispatch(setCameraPermission('Granted'));\n        updateVideoDevices(deviceManager, dispatch, getState);\n      } else {\n        dispatch(setCameraPermission('Denied'));\n      }\n    }\n  });\n};\n\nexport const updateDevices = () => {\n  return async (dispatch, getState) => {\n    const state = getState();\n    const deviceManager = state.devices.deviceManager;\n\n    if (deviceManager == null) {\n      console.error('no device manager available');\n      return;\n    }\n\n    const cameraList = await deviceManager.getCameras();\n    dispatch(setVideoDeviceList(cameraList));\n    const microphoneList = await deviceManager.getMicrophones();\n    dispatch(setAudioDeviceList(microphoneList));\n  };\n};\nexport const registerToCallAgent = (userId, callAgent, callEndedHandler) => {\n  return async (dispatch, getState) => {\n    setLogLevel('verbose');\n    setUserId(userId);\n    setCallAgent(callAgent);\n    callAgent.on('callsUpdated', e => {\n      e.added.forEach(addedCall => {\n        console.log(`Call added : Call Id = ${addedCall.id}`);\n        const state = getState();\n\n        if (state.calls.call && addedCall.direction === 'Incoming') {\n          addedCall.hangUp();\n          return;\n        }\n\n        dispatch(callAdded(addedCall));\n        addedCall.on('stateChanged', () => {\n          dispatch(setCallState(addedCall.state));\n        });\n        dispatch(setCallState(addedCall.state));\n        addedCall.on('isScreenSharingOnChanged', () => {\n          dispatch(setShareScreen(addedCall.isScreenSharingOn));\n        });\n        dispatch(setShareScreen(addedCall.isScreenSharingOn)); // if remote participants have changed, subscribe to the added remote participants\n\n        addedCall.on('remoteParticipantsUpdated', ev => {\n          // for each of the added remote participants, subscribe to events and then just update as well in case the update has already happened\n          const state = getState();\n          ev.added.forEach(addedRemoteParticipant => {\n            subscribeToParticipant(addedRemoteParticipant, addedCall, dispatch);\n            dispatch(setParticipants([...state.calls.remoteParticipants, addedRemoteParticipant]));\n          }); // We don't use the actual value we are just going to reset the remoteParticipants based on the call\n\n          if (ev.removed.length > 0) {\n            dispatch(setParticipants([...addedCall.remoteParticipants.values()]));\n          }\n        });\n        dispatch(setParticipants([...state.calls.remoteParticipants]));\n      });\n      e.removed.forEach(removedCall => {\n        const state = getState();\n\n        if (state.calls.call && state.calls.call === removedCall) {\n          dispatch(callRemoved(removedCall, state.calls.group));\n\n          if (removedCall.callEndReason && removedCall.callEndReason.code !== 0) {\n            removedCall.callEndReason && callEndedHandler(removedCall.callEndReason);\n          }\n        }\n      });\n    });\n  };\n};\nexport const initCallClient = unsupportedStateHandler => {\n  return async (dispatch, getState) => {\n    let callClient; // check if chrome on ios OR firefox browser\n\n    if (utils.isOnIphoneAndNotSafari() || utils.isUnsupportedBrowser()) {\n      unsupportedStateHandler();\n      return;\n    }\n\n    try {\n      setLogLevel('verbose');\n      callClient = new CallClient();\n    } catch (e) {\n      unsupportedStateHandler();\n      return;\n    }\n\n    if (!callClient) {\n      return;\n    }\n\n    const deviceManager = await callClient.getDeviceManager();\n    dispatch(setCallClient(callClient));\n    dispatch(setDeviceManager(deviceManager));\n    subscribeToDeviceManager(deviceManager, dispatch, getState);\n  };\n}; // what does the forEveryone parameter really mean?\n\nexport const endCall = async (call, options) => {\n  await call.hangUp(options).catch(e => console.error(e));\n};\nexport const joinGroup = async (callAgent, context, callOptions) => {\n  try {\n    await callAgent.join(context, callOptions);\n  } catch (e) {\n    console.log('Failed to join a call', e);\n    return;\n  }\n};\nexport const addParticipant = async (call, user) => {\n  await call.addParticipant(user);\n};\nexport const removeParticipant = async (call, user) => {\n  await call.removeParticipant(user).catch(e => console.error(e));\n};","map":{"version":3,"sources":["C:/Users/VISHWANATH REDDY/Documents/Git Uploads/GroupVideoCalling/Calling/ClientApp/src/core/sideEffects.ts"],"names":["CallClient","utils","callAdded","callRemoved","setCallState","setParticipants","setCallAgent","setMic","setShareScreen","setAudioDeviceInfo","setAudioDeviceList","setCameraPermission","setMicrophonePermission","setVideoDeviceInfo","setVideoDeviceList","setDeviceManager","addScreenShareStream","removeScreenShareStream","setLogLevel","RemoteStreamSelector","Constants","setCallClient","setUserId","setMicrophone","mic","dispatch","getState","state","undefined","calls","call","console","error","controls","unmute","mute","e","setShareUnshareScreen","shareScreen","startScreenSharing","stopScreenSharing","subscribeToParticipant","participant","remoteStreamSelector","getInstance","DOMINANT_PARTICIPANTS_COUNT","on","participantStateChanged","getId","identifier","displayName","isMuted","videoStreams","isAvailable","remoteParticipants","values","participantAudioChanged","added","forEach","addedStream","mediaStreamType","participantVideoChanged","updateAudioDevices","deviceManager","microphoneList","getMicrophones","devices","audioDeviceInfo","length","selectMicrophone","isSelectedAudioDeviceInList","updateVideoDevices","cameraList","getCameras","videoDeviceInfo","isSelectedVideoDeviceInList","subscribeToDeviceManager","askDevicePermission","audio","video","then","updateDevices","registerToCallAgent","userId","callAgent","callEndedHandler","addedCall","log","id","direction","hangUp","isScreenSharingOn","ev","addedRemoteParticipant","removed","removedCall","group","callEndReason","code","initCallClient","unsupportedStateHandler","callClient","isOnIphoneAndNotSafari","isUnsupportedBrowser","getDeviceManager","endCall","options","catch","joinGroup","context","callOptions","join","addParticipant","user","removeParticipant"],"mappings":"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","sourcesContent":["import {\r\n  AudioDeviceInfo,\r\n  Call,\r\n  CommunicationServicesError,\r\n  GroupCallLocator,\r\n  JoinCallOptions,\r\n  DeviceManager,\r\n  DeviceAccess,\r\n  RemoteParticipant,\r\n  VideoDeviceInfo,\r\n  CallAgent,\r\n  CallClient,\r\n  HangUpOptions,\r\n  CallEndReason\r\n} from '@azure/communication-calling';\r\nimport { CommunicationUserKind } from '@azure/communication-common';\r\nimport { Dispatch } from 'redux';\r\nimport { utils } from '../Utils/Utils';\r\nimport { callAdded, callRemoved, setCallState, setParticipants, setCallAgent } from './actions/calls';\r\nimport { setMic, setShareScreen } from './actions/controls';\r\nimport {\r\n  setAudioDeviceInfo,\r\n  setAudioDeviceList,\r\n  setCameraPermission,\r\n  setMicrophonePermission,\r\n  setVideoDeviceInfo,\r\n  setVideoDeviceList,\r\n  setDeviceManager\r\n} from './actions/devices';\r\nimport { addScreenShareStream, removeScreenShareStream } from './actions/streams';\r\nimport { State } from './reducers';\r\nimport { setLogLevel } from '@azure/logger';\r\nimport RemoteStreamSelector from './RemoteStreamSelector';\r\nimport { Constants } from './constants';\r\nimport { setCallClient, setUserId } from './actions/sdk';\r\n\r\nexport const setMicrophone = (mic: boolean) => {\r\n  return async (dispatch: Dispatch, getState: () => State): Promise<void> => {\r\n    const state = getState();\r\n\r\n    if (state === undefined || state.calls.call === undefined) {\r\n      console.error('state or state.controls.mic is null');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      if (!state.controls.mic) {\r\n        await state.calls.call.unmute();\r\n      } else {\r\n        await state.calls.call.mute();\r\n      }\r\n\r\n      dispatch(setMic(mic));\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n  };\r\n};\r\n\r\nexport const setShareUnshareScreen = (shareScreen: boolean) => {\r\n  return async (dispatch: Dispatch, getState: () => State): Promise<void> => {\r\n    const state = getState();\r\n\r\n    if (state === undefined || state.calls.call === undefined) {\r\n      console.error('state or state.controls.shareScreen is null');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      if (!state.controls.shareScreen) {\r\n        await state.calls.call.startScreenSharing();\r\n      } else {\r\n        await state.calls.call.stopScreenSharing();\r\n      }\r\n\r\n      dispatch(setShareScreen(shareScreen));\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n  };\r\n};\r\n\r\nconst subscribeToParticipant = (participant: RemoteParticipant, call: Call, dispatch: Dispatch): void => {\r\n  const remoteStreamSelector = RemoteStreamSelector.getInstance(Constants.DOMINANT_PARTICIPANTS_COUNT, dispatch);\r\n\r\n  participant.on('stateChanged', () => {\r\n    remoteStreamSelector.participantStateChanged(\r\n      utils.getId(participant.identifier),\r\n      participant.displayName ?? '',\r\n      participant.state,\r\n      !participant.isMuted,\r\n      participant.videoStreams[0].isAvailable\r\n    );\r\n    dispatch(setParticipants([...call.remoteParticipants.values()]));\r\n  });\r\n\r\n  participant.on('isMutedChanged', () => {\r\n    remoteStreamSelector.participantAudioChanged(utils.getId(participant.identifier), !participant.isMuted);\r\n  });\r\n\r\n  participant.on('isSpeakingChanged', () => {\r\n    dispatch(setParticipants([...call.remoteParticipants.values()]));\r\n  });\r\n\r\n  participant.on('videoStreamsUpdated', (e): void => {\r\n    e.added.forEach((addedStream) => {\r\n      if (addedStream.mediaStreamType === 'ScreenSharing') {\r\n        addedStream.on('isAvailableChanged', () => {\r\n          if (addedStream.isAvailable) {\r\n            dispatch(addScreenShareStream(addedStream, participant));\r\n          } else {\r\n            dispatch(removeScreenShareStream(addedStream, participant));\r\n          }\r\n        });\r\n\r\n        if (addedStream.isAvailable) {\r\n          dispatch(addScreenShareStream(addedStream, participant));\r\n        }\r\n      } else if (addedStream.mediaStreamType === 'Video') {\r\n        addedStream.on('isAvailableChanged', () => {\r\n          remoteStreamSelector.participantVideoChanged(utils.getId(participant.identifier), addedStream.isAvailable);\r\n        });\r\n      }\r\n    });\r\n    dispatch(setParticipants([...call.remoteParticipants.values()]));\r\n  });\r\n};\r\n\r\nconst updateAudioDevices = async (\r\n  deviceManager: DeviceManager,\r\n  dispatch: Dispatch,\r\n  getState: () => State\r\n): Promise<void> => {\r\n  const microphoneList: AudioDeviceInfo[] = await deviceManager.getMicrophones();\r\n  dispatch(setAudioDeviceList(microphoneList));\r\n\r\n  const state = getState();\r\n  if (state.devices.audioDeviceInfo === undefined && microphoneList.length > 0) {\r\n    dispatch(setAudioDeviceInfo(microphoneList[0]));\r\n    deviceManager.selectMicrophone(microphoneList[0]);\r\n  } else if (\r\n    state.devices.audioDeviceInfo &&\r\n    !utils.isSelectedAudioDeviceInList(state.devices.audioDeviceInfo, microphoneList)\r\n  ) {\r\n    deviceManager.selectMicrophone(state.devices.audioDeviceInfo);\r\n  }\r\n};\r\n\r\nconst updateVideoDevices = async (\r\n  deviceManager: DeviceManager,\r\n  dispatch: Dispatch,\r\n  getState: () => State\r\n): Promise<void> => {\r\n  const cameraList: VideoDeviceInfo[] = await deviceManager.getCameras();\r\n  dispatch(setVideoDeviceList(cameraList));\r\n\r\n  const state = getState();\r\n  if (state.devices.videoDeviceInfo === undefined) {\r\n    dispatch(setVideoDeviceInfo(cameraList[0]));\r\n  } else if (\r\n    state.devices.videoDeviceInfo &&\r\n    !utils.isSelectedVideoDeviceInList(state.devices.videoDeviceInfo, cameraList)\r\n  ) {\r\n    dispatch(setVideoDeviceInfo(state.devices.videoDeviceInfo));\r\n  }\r\n};\r\n\r\nconst subscribeToDeviceManager = async (\r\n  deviceManager: DeviceManager,\r\n  dispatch: Dispatch,\r\n  getState: () => State\r\n): Promise<void> => {\r\n  // listen for any new events\r\n  deviceManager.on('videoDevicesUpdated', async () => {\r\n    updateVideoDevices(deviceManager, dispatch, getState);\r\n  });\r\n\r\n  deviceManager.on('audioDevicesUpdated', async () => {\r\n    updateAudioDevices(deviceManager, dispatch, getState);\r\n  });\r\n\r\n  deviceManager.askDevicePermission({ audio: true, video: true }).then((e: DeviceAccess) => {\r\n    if (e.audio !== undefined) {\r\n      if (e.audio) {\r\n        dispatch(setMicrophonePermission('Granted'));\r\n\r\n        updateAudioDevices(deviceManager, dispatch, getState);\r\n      } else {\r\n        dispatch(setMicrophonePermission('Denied'));\r\n      }\r\n    }\r\n\r\n    if (e.video !== undefined) {\r\n      if (e.video) {\r\n        dispatch(setCameraPermission('Granted'));\r\n        updateVideoDevices(deviceManager, dispatch, getState);\r\n      } else {\r\n        dispatch(setCameraPermission('Denied'));\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\nexport const updateDevices = () => {\r\n  return async (dispatch: Dispatch, getState: () => State): Promise<void> => {\r\n    const state = getState();\r\n    const deviceManager = state.devices.deviceManager;\r\n\r\n    if (deviceManager == null) {\r\n      console.error('no device manager available');\r\n      return;\r\n    }\r\n\r\n    const cameraList: VideoDeviceInfo[] = await deviceManager.getCameras();\r\n\r\n    dispatch(setVideoDeviceList(cameraList));\r\n\r\n    const microphoneList: AudioDeviceInfo[] = await deviceManager.getMicrophones();\r\n\r\n    dispatch(setAudioDeviceList(microphoneList));\r\n  };\r\n};\r\n\r\nexport const registerToCallAgent = (\r\n  userId: string,\r\n  callAgent: CallAgent,\r\n  callEndedHandler: (reason: CallEndReason) => void\r\n) => {\r\n  return async (dispatch: Dispatch, getState: () => State): Promise<void> => {\r\n    setLogLevel('verbose');\r\n\r\n    setUserId(userId);\r\n    setCallAgent(callAgent);\r\n\r\n    callAgent.on('callsUpdated', (e: { added: Call[]; removed: Call[] }): void => {\r\n      e.added.forEach((addedCall) => {\r\n        console.log(`Call added : Call Id = ${addedCall.id}`);\r\n\r\n        const state = getState();\r\n        if (state.calls.call && addedCall.direction === 'Incoming') {\r\n          addedCall.hangUp();\r\n          return;\r\n        }\r\n\r\n        dispatch(callAdded(addedCall));\r\n\r\n        addedCall.on('stateChanged', (): void => {\r\n          dispatch(setCallState(addedCall.state));\r\n        });\r\n\r\n        dispatch(setCallState(addedCall.state));\r\n\r\n        addedCall.on('isScreenSharingOnChanged', (): void => {\r\n          dispatch(setShareScreen(addedCall.isScreenSharingOn));\r\n        });\r\n\r\n        dispatch(setShareScreen(addedCall.isScreenSharingOn));\r\n\r\n        // if remote participants have changed, subscribe to the added remote participants\r\n        addedCall.on('remoteParticipantsUpdated', (ev): void => {\r\n          // for each of the added remote participants, subscribe to events and then just update as well in case the update has already happened\r\n          const state = getState();\r\n          ev.added.forEach((addedRemoteParticipant) => {\r\n            subscribeToParticipant(addedRemoteParticipant, addedCall, dispatch);\r\n            dispatch(setParticipants([...state.calls.remoteParticipants, addedRemoteParticipant]));\r\n          });\r\n\r\n          // We don't use the actual value we are just going to reset the remoteParticipants based on the call\r\n          if (ev.removed.length > 0) {\r\n            dispatch(setParticipants([...addedCall.remoteParticipants.values()]));\r\n          }\r\n        });\r\n\r\n        dispatch(setParticipants([...state.calls.remoteParticipants]));\r\n      });\r\n      e.removed.forEach((removedCall) => {\r\n        const state = getState();\r\n        if (state.calls.call && state.calls.call === removedCall) {\r\n          dispatch(callRemoved(removedCall, state.calls.group));\r\n          if (removedCall.callEndReason && removedCall.callEndReason.code !== 0) {\r\n            removedCall.callEndReason && callEndedHandler(removedCall.callEndReason);\r\n          }\r\n        }\r\n      });\r\n    });\r\n  };\r\n};\r\n\r\nexport const initCallClient = (unsupportedStateHandler: () => void) => {\r\n  return async (dispatch: Dispatch, getState: () => State): Promise<void> => {\r\n    let callClient;\r\n\r\n    // check if chrome on ios OR firefox browser\r\n    if (utils.isOnIphoneAndNotSafari() || utils.isUnsupportedBrowser()) {\r\n      unsupportedStateHandler();\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setLogLevel('verbose');\r\n      callClient = new CallClient();\r\n    } catch (e) {\r\n      unsupportedStateHandler();\r\n      return;\r\n    }\r\n\r\n    if (!callClient) {\r\n      return;\r\n    }\r\n\r\n    const deviceManager: DeviceManager = await callClient.getDeviceManager();\r\n    dispatch(setCallClient(callClient));\r\n    dispatch(setDeviceManager(deviceManager));\r\n    subscribeToDeviceManager(deviceManager, dispatch, getState);\r\n  };\r\n};\r\n\r\n// what does the forEveryone parameter really mean?\r\nexport const endCall = async (call: Call, options: HangUpOptions): Promise<void> => {\r\n  await call.hangUp(options).catch((e: CommunicationServicesError) => console.error(e));\r\n};\r\n\r\nexport const joinGroup = async (\r\n  callAgent: CallAgent,\r\n  context: GroupCallLocator,\r\n  callOptions: JoinCallOptions\r\n): Promise<void> => {\r\n  try {\r\n    await callAgent.join(context, callOptions);\r\n  } catch (e) {\r\n    console.log('Failed to join a call', e);\r\n    return;\r\n  }\r\n};\r\n\r\nexport const addParticipant = async (call: Call, user: CommunicationUserKind): Promise<void> => {\r\n  await call.addParticipant(user);\r\n};\r\n\r\nexport const removeParticipant = async (call: Call, user: CommunicationUserKind): Promise<void> => {\r\n  await call.removeParticipant(user).catch((e: CommunicationServicesError) => console.error(e));\r\n};\r\n"]},"metadata":{},"sourceType":"module"}