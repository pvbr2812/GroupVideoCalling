{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { URLBuilder } from \"@azure/core-http\";\nimport { parseConnectionString } from \"./connectionString\";\n\nconst isValidEndpoint = host => {\n  var _a;\n\n  const url = URLBuilder.parse(host);\n  return !!((_a = url.getScheme()) === null || _a === void 0 ? void 0 : _a.match(/^http[s]?/)) && url.getHost() !== undefined && url.getHost() !== \"\" && (url.getPath() === undefined || url.getPath() === \"\" || url.getPath() === \"/\");\n};\n\nconst assertValidEndpoint = host => {\n  if (!isValidEndpoint(host)) {\n    throw new Error(`Invalid endpoint url ${host}`);\n  }\n};\n/**\n * Checks whether a value is a KeyCredential.\n *\n * @param credential - The credential being checked.\n */\n\n\nexport const isKeyCredential = credential => {\n  const castCredential = credential;\n  return castCredential && typeof castCredential.key === \"string\" && castCredential.getToken === undefined;\n};\n/**\n * Parses arguments passed to a communication client.\n * @hidden\n */\n\nexport const parseClientArguments = (connectionStringOrUrl, credentialOrOptions) => {\n  if (isKeyCredential(credentialOrOptions) || isTokenCredential(credentialOrOptions)) {\n    assertValidEndpoint(connectionStringOrUrl);\n    return {\n      url: connectionStringOrUrl,\n      credential: credentialOrOptions\n    };\n  } else {\n    const {\n      endpoint: host,\n      credential\n    } = parseConnectionString(connectionStringOrUrl);\n    assertValidEndpoint(host);\n    return {\n      url: host,\n      credential\n    };\n  }\n};","map":{"version":3,"sources":["../../../src/credential/clientArguments.ts"],"names":[],"mappings":"AAAA;AACA;AAEA,SAAS,iBAAT,QAAkE,kBAAlE;AACA,SAAS,UAAT,QAA2B,kBAA3B;AACA,SAAS,qBAAT,QAAsC,oBAAtC;;AAEA,MAAM,eAAe,GAAI,IAAD,IAA0B;;;AAChD,QAAM,GAAG,GAAG,UAAU,CAAC,KAAX,CAAiB,IAAjB,CAAZ;AAEA,SACE,CAAC,EAAC,CAAA,EAAA,GAAA,GAAG,CAAC,SAAJ,EAAA,MAAe,IAAf,IAAe,EAAA,KAAA,KAAA,CAAf,GAAe,KAAA,CAAf,GAAe,EAAA,CAAE,KAAF,CAAQ,WAAR,CAAhB,CAAD,IACA,GAAG,CAAC,OAAJ,OAAkB,SADlB,IAEA,GAAG,CAAC,OAAJ,OAAkB,EAFlB,KAGC,GAAG,CAAC,OAAJ,OAAkB,SAAlB,IAA+B,GAAG,CAAC,OAAJ,OAAkB,EAAjD,IAAuD,GAAG,CAAC,OAAJ,OAAkB,GAH1E,CADF;AAMD,CATD;;AAWA,MAAM,mBAAmB,GAAI,IAAD,IAAuB;AACjD,MAAI,CAAC,eAAe,CAAC,IAAD,CAApB,EAA4B;AAC1B,UAAM,IAAI,KAAJ,CAAU,wBAAwB,IAAI,EAAtC,CAAN;AACD;AACF,CAJD;AAMA;;;;AAIG;;;AACH,OAAO,MAAM,eAAe,GAAI,UAAD,IAAqD;AAClF,QAAM,cAAc,GAAG,UAAvB;AAIA,SACE,cAAc,IACd,OAAO,cAAc,CAAC,GAAtB,KAA8B,QAD9B,IAEA,cAAc,CAAC,QAAf,KAA4B,SAH9B;AAKD,CAVM;AAqBP;;;AAGG;;AACH,OAAO,MAAM,oBAAoB,GAAG,CAClC,qBADkC,EAElC,mBAFkC,KAGb;AACrB,MAAI,eAAe,CAAC,mBAAD,CAAf,IAAwC,iBAAiB,CAAC,mBAAD,CAA7D,EAAoF;AAClF,IAAA,mBAAmB,CAAC,qBAAD,CAAnB;AACA,WAAO;AAAE,MAAA,GAAG,EAAE,qBAAP;AAA8B,MAAA,UAAU,EAAE;AAA1C,KAAP;AACD,GAHD,MAGO;AACL,UAAM;AAAE,MAAA,QAAQ,EAAE,IAAZ;AAAkB,MAAA;AAAlB,QAAiC,qBAAqB,CAAC,qBAAD,CAA5D;AACA,IAAA,mBAAmB,CAAC,IAAD,CAAnB;AACA,WAAO;AAAE,MAAA,GAAG,EAAE,IAAP;AAAa,MAAA;AAAb,KAAP;AACD;AACF,CAZM","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isTokenCredential, KeyCredential, TokenCredential } from \"@azure/core-auth\";\nimport { URLBuilder } from \"@azure/core-http\";\nimport { parseConnectionString } from \"./connectionString\";\n\nconst isValidEndpoint = (host: string): boolean => {\n  const url = URLBuilder.parse(host);\n\n  return (\n    !!url.getScheme()?.match(/^http[s]?/) &&\n    url.getHost() !== undefined &&\n    url.getHost() !== \"\" &&\n    (url.getPath() === undefined || url.getPath() === \"\" || url.getPath() === \"/\")\n  );\n};\n\nconst assertValidEndpoint = (host: string): void => {\n  if (!isValidEndpoint(host)) {\n    throw new Error(`Invalid endpoint url ${host}`);\n  }\n};\n\n/**\n * Checks whether a value is a KeyCredential.\n *\n * @param credential - The credential being checked.\n */\nexport const isKeyCredential = (credential: unknown): credential is KeyCredential => {\n  const castCredential = credential as {\n    key: unknown;\n    getToken: unknown;\n  };\n  return (\n    castCredential &&\n    typeof castCredential.key === \"string\" &&\n    castCredential.getToken === undefined\n  );\n};\n\n/**\n * The URL and credential from parsing the arguments of a communication client.\n * @hidden\n */\nexport type UrlWithCredential = {\n  url: string;\n  credential: TokenCredential | KeyCredential;\n};\n\n/**\n * Parses arguments passed to a communication client.\n * @hidden\n */\nexport const parseClientArguments = (\n  connectionStringOrUrl: string,\n  credentialOrOptions?: unknown\n): UrlWithCredential => {\n  if (isKeyCredential(credentialOrOptions) || isTokenCredential(credentialOrOptions)) {\n    assertValidEndpoint(connectionStringOrUrl);\n    return { url: connectionStringOrUrl, credential: credentialOrOptions };\n  } else {\n    const { endpoint: host, credential } = parseConnectionString(connectionStringOrUrl);\n    assertValidEndpoint(host);\n    return { url: host, credential };\n  }\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}