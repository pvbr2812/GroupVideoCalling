{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport _invoke from \"lodash/invoke\";\nimport _keys from \"lodash/keys\";\nimport _uniqueId from \"lodash/uniqueId\";\nimport { FocusZoneDirection, FocusZoneTabbableElements, IS_ENTER_DISABLED_ATTRIBUTE, IS_FOCUSABLE_ATTRIBUTE } from '@fluentui/accessibility';\nimport * as React from 'react';\nimport cx from 'classnames';\nimport { getCode, keyboardKey, SpacebarKey } from '@fluentui/keyboard-key';\nimport * as ReactDOM from 'react-dom';\nimport * as PropTypes from 'prop-types';\nimport { elementContains, findScrollableParent, getDocument as _getDocument, getParent, getWindow, raiseClick, shouldWrapFocus as _shouldWrapFocus } from '@uifabric/utilities';\nimport { getElementType } from '../utils/getElementType';\nimport { getUnhandledProps } from '../utils/getUnhandledProps';\nimport { getNextElement, getPreviousElement, isElementFocusZone, isElementFocusSubZone, isElementTabbable, getElementIndexPath, getFocusableByIndexPath, FOCUSZONE_ID_ATTRIBUTE } from './focusUtilities';\nvar TABINDEX = 'tabindex';\nvar NO_VERTICAL_WRAP = 'data-no-vertical-wrap';\nvar NO_HORIZONTAL_WRAP = 'data-no-horizontal-wrap';\nvar LARGE_DISTANCE_FROM_CENTER = 999999999;\nvar LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;\nvar _allInstances = {};\n\nvar _outerZones = new Set();\n\nvar ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search'];\nvar ALLOW_VIRTUAL_ELEMENTS = false;\n/**\n * Handle global tab presses so that we can patch tabindexes on the fly.\n */\n\nfunction _onKeyDownCapture(ev) {\n  if (getCode(ev) === keyboardKey.Tab) {\n    _outerZones.forEach(function (zone) {\n      return zone.updateTabIndexes();\n    });\n  }\n}\n\nexport var FocusZone = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(FocusZone, _React$Component);\n  /** Used for testing purposes only. */\n\n\n  FocusZone.getOuterZones = function getOuterZones() {\n    return _outerZones.size;\n  };\n\n  function FocusZone(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this._root = {\n      current: null\n    };\n    _this._id = void 0;\n    _this._activeElement = void 0;\n    _this._lastIndexPath = void 0;\n    _this._isParked = false;\n    _this._parkedTabIndex = void 0;\n    _this._defaultFocusElement = void 0;\n    _this._focusAlignment = void 0;\n    _this._isInnerZone = void 0;\n    _this._processingTabKey = void 0;\n    _this.windowElement = void 0;\n\n    _this.setRef = function (elem) {\n      // findDOMNode needed to get correct DOM ref with react-hot-loader, see https://github.com/gaearon/react-hot-loader/issues/964\n      _this._root.current = ReactDOM.findDOMNode(elem);\n    };\n\n    _this._onBlur = function () {\n      _this.setParkedFocus(false);\n    };\n\n    _this._onFocus = function (ev) {\n      var _this$props = _this.props,\n          onActiveElementChanged = _this$props.onActiveElementChanged,\n          stopFocusPropagation = _this$props.stopFocusPropagation,\n          shouldFocusInnerElementWhenReceivedFocus = _this$props.shouldFocusInnerElementWhenReceivedFocus,\n          defaultTabbableElement = _this$props.defaultTabbableElement;\n      var newActiveElement;\n\n      var isImmediateDescendant = _this.isImmediateDescendantOfZone(ev.target);\n\n      if (isImmediateDescendant) {\n        newActiveElement = ev.target;\n      } else {\n        var parentElement = ev.target;\n\n        while (parentElement && parentElement !== _this._root.current) {\n          if (isElementTabbable(parentElement) && _this.isImmediateDescendantOfZone(parentElement)) {\n            newActiveElement = parentElement;\n            break;\n          }\n\n          parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n        }\n      } // If an inner focusable element should be focused when FocusZone container receives focus\n\n\n      if (shouldFocusInnerElementWhenReceivedFocus && ev.target === _this._root.current) {\n        var maybeElementToFocus = defaultTabbableElement && typeof defaultTabbableElement === 'function' && defaultTabbableElement(_this._root.current); // try to focus defaultTabbable element\n\n        if (maybeElementToFocus && isElementTabbable(maybeElementToFocus)) {\n          newActiveElement = maybeElementToFocus;\n          maybeElementToFocus.focus();\n        } else {\n          // force focus on first focusable element\n          _this.focus(true);\n\n          if (_this._activeElement) {\n            // set to null as new active element was handled in method above\n            newActiveElement = null;\n          }\n        }\n      }\n\n      if (newActiveElement && newActiveElement !== _this._activeElement) {\n        _this._activeElement = newActiveElement;\n\n        if (isImmediateDescendant) {\n          _this.setFocusAlignment(_this._activeElement);\n\n          _this.updateTabIndexes();\n        }\n      }\n\n      if (onActiveElementChanged) {\n        onActiveElementChanged(_this._activeElement, ev);\n      }\n\n      if (stopFocusPropagation) {\n        ev.stopPropagation();\n      }\n\n      _invoke(_this.props, 'onFocus', ev);\n    };\n\n    _this._onMouseDown = function (ev) {\n      var disabled = _this.props.disabled;\n\n      if (disabled) {\n        return;\n      }\n\n      var target = ev.target;\n      var path = [];\n\n      while (target && target !== _this._root.current) {\n        path.push(target);\n        target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);\n      }\n\n      while (path.length) {\n        target = path.pop();\n\n        if (target && isElementTabbable(target)) {\n          _this.setActiveElement(target, true);\n        }\n\n        if (isElementFocusZone(target)) {\n          // Stop here since the focus zone will take care of its own children.\n          break;\n        }\n      }\n    };\n\n    _this._onKeyDown = function (ev) {\n      var _this$props2 = _this.props,\n          direction = _this$props2.direction,\n          disabled = _this$props2.disabled,\n          shouldEnterInnerZone = _this$props2.shouldEnterInnerZone,\n          pagingSupportDisabled = _this$props2.pagingSupportDisabled;\n\n      if (disabled) {\n        return undefined;\n      }\n\n      var doc = _getDocument(_this._root.current);\n\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n      } // @ts-ignore\n\n\n      if (doc.activeElement === _this._root.current && _this._isInnerZone) {\n        // If this element has focus, it is being controlled by a parent.\n        // Ignore the keystroke.\n        return undefined;\n      } // If the default has been prevented, do not process keyboard events.\n\n\n      if (ev.isDefaultPrevented()) {\n        return undefined;\n      }\n\n      if (shouldEnterInnerZone && shouldEnterInnerZone(ev) && _this.isImmediateDescendantOfZone(ev.target)) {\n        // Try to focus\n        var innerZone = _this.getFirstInnerZone();\n\n        if (innerZone) {\n          if (!innerZone.focus(true)) {\n            return undefined;\n          }\n        } else if (isElementFocusSubZone(ev.target)) {\n          if (!_this.focusElement(getNextElement(ev.target, ev.target.firstChild, true))) {\n            return undefined;\n          }\n        } else {\n          return undefined;\n        }\n      } else if (ev.altKey) {\n        return undefined;\n      } else {\n        switch (getCode(ev)) {\n          case SpacebarKey:\n            // @ts-ignore\n            if (_this.tryInvokeClickForFocusable(ev.target)) {\n              break;\n            }\n\n            return undefined;\n\n          case keyboardKey.ArrowLeft:\n            if (direction !== FocusZoneDirection.vertical) {\n              _this.preventDefaultWhenHandled(ev);\n\n              if (_this.moveFocusLeft()) {\n                break;\n              }\n            }\n\n            return undefined;\n\n          case keyboardKey.ArrowRight:\n            if (direction !== FocusZoneDirection.vertical) {\n              _this.preventDefaultWhenHandled(ev);\n\n              if (_this.moveFocusRight()) {\n                break;\n              }\n            }\n\n            return undefined;\n\n          case keyboardKey.ArrowUp:\n            if (direction !== FocusZoneDirection.horizontal) {\n              _this.preventDefaultWhenHandled(ev);\n\n              if (_this.moveFocusUp()) {\n                break;\n              }\n            }\n\n            return undefined;\n\n          case keyboardKey.ArrowDown:\n            if (direction !== FocusZoneDirection.horizontal) {\n              _this.preventDefaultWhenHandled(ev);\n\n              if (_this.moveFocusDown()) {\n                break;\n              }\n            }\n\n            return undefined;\n\n          case keyboardKey.PageDown:\n            if (!pagingSupportDisabled && _this.moveFocusPaging(true)) {\n              break;\n            }\n\n            return undefined;\n\n          case keyboardKey.PageUp:\n            if (!pagingSupportDisabled && _this.moveFocusPaging(false)) {\n              break;\n            }\n\n            return undefined;\n\n          case keyboardKey.Tab:\n            if (_this.props.handleTabKey === FocusZoneTabbableElements.all || _this.props.handleTabKey === FocusZoneTabbableElements.inputOnly && _this.isElementInput(ev.target)) {\n              var focusChanged = false;\n              _this._processingTabKey = true;\n\n              if (direction === FocusZoneDirection.vertical || !_this.shouldWrapFocus(_this._activeElement, NO_HORIZONTAL_WRAP)) {\n                focusChanged = ev.shiftKey ? _this.moveFocusUp() : _this.moveFocusDown();\n              } else {\n                var tabWithDirection = _this.props.isRtl ? !ev.shiftKey : ev.shiftKey;\n                focusChanged = tabWithDirection ? _this.moveFocusLeft() : _this.moveFocusRight();\n              }\n\n              _this._processingTabKey = false;\n\n              if (focusChanged) {\n                break;\n              }\n            } else if (_this.props.shouldResetActiveElementWhenTabFromZone) {\n              _this._activeElement = null;\n            }\n\n            return undefined;\n\n          case keyboardKey.Home:\n            if (_this.isContentEditableElement(ev.target) || _this.isElementInput(ev.target) && !_this.shouldInputLoseFocus(ev.target, false)) {\n              return false;\n            }\n\n            var firstChild = _this._root.current && _this._root.current.firstChild;\n\n            if (_this._root.current && firstChild && _this.focusElement(getNextElement(_this._root.current, firstChild, true))) {\n              break;\n            }\n\n            return undefined;\n\n          case keyboardKey.End:\n            if (_this.isContentEditableElement(ev.target) || _this.isElementInput(ev.target) && !_this.shouldInputLoseFocus(ev.target, false)) {\n              return false;\n            }\n\n            var lastChild = _this._root.current && _this._root.current.lastChild;\n\n            if (_this._root.current && _this.focusElement(getPreviousElement(_this._root.current, lastChild, true, true, true))) {\n              break;\n            }\n\n            return undefined;\n\n          case keyboardKey.Enter:\n            // @ts-ignore\n            if (_this.tryInvokeClickForFocusable(ev.target)) {\n              break;\n            }\n\n            return undefined;\n\n          default:\n            return undefined;\n        }\n      }\n\n      ev.preventDefault();\n      ev.stopPropagation();\n      return undefined;\n    };\n\n    _this.getHorizontalDistanceFromCenter = function (isForward, activeRect, targetRect) {\n      var leftAlignment = _this._focusAlignment.left; // ClientRect values can be floats that differ by very small fractions of a decimal.\n      // If the difference between top and bottom are within a pixel then we should treat\n      // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n      // but without Math.Floor they will be handled incorrectly.\n\n      var targetRectTop = Math.floor(targetRect.top);\n      var activeRectBottom = Math.floor(activeRect.bottom);\n      var targetRectBottom = Math.floor(targetRect.bottom);\n      var activeRectTop = Math.floor(activeRect.top);\n      var isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;\n      var isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;\n\n      if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {\n        if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n          return 0;\n        }\n\n        return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n      }\n\n      if (!_this.shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {\n        return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n      }\n\n      return LARGE_DISTANCE_FROM_CENTER;\n    };\n\n    _this._id = _uniqueId('FocusZone');\n    _this._focusAlignment = {\n      left: 0,\n      top: 0\n    };\n    _this._processingTabKey = false;\n    return _this;\n  }\n\n  var _proto = FocusZone.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    _allInstances[this._id] = this;\n    this.setRef(this); // called here to support functional components, we only need HTMLElement ref anyway\n\n    if (!this._root.current) {\n      return;\n    } // @ts-ignore\n\n\n    this.windowElement = getWindow(this._root.current);\n    var parentElement = getParent(this._root.current, ALLOW_VIRTUAL_ELEMENTS);\n\n    var doc = _getDocument(this._root.current); // @ts-ignore\n\n\n    while (parentElement && parentElement !== doc.body && parentElement.nodeType === 1) {\n      if (isElementFocusZone(parentElement)) {\n        this._isInnerZone = true;\n        break;\n      }\n\n      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n    }\n\n    if (!this._isInnerZone) {\n      _outerZones.add(this);\n\n      if (this.windowElement && _outerZones.size === 1) {\n        this.windowElement.addEventListener('keydown', _onKeyDownCapture, true);\n      }\n    }\n\n    this._root.current.addEventListener('blur', this._onBlur, true); // Assign initial tab indexes so that we can set initial focus as appropriate.\n\n\n    this.updateTabIndexes();\n\n    if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'string') {\n      this._activeElement = this.getDocument().querySelector(this.props.defaultTabbableElement);\n    }\n\n    if (this.props.shouldFocusOnMount) {\n      this.focus();\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    if (!this._root.current) {\n      return;\n    }\n\n    var doc = _getDocument(this._root.current);\n\n    if (doc && this._lastIndexPath && (doc.activeElement === doc.body || doc.activeElement === null || !this.props.preventFocusRestoration && doc.activeElement === this._root.current)) {\n      // The element has been removed after the render, attempt to restore focus.\n      var elementToFocus = getFocusableByIndexPath(this._root.current, this._lastIndexPath);\n\n      if (elementToFocus) {\n        this.setActiveElement(elementToFocus, true);\n        elementToFocus.focus();\n        this.setParkedFocus(false);\n      } else {\n        // We had a focus path to restore, but now that path is unresolvable. Park focus\n        // on the container until we can try again.\n        this.setParkedFocus(true);\n      }\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    delete _allInstances[this._id];\n\n    if (!this._isInnerZone) {\n      _outerZones.delete(this);\n\n      if (this.windowElement && _outerZones.size === 0) {\n        this.windowElement.removeEventListener('keydown', _onKeyDownCapture, true);\n      }\n    }\n\n    if (this._root.current) {\n      this._root.current.removeEventListener('blur', this._onBlur, true);\n    }\n\n    this._activeElement = null;\n    this._defaultFocusElement = null;\n  };\n\n  _proto.render = function render() {\n    var className = this.props.className;\n    var ElementType = getElementType(this.props);\n    var unhandledProps = getUnhandledProps(_keys(FocusZone.propTypes), this.props); // Note, right before rendering/reconciling proceeds, we need to record if focus\n    // was in the zone before the update. This helper will track this and, if focus\n    // was actually in the zone, what the index path to the element is at this time.\n    // Then, later in componentDidUpdate, we can evaluate if we need to restore it in\n    // the case the element was removed.\n\n    this.evaluateFocusBeforeRender();\n    return /*#__PURE__*/React.createElement(ElementType, _extends({}, unhandledProps, {\n      className: cx(FocusZone.className, className),\n      \"data-focuszone-id\": this._id,\n      onKeyDown: this._onKeyDown,\n      onFocus: this._onFocus,\n      onMouseDownCapture: this._onMouseDown\n    }), this.props.children);\n  }\n  /**\n   * Sets focus to the first tabbable item in the zone.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element, even if focus is already in the focus zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  ;\n\n  _proto.focus = function focus(forceIntoFirstElement) {\n    if (forceIntoFirstElement === void 0) {\n      forceIntoFirstElement = false;\n    }\n\n    if (this._root.current) {\n      if (!forceIntoFirstElement && this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' && this._isInnerZone) {\n        var ownerZoneElement = this.getOwnerZone(this._root.current);\n\n        if (ownerZoneElement !== this._root.current) {\n          var ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];\n\n          return !!ownerZone && ownerZone.focusElement(this._root.current);\n        }\n\n        return false;\n      }\n\n      if (!forceIntoFirstElement && this._activeElement && elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS) && isElementTabbable(this._activeElement)) {\n        this._activeElement.focus();\n\n        return true;\n      }\n\n      var firstChild = this._root.current.firstChild;\n      return this.focusElement(getNextElement(this._root.current, firstChild, true));\n    }\n\n    return false;\n  }\n  /**\n   * Sets focus to the last tabbable item in the zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  ;\n\n  _proto.focusLast = function focusLast() {\n    if (this._root.current) {\n      var lastChild = this._root.current && this._root.current.lastChild;\n      return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true));\n    }\n\n    return false;\n  }\n  /**\n   * Sets focus to a specific child element within the zone. This can be used in conjunction with\n   * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct\n   * location and then focus.)\n   * @param element - The child element within the zone to focus.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  ;\n\n  _proto.focusElement = function focusElement(element) {\n    var shouldReceiveFocus = this.props.shouldReceiveFocus;\n\n    if (shouldReceiveFocus && !shouldReceiveFocus(element)) {\n      return false;\n    }\n\n    if (element) {\n      this.setActiveElement(element);\n\n      if (this._activeElement) {\n        this._activeElement.focus();\n      }\n\n      return true;\n    }\n\n    return false;\n  }; // Record if focus was in the zone, what the index path to the element is at this time.\n\n\n  _proto.evaluateFocusBeforeRender = function evaluateFocusBeforeRender() {\n    if (!this._root.current) {\n      return;\n    }\n\n    var doc = _getDocument(this._root.current);\n\n    if (!doc) {\n      return;\n    }\n\n    var focusedElement = doc.activeElement; // Only update the index path if we are not parked on the root.\n\n    if (focusedElement !== this._root.current) {\n      var shouldRestoreFocus = elementContains(this._root.current, focusedElement, ALLOW_VIRTUAL_ELEMENTS);\n      this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(this._root.current, doc.activeElement) : undefined;\n    }\n  }\n  /**\n   * When focus is in the zone at render time but then all focusable elements are removed,\n   * we \"park\" focus temporarily on the root. Once we update with focusable children, we restore\n   * focus to the closest path from previous. If the user tabs away from the parked container,\n   * we restore focusability to the pre-parked state.\n   */\n  ;\n\n  _proto.setParkedFocus = function setParkedFocus(isParked) {\n    if (this._root.current && this._isParked !== isParked) {\n      this._isParked = isParked;\n\n      if (isParked) {\n        if (!this.props.allowFocusRoot) {\n          this._parkedTabIndex = this._root.current.getAttribute('tabindex');\n\n          this._root.current.setAttribute('tabindex', '-1');\n        }\n\n        this._root.current.focus();\n      } else if (!this.props.allowFocusRoot) {\n        if (this._parkedTabIndex) {\n          this._root.current.setAttribute('tabindex', this._parkedTabIndex);\n\n          this._parkedTabIndex = undefined;\n        } else {\n          this._root.current.removeAttribute('tabindex');\n        }\n      }\n    }\n  };\n\n  _proto.setActiveElement = function setActiveElement(element, forceAlignemnt) {\n    var previousActiveElement = this._activeElement;\n    this._activeElement = element;\n\n    if (previousActiveElement) {\n      if (isElementFocusZone(previousActiveElement)) {\n        this.updateTabIndexes(previousActiveElement);\n      }\n\n      previousActiveElement.tabIndex = -1;\n    }\n\n    if (this._activeElement) {\n      if (!this._focusAlignment || forceAlignemnt) {\n        this.setFocusAlignment(element, true, true);\n      }\n\n      this._activeElement.tabIndex = 0;\n    }\n  };\n\n  _proto.preventDefaultWhenHandled = function preventDefaultWhenHandled(ev) {\n    this.props.preventDefaultWhenHandled && ev.preventDefault();\n  }\n  /**\n   * Handle the keystrokes.\n   */\n  ;\n  /**\n   * Walk up the dom try to find a focusable element.\n   */\n\n\n  _proto.tryInvokeClickForFocusable = function tryInvokeClickForFocusable(targetElement) {\n    var target = targetElement;\n\n    if (target === this._root.current || !this.props.shouldRaiseClicks) {\n      return false;\n    }\n\n    do {\n      if (target.tagName === 'BUTTON' || target.tagName === 'A' || target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {\n        return false;\n      }\n\n      if (this.isImmediateDescendantOfZone(target) && target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' && target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== 'true') {\n        raiseClick(target);\n        return true;\n      }\n\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);\n    } while (target !== this._root.current);\n\n    return false;\n  }\n  /**\n   * Traverse to find first child zone.\n   */\n  ;\n\n  _proto.getFirstInnerZone = function getFirstInnerZone(forRootElement) {\n    var rootElement = forRootElement || this._activeElement || this._root.current;\n\n    if (!rootElement) {\n      return null;\n    }\n\n    if (isElementFocusZone(rootElement)) {\n      return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];\n    }\n\n    var child = rootElement.firstElementChild;\n\n    while (child) {\n      if (isElementFocusZone(child)) {\n        return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];\n      }\n\n      var match = this.getFirstInnerZone(child);\n\n      if (match) {\n        return match;\n      }\n\n      child = child.nextElementSibling;\n    }\n\n    return null;\n  };\n\n  _proto.moveFocus = function moveFocus(isForward, getDistanceFromCenter, // @ts-ignore\n  ev, useDefaultWrap) {\n    if (useDefaultWrap === void 0) {\n      useDefaultWrap = true;\n    }\n\n    var element = this._activeElement;\n    var candidateDistance = -1;\n    var candidateElement = undefined;\n    var changedFocus = false;\n    var isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;\n\n    if (!element || !this._root.current) {\n      return false;\n    }\n\n    if (this.isElementInput(element)) {\n      if (!this.shouldInputLoseFocus(element, isForward)) {\n        return false;\n      }\n    }\n\n    var activeRect = isBidirectional ? element.getBoundingClientRect() : null;\n\n    do {\n      element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);\n\n      if (isBidirectional) {\n        if (element) {\n          var _targetRect = element.getBoundingClientRect();\n\n          var elementDistance = getDistanceFromCenter(activeRect, _targetRect);\n\n          if (elementDistance === -1 && candidateDistance === -1) {\n            candidateElement = element;\n            break;\n          }\n\n          if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n\n          if (candidateDistance >= 0 && elementDistance < 0) {\n            break;\n          }\n        }\n      } else {\n        candidateElement = element;\n        break;\n      }\n    } while (element); // Focus the closest candidate\n\n\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));\n      }\n\n      return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));\n    }\n\n    return changedFocus;\n  };\n\n  _proto.moveFocusDown = function moveFocusDown() {\n    var _this2 = this;\n\n    var targetTop = -1;\n    var leftAlignment = this._focusAlignment.left;\n\n    if (this.moveFocus(true, function (activeRect, targetRect) {\n      var distance = -1; // ClientRect values can be floats that differ by very small fractions of a decimal.\n      // If the difference between top and bottom are within a pixel then we should treat\n      // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n      // but without Math.Floor they will be handled incorrectly.\n\n      var targetRectTop = Math.floor(targetRect.top);\n      var activeRectBottom = Math.floor(activeRect.bottom);\n\n      if (targetRectTop < activeRectBottom) {\n        if (!_this2.shouldWrapFocus(_this2._activeElement, NO_VERTICAL_WRAP)) {\n          return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n        }\n\n        return LARGE_DISTANCE_FROM_CENTER;\n      }\n\n      if (targetTop === -1 && targetRectTop >= activeRectBottom || targetRectTop === targetTop) {\n        targetTop = targetRectTop;\n\n        if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n          distance = 0;\n        } else {\n          distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n        }\n      }\n\n      return distance;\n    })) {\n      this.setFocusAlignment(this._activeElement, true, true);\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.moveFocusUp = function moveFocusUp() {\n    var _this3 = this;\n\n    var targetTop = -1;\n    var leftAlignment = this._focusAlignment.left;\n\n    if (this.moveFocus(false, function (activeRect, targetRect) {\n      var distance = -1; // ClientRect values can be floats that differ by very small fractions of a decimal.\n      // If the difference between top and bottom are within a pixel then we should treat\n      // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n      // but without Math.Floor they will be handled incorrectly.\n\n      var targetRectBottom = Math.floor(targetRect.bottom);\n      var targetRectTop = Math.floor(targetRect.top);\n      var activeRectTop = Math.floor(activeRect.top);\n\n      if (targetRectBottom > activeRectTop) {\n        if (!_this3.shouldWrapFocus(_this3._activeElement, NO_VERTICAL_WRAP)) {\n          return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n        }\n\n        return LARGE_DISTANCE_FROM_CENTER;\n      }\n\n      if (targetTop === -1 && targetRectBottom <= activeRectTop || targetRectTop === targetTop) {\n        targetTop = targetRectTop;\n\n        if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n          distance = 0;\n        } else {\n          distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n        }\n      }\n\n      return distance;\n    })) {\n      this.setFocusAlignment(this._activeElement, true, true);\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.moveFocusLeft = function moveFocusLeft() {\n    var _this4 = this;\n\n    var shouldWrap = this.shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);\n\n    if (this.moveFocus( // @ts-ignore\n    this.props.isRtl, function (activeRect, targetRect) {\n      var distance = -1;\n      var topBottomComparison;\n\n      if (_this4.props.isRtl) {\n        // When in RTL, this comparison should be the same as the one in moveFocusRight for LTR.\n        // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.\n        // This is important, because we want to be comparing the top of the target rect\n        // with the bottom of the active rect.\n        topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n      } else {\n        topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n      }\n\n      if (topBottomComparison && targetRect.right <= activeRect.right && _this4.props.direction !== FocusZoneDirection.vertical) {\n        distance = activeRect.right - targetRect.right;\n      } else if (!shouldWrap) {\n        distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n      }\n\n      return distance;\n    }, undefined\n    /* ev */\n    , shouldWrap)) {\n      this.setFocusAlignment(this._activeElement, true, false);\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.moveFocusRight = function moveFocusRight() {\n    var _this5 = this;\n\n    var shouldWrap = this.shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);\n\n    if (this.moveFocus(!this.props.isRtl, function (activeRect, targetRect) {\n      var distance = -1;\n      var topBottomComparison;\n\n      if (_this5.props.isRtl) {\n        // When in RTL, this comparison should be the same as the one in moveFocusLeft for LTR.\n        // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.\n        // This is important, because we want to be comparing the bottom of the target rect\n        // with the top of the active rect.\n        topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n      } else {\n        topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n      }\n\n      if (topBottomComparison && targetRect.left >= activeRect.left && _this5.props.direction !== FocusZoneDirection.vertical) {\n        distance = targetRect.left - activeRect.left;\n      } else if (!shouldWrap) {\n        distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n      }\n\n      return distance;\n    }, undefined\n    /* ev */\n    , shouldWrap)) {\n      this.setFocusAlignment(this._activeElement, true, false);\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.moveFocusPaging = function moveFocusPaging(isForward, useDefaultWrap) {\n    if (useDefaultWrap === void 0) {\n      useDefaultWrap = true;\n    }\n\n    var element = this._activeElement;\n\n    if (!element || !this._root.current) {\n      return false;\n    }\n\n    if (this.isElementInput(element)) {\n      if (!this.shouldInputLoseFocus(element, isForward)) {\n        return false;\n      }\n    }\n\n    var scrollableParent = findScrollableParent(element);\n\n    if (!scrollableParent) {\n      return false;\n    }\n\n    var candidateDistance = -1;\n    var candidateElement = undefined;\n    var targetTop = -1;\n    var targetBottom = -1;\n    var pagesize = scrollableParent.clientHeight;\n    var activeRect = element.getBoundingClientRect();\n\n    do {\n      element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);\n\n      if (element) {\n        var _targetRect2 = element.getBoundingClientRect();\n\n        var targetRectTop = Math.floor(_targetRect2.top);\n        var activeRectBottom = Math.floor(activeRect.bottom);\n        var targetRectBottom = Math.floor(_targetRect2.bottom);\n        var activeRectTop = Math.floor(activeRect.top);\n        var elementDistance = this.getHorizontalDistanceFromCenter(isForward, activeRect, _targetRect2);\n        var isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;\n        var isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;\n\n        if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {\n          break;\n        }\n\n        if (elementDistance > -1) {\n          // for paging down\n          if (isForward && targetRectTop > targetTop) {\n            targetTop = targetRectTop;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (!isForward && targetRectBottom < targetBottom) {\n            // for paging up\n            targetBottom = targetRectBottom;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (candidateDistance === -1 || elementDistance <= candidateDistance) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n        }\n      }\n    } while (element);\n\n    var changedFocus = false; // Focus the closest candidate\n\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n      this.setFocusAlignment(candidateElement, false, true);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));\n      }\n\n      return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));\n    }\n\n    return changedFocus;\n  };\n\n  _proto.setFocusAlignment = function setFocusAlignment(element, isHorizontal, isVertical) {\n    if (this.props.direction === FocusZoneDirection.bidirectional && (!this._focusAlignment || isHorizontal || isVertical)) {\n      var rect = element.getBoundingClientRect();\n      var left = rect.left + rect.width / 2;\n      var top = rect.top + rect.height / 2;\n\n      if (!this._focusAlignment) {\n        this._focusAlignment = {\n          left: left,\n          top: top\n        };\n      }\n\n      if (isHorizontal) {\n        this._focusAlignment.left = left;\n      }\n\n      if (isVertical) {\n        this._focusAlignment.top = top;\n      }\n    }\n  };\n\n  _proto.isImmediateDescendantOfZone = function isImmediateDescendantOfZone(element) {\n    return this.getOwnerZone(element) === this._root.current;\n  };\n\n  _proto.getOwnerZone = function getOwnerZone(element) {\n    var doc = _getDocument(this._root.current);\n\n    var parentElement = getParent(element, ALLOW_VIRTUAL_ELEMENTS); // @ts-ignore\n\n    while (parentElement && parentElement !== this._root.current && parentElement !== doc.body) {\n      if (isElementFocusZone(parentElement)) {\n        return parentElement;\n      }\n\n      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n    }\n\n    return this._root.current;\n  };\n\n  _proto.updateTabIndexes = function updateTabIndexes(onElement) {\n    var element = onElement;\n\n    if (!this._activeElement && this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'function') {\n      this._activeElement = this.props.defaultTabbableElement(this._root.current);\n    }\n\n    if (!element && this._root.current) {\n      this._defaultFocusElement = null;\n      element = this._root.current;\n\n      if (this._activeElement && !elementContains(element, this._activeElement, ALLOW_VIRTUAL_ELEMENTS)) {\n        this._activeElement = null;\n      }\n    } // If active element changes state to disabled, set it to null.\n    // Otherwise, we lose keyboard accessibility to other elements in focus zone.\n\n\n    if (this._activeElement && !isElementTabbable(this._activeElement)) {\n      this._activeElement = null;\n    }\n\n    var childNodes = element && element.children;\n\n    for (var childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {\n      var child = childNodes[childIndex];\n\n      if (!isElementFocusZone(child)) {\n        // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.\n        if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n\n        if (isElementTabbable(child)) {\n          if (this.props.disabled) {\n            child.setAttribute(TABINDEX, '-1');\n          } else if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {\n            this._defaultFocusElement = child;\n\n            if (child.getAttribute(TABINDEX) !== '0') {\n              child.setAttribute(TABINDEX, '0');\n            }\n          } else if (child.getAttribute(TABINDEX) !== '-1') {\n            child.setAttribute(TABINDEX, '-1');\n          }\n        } else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {\n          // Disgusting IE hack. Sad face.\n          child.setAttribute('focusable', 'false');\n        }\n      } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {\n        if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {\n          this._defaultFocusElement = child;\n\n          if (child.getAttribute(TABINDEX) !== '0') {\n            child.setAttribute(TABINDEX, '0');\n          }\n        } else if (child.getAttribute(TABINDEX) !== '-1') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n      }\n\n      this.updateTabIndexes(child);\n    }\n  };\n\n  _proto.isContentEditableElement = function isContentEditableElement(element) {\n    return element && element.getAttribute('contenteditable') === 'true';\n  };\n\n  _proto.isElementInput = function isElementInput(element) {\n    if (element && element.tagName && (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')) {\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.shouldInputLoseFocus = function shouldInputLoseFocus(element, isForward) {\n    // If a tab was used, we want to focus on the next element.\n    if (!this._processingTabKey && element && element.type && ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {\n      var selectionStart = element.selectionStart;\n      var selectionEnd = element.selectionEnd;\n      var isRangeSelected = selectionStart !== selectionEnd;\n      var inputValue = element.value;\n      var isReadonly = element.readOnly; // We shouldn't lose focus in the following cases:\n      // 1. There is range selected.\n      // 2. When selection start is larger than 0 and it is backward and not readOnly.\n      // 3. when selection start is not the end of length and it is forward and not readOnly.\n      // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit tab)\n      // and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is determined by calling the\n      // callback shouldInputLoseFocusOnArrowKey\n\n      if (isRangeSelected || selectionStart > 0 && !isForward && !isReadonly || selectionStart !== inputValue.length && isForward && !isReadonly || !!this.props.handleTabKey && !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  _proto.shouldWrapFocus = function shouldWrapFocus(element, noWrapDataAttribute) {\n    return !!this.props.checkForNoWrap ? _shouldWrapFocus(element, noWrapDataAttribute) : true;\n  };\n\n  _proto.getDocument = function getDocument() {\n    return _getDocument(this._root.current);\n  };\n\n  return FocusZone;\n}(React.Component);\nFocusZone.propTypes = {\n  className: PropTypes.string,\n  direction: PropTypes.number,\n  defaultTabbableElement: PropTypes.func,\n  shouldFocusOnMount: PropTypes.bool,\n  shouldResetActiveElementWhenTabFromZone: PropTypes.bool,\n  shouldRaiseClicks: PropTypes.bool,\n  shouldFocusInnerElementWhenReceivedFocus: PropTypes.bool,\n  disabled: PropTypes.bool,\n  as: PropTypes.elementType,\n  isCircularNavigation: PropTypes.bool,\n  shouldEnterInnerZone: PropTypes.func,\n  onActiveElementChanged: PropTypes.func,\n  shouldReceiveFocus: PropTypes.func,\n  handleTabKey: PropTypes.number,\n  shouldInputLoseFocusOnArrowKey: PropTypes.func,\n  stopFocusPropagation: PropTypes.bool,\n  onFocus: PropTypes.func,\n  preventDefaultWhenHandled: PropTypes.bool,\n  isRtl: PropTypes.bool,\n  preventFocusRestoration: PropTypes.bool,\n  pagingSupportDisabled: PropTypes.bool\n};\nFocusZone.defaultProps = {\n  isCircularNavigation: false,\n  direction: FocusZoneDirection.bidirectional,\n  as: 'div',\n  preventDefaultWhenHandled: true,\n  shouldRaiseClicks: false\n};\nFocusZone.displayName = 'FocusZone';\nFocusZone.className = 'ms-FocusZone';","map":{"version":3,"sources":["FocusZone/FocusZone.tsx"],"names":["getDocument","shouldWrapFocus","TABINDEX","NO_VERTICAL_WRAP","NO_HORIZONTAL_WRAP","LARGE_DISTANCE_FROM_CENTER","LARGE_NEGATIVE_DISTANCE_FROM_CENTER","_allInstances","_outerZones","ALLOWED_INPUT_TYPES","ALLOW_VIRTUAL_ELEMENTS","getCode","keyboardKey","zone","FocusZone","React","propTypes","className","PropTypes","direction","defaultTabbableElement","shouldFocusOnMount","shouldResetActiveElementWhenTabFromZone","shouldRaiseClicks","shouldFocusInnerElementWhenReceivedFocus","disabled","as","isCircularNavigation","shouldEnterInnerZone","onActiveElementChanged","shouldReceiveFocus","handleTabKey","shouldInputLoseFocusOnArrowKey","stopFocusPropagation","onFocus","preventDefaultWhenHandled","isRtl","preventFocusRestoration","pagingSupportDisabled","bool","defaultProps","FocusZoneDirection","displayName","_root","current","_id","_activeElement","_lastIndexPath","_isParked","_parkedTabIndex","_defaultFocusElement","_focusAlignment","_isInnerZone","_processingTabKey","windowElement","left","top","componentDidMount","getWindow","parentElement","getParent","doc","isElementFocusZone","componentDidUpdate","elementToFocus","getFocusableByIndexPath","componentWillUnmount","render","ElementType","getElementType","unhandledProps","getUnhandledProps","cx","_onMouseDown","focus","forceIntoFirstElement","ownerZoneElement","ownerZone","elementContains","isElementTabbable","firstChild","getNextElement","focusLast","lastChild","getPreviousElement","focusElement","ReactDOM","evaluateFocusBeforeRender","focusedElement","shouldRestoreFocus","getElementIndexPath","setParkedFocus","isImmediateDescendant","ev","newActiveElement","maybeElementToFocus","target","path","setActiveElement","previousActiveElement","innerZone","isElementFocusSubZone","FocusZoneTabbableElements","focusChanged","tabWithDirection","tryInvokeClickForFocusable","raiseClick","getFirstInnerZone","rootElement","forRootElement","child","match","useDefaultWrap","element","candidateDistance","candidateElement","changedFocus","isBidirectional","activeRect","isForward","targetRect","elementDistance","getDistanceFromCenter","moveFocusDown","targetTop","leftAlignment","distance","targetRectTop","Math","activeRectBottom","moveFocusUp","targetRectBottom","activeRectTop","moveFocusLeft","shouldWrap","topBottomComparison","parseFloat","undefined","moveFocusRight","isValidCandidateOnpagingDown","isValidCandidateOnpagingUp","moveFocusPaging","scrollableParent","findScrollableParent","targetBottom","pagesize","isElementPassedPageSizeOnPagingDown","isElementPassedPageSizeOnPagingUp","setFocusAlignment","rect","isImmediateDescendantOfZone","getOwnerZone","updateTabIndexes","childNodes","childIndex","isContentEditableElement","isElementInput","shouldInputLoseFocus","selectionStart","selectionEnd","isRangeSelected","inputValue","isReadonly"],"mappings":"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","sourcesContent":["import {\n  FocusZoneDirection,\n  FocusZoneTabbableElements,\n  IS_ENTER_DISABLED_ATTRIBUTE,\n  IS_FOCUSABLE_ATTRIBUTE,\n} from '@fluentui/accessibility';\nimport * as React from 'react';\nimport cx from 'classnames';\nimport * as _ from 'lodash';\nimport { getCode, keyboardKey, SpacebarKey } from '@fluentui/keyboard-key';\nimport * as ReactDOM from 'react-dom';\nimport * as PropTypes from 'prop-types';\n\nimport {\n  elementContains,\n  findScrollableParent,\n  getDocument,\n  getParent,\n  getWindow,\n  raiseClick,\n  shouldWrapFocus,\n} from '@uifabric/utilities';\n\nimport { getElementType } from '../utils/getElementType';\nimport { getUnhandledProps } from '../utils/getUnhandledProps';\nimport { FocusZoneProps, IFocusZone } from './FocusZone.types';\nimport {\n  getNextElement,\n  getPreviousElement,\n  isElementFocusZone,\n  isElementFocusSubZone,\n  isElementTabbable,\n  getElementIndexPath,\n  getFocusableByIndexPath,\n  FOCUSZONE_ID_ATTRIBUTE,\n} from './focusUtilities';\n\nconst TABINDEX = 'tabindex';\nconst NO_VERTICAL_WRAP = 'data-no-vertical-wrap';\nconst NO_HORIZONTAL_WRAP = 'data-no-horizontal-wrap';\nconst LARGE_DISTANCE_FROM_CENTER = 999999999;\nconst LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;\n\nconst _allInstances: {\n  [key: string]: FocusZone;\n} = {};\n\nconst _outerZones: Set<FocusZone> = new Set();\n\ninterface Point {\n  left: number;\n  top: number;\n}\nconst ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search'];\n\nconst ALLOW_VIRTUAL_ELEMENTS = false;\n\n/**\n * Handle global tab presses so that we can patch tabindexes on the fly.\n */\nfunction _onKeyDownCapture(ev: KeyboardEvent) {\n  if (getCode(ev) === keyboardKey.Tab) {\n    _outerZones.forEach(zone => zone.updateTabIndexes());\n  }\n}\n\nexport class FocusZone extends React.Component<FocusZoneProps> implements IFocusZone {\n  static propTypes = {\n    className: PropTypes.string,\n    direction: PropTypes.number,\n    defaultTabbableElement: PropTypes.func,\n    shouldFocusOnMount: PropTypes.bool,\n    shouldResetActiveElementWhenTabFromZone: PropTypes.bool,\n    shouldRaiseClicks: PropTypes.bool,\n    shouldFocusInnerElementWhenReceivedFocus: PropTypes.bool,\n    disabled: PropTypes.bool,\n    as: PropTypes.elementType as PropTypes.Requireable<React.ElementType>,\n    isCircularNavigation: PropTypes.bool,\n    shouldEnterInnerZone: PropTypes.func,\n    onActiveElementChanged: PropTypes.func,\n    shouldReceiveFocus: PropTypes.func,\n    handleTabKey: PropTypes.number,\n    shouldInputLoseFocusOnArrowKey: PropTypes.func,\n    stopFocusPropagation: PropTypes.bool,\n    onFocus: PropTypes.func,\n    preventDefaultWhenHandled: PropTypes.bool,\n    isRtl: PropTypes.bool,\n    preventFocusRestoration: PropTypes.bool,\n    pagingSupportDisabled: PropTypes.bool,\n  };\n\n  static defaultProps: FocusZoneProps = {\n    isCircularNavigation: false,\n    direction: FocusZoneDirection.bidirectional,\n    as: 'div',\n    preventDefaultWhenHandled: true,\n    shouldRaiseClicks: false,\n  };\n\n  static displayName = 'FocusZone';\n  static className = 'ms-FocusZone';\n\n  /** Used for testing purposes only. */\n  static getOuterZones(): number {\n    return _outerZones.size;\n  }\n\n  _root: { current: HTMLElement | null } = { current: null };\n  _id: string;\n  /** The most recently focused child element. */\n  _activeElement: HTMLElement | null;\n\n  /**\n   * The index path to the last focused child element.\n   */\n  _lastIndexPath: number[] | undefined;\n\n  /**\n   * Flag to define when we've intentionally parked focus on the root element to temporarily\n   * hold focus until items appear within the zone.\n   */\n  _isParked: boolean = false;\n  _parkedTabIndex: string | null | undefined;\n\n  /** The child element with tabindex=0. */\n  _defaultFocusElement: HTMLElement | null;\n  _focusAlignment: Point;\n  _isInnerZone: boolean;\n\n  /** Used to allow us to move to next focusable element even when we're focusing on a input element when pressing tab */\n  _processingTabKey: boolean;\n\n  windowElement: Window | null;\n\n  constructor(props: FocusZoneProps) {\n    super(props);\n\n    this._id = _.uniqueId('FocusZone');\n\n    this._focusAlignment = {\n      left: 0,\n      top: 0,\n    };\n\n    this._processingTabKey = false;\n  }\n\n  componentDidMount(): void {\n    _allInstances[this._id] = this;\n\n    this.setRef(this); // called here to support functional components, we only need HTMLElement ref anyway\n\n    if (!this._root.current) {\n      return;\n    }\n\n    // @ts-ignore\n    this.windowElement = getWindow(this._root.current);\n    let parentElement = getParent(this._root.current, ALLOW_VIRTUAL_ELEMENTS);\n    const doc = getDocument(this._root.current);\n\n    // @ts-ignore\n    while (parentElement && parentElement !== doc.body && parentElement.nodeType === 1) {\n      if (isElementFocusZone(parentElement)) {\n        this._isInnerZone = true;\n        break;\n      }\n      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n    }\n\n    if (!this._isInnerZone) {\n      _outerZones.add(this);\n\n      if (this.windowElement && _outerZones.size === 1) {\n        this.windowElement.addEventListener('keydown', _onKeyDownCapture, true);\n      }\n    }\n\n    this._root.current.addEventListener('blur', this._onBlur, true);\n\n    // Assign initial tab indexes so that we can set initial focus as appropriate.\n    this.updateTabIndexes();\n\n    if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'string') {\n      this._activeElement = this.getDocument().querySelector(this.props.defaultTabbableElement) as HTMLElement;\n    }\n\n    if (this.props.shouldFocusOnMount) {\n      this.focus();\n    }\n  }\n\n  componentDidUpdate(): void {\n    if (!this._root.current) {\n      return;\n    }\n    const doc = getDocument(this._root.current);\n\n    if (\n      doc &&\n      this._lastIndexPath &&\n      (doc.activeElement === doc.body ||\n        doc.activeElement === null ||\n        (!this.props.preventFocusRestoration && doc.activeElement === this._root.current))\n    ) {\n      // The element has been removed after the render, attempt to restore focus.\n      const elementToFocus = getFocusableByIndexPath(this._root.current as HTMLElement, this._lastIndexPath);\n\n      if (elementToFocus) {\n        this.setActiveElement(elementToFocus, true);\n        elementToFocus.focus();\n        this.setParkedFocus(false);\n      } else {\n        // We had a focus path to restore, but now that path is unresolvable. Park focus\n        // on the container until we can try again.\n        this.setParkedFocus(true);\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    delete _allInstances[this._id];\n\n    if (!this._isInnerZone) {\n      _outerZones.delete(this);\n\n      if (this.windowElement && _outerZones.size === 0) {\n        this.windowElement.removeEventListener('keydown', _onKeyDownCapture, true);\n      }\n    }\n\n    if (this._root.current) {\n      this._root.current.removeEventListener('blur', this._onBlur, true);\n    }\n\n    this._activeElement = null;\n    this._defaultFocusElement = null;\n  }\n\n  render() {\n    const { className } = this.props;\n\n    const ElementType = getElementType(this.props);\n    const unhandledProps = getUnhandledProps(_.keys(FocusZone.propTypes) as any, this.props);\n\n    // Note, right before rendering/reconciling proceeds, we need to record if focus\n    // was in the zone before the update. This helper will track this and, if focus\n    // was actually in the zone, what the index path to the element is at this time.\n    // Then, later in componentDidUpdate, we can evaluate if we need to restore it in\n    // the case the element was removed.\n    this.evaluateFocusBeforeRender();\n\n    return (\n      <ElementType\n        {...unhandledProps}\n        className={cx(FocusZone.className, className)}\n        data-focuszone-id={this._id}\n        onKeyDown={this._onKeyDown}\n        onFocus={this._onFocus}\n        onMouseDownCapture={this._onMouseDown}\n      >\n        {this.props.children}\n      </ElementType>\n    );\n  }\n\n  /**\n   * Sets focus to the first tabbable item in the zone.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element, even if focus is already in the focus zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focus(forceIntoFirstElement: boolean = false): boolean {\n    if (this._root.current) {\n      if (\n        !forceIntoFirstElement &&\n        this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\n        this._isInnerZone\n      ) {\n        const ownerZoneElement = this.getOwnerZone(this._root.current) as HTMLElement;\n\n        if (ownerZoneElement !== this._root.current) {\n          const ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n\n          return !!ownerZone && ownerZone.focusElement(this._root.current);\n        }\n\n        return false;\n      }\n      if (\n        !forceIntoFirstElement &&\n        this._activeElement &&\n        elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS) &&\n        isElementTabbable(this._activeElement)\n      ) {\n        this._activeElement.focus();\n        return true;\n      }\n\n      const firstChild = this._root.current.firstChild as HTMLElement;\n\n      return this.focusElement(getNextElement(this._root.current, firstChild, true) as HTMLElement);\n    }\n    return false;\n  }\n\n  /**\n   * Sets focus to the last tabbable item in the zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focusLast(): boolean {\n    if (this._root.current) {\n      const lastChild = this._root.current && (this._root.current.lastChild as HTMLElement | null);\n\n      return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true) as HTMLElement);\n    }\n\n    return false;\n  }\n\n  /**\n   * Sets focus to a specific child element within the zone. This can be used in conjunction with\n   * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct\n   * location and then focus.)\n   * @param element - The child element within the zone to focus.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focusElement(element: HTMLElement): boolean {\n    const { shouldReceiveFocus } = this.props;\n\n    if (shouldReceiveFocus && !shouldReceiveFocus(element)) {\n      return false;\n    }\n\n    if (element) {\n      this.setActiveElement(element);\n      if (this._activeElement) {\n        this._activeElement.focus();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  setRef = (elem: React.ReactInstance): void => {\n    // findDOMNode needed to get correct DOM ref with react-hot-loader, see https://github.com/gaearon/react-hot-loader/issues/964\n    this._root.current = ReactDOM.findDOMNode(elem) as HTMLElement;\n  };\n\n  // Record if focus was in the zone, what the index path to the element is at this time.\n  evaluateFocusBeforeRender(): void {\n    if (!this._root.current) {\n      return;\n    }\n    const doc = getDocument(this._root.current);\n\n    if (!doc) {\n      return;\n    }\n\n    const focusedElement = doc.activeElement as HTMLElement;\n\n    // Only update the index path if we are not parked on the root.\n    if (focusedElement !== this._root.current) {\n      const shouldRestoreFocus = elementContains(this._root.current, focusedElement, ALLOW_VIRTUAL_ELEMENTS);\n\n      this._lastIndexPath = shouldRestoreFocus\n        ? getElementIndexPath(this._root.current as HTMLElement, doc.activeElement as HTMLElement)\n        : undefined;\n    }\n  }\n\n  /**\n   * When focus is in the zone at render time but then all focusable elements are removed,\n   * we \"park\" focus temporarily on the root. Once we update with focusable children, we restore\n   * focus to the closest path from previous. If the user tabs away from the parked container,\n   * we restore focusability to the pre-parked state.\n   */\n  setParkedFocus(isParked: boolean): void {\n    if (this._root.current && this._isParked !== isParked) {\n      this._isParked = isParked;\n\n      if (isParked) {\n        if (!this.props.allowFocusRoot) {\n          this._parkedTabIndex = this._root.current.getAttribute('tabindex');\n          this._root.current.setAttribute('tabindex', '-1');\n        }\n        this._root.current.focus();\n      } else if (!this.props.allowFocusRoot) {\n        if (this._parkedTabIndex) {\n          this._root.current.setAttribute('tabindex', this._parkedTabIndex);\n          this._parkedTabIndex = undefined;\n        } else {\n          this._root.current.removeAttribute('tabindex');\n        }\n      }\n    }\n  }\n\n  _onBlur = () => {\n    this.setParkedFocus(false);\n  };\n\n  _onFocus = (ev: React.FocusEvent<HTMLElement>): void => {\n    const {\n      onActiveElementChanged,\n      stopFocusPropagation,\n      shouldFocusInnerElementWhenReceivedFocus,\n      defaultTabbableElement,\n    } = this.props;\n\n    let newActiveElement: HTMLElement | null | undefined;\n    const isImmediateDescendant = this.isImmediateDescendantOfZone(ev.target as HTMLElement);\n\n    if (isImmediateDescendant) {\n      newActiveElement = ev.target as HTMLElement;\n    } else {\n      let parentElement = ev.target as HTMLElement;\n\n      while (parentElement && parentElement !== this._root.current) {\n        if (isElementTabbable(parentElement) && this.isImmediateDescendantOfZone(parentElement)) {\n          newActiveElement = parentElement;\n          break;\n        }\n        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n      }\n    }\n\n    // If an inner focusable element should be focused when FocusZone container receives focus\n    if (shouldFocusInnerElementWhenReceivedFocus && ev.target === this._root.current) {\n      const maybeElementToFocus =\n        defaultTabbableElement &&\n        typeof defaultTabbableElement === 'function' &&\n        defaultTabbableElement(this._root.current);\n\n      // try to focus defaultTabbable element\n      if (maybeElementToFocus && isElementTabbable(maybeElementToFocus)) {\n        newActiveElement = maybeElementToFocus;\n        maybeElementToFocus.focus();\n      } else {\n        // force focus on first focusable element\n        this.focus(true);\n        if (this._activeElement) {\n          // set to null as new active element was handled in method above\n\n          newActiveElement = null;\n        }\n      }\n    }\n\n    if (newActiveElement && newActiveElement !== this._activeElement) {\n      this._activeElement = newActiveElement;\n\n      if (isImmediateDescendant) {\n        this.setFocusAlignment(this._activeElement);\n        this.updateTabIndexes();\n      }\n    }\n\n    if (onActiveElementChanged) {\n      onActiveElementChanged(this._activeElement as HTMLElement, ev);\n    }\n\n    if (stopFocusPropagation) {\n      ev.stopPropagation();\n    }\n\n    _.invoke(this.props, 'onFocus', ev);\n  };\n\n  _onMouseDown = (ev: React.MouseEvent<HTMLElement>): void => {\n    const { disabled } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    let target = ev.target as HTMLElement;\n    const path: HTMLElement[] = [];\n\n    while (target && target !== this._root.current) {\n      path.push(target);\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n    }\n\n    while (path.length) {\n      target = path.pop() as HTMLElement;\n\n      if (target && isElementTabbable(target)) {\n        this.setActiveElement(target, true);\n      }\n\n      if (isElementFocusZone(target)) {\n        // Stop here since the focus zone will take care of its own children.\n        break;\n      }\n    }\n  };\n\n  setActiveElement(element: HTMLElement, forceAlignemnt?: boolean): void {\n    const previousActiveElement = this._activeElement;\n\n    this._activeElement = element;\n\n    if (previousActiveElement) {\n      if (isElementFocusZone(previousActiveElement)) {\n        this.updateTabIndexes(previousActiveElement);\n      }\n\n      previousActiveElement.tabIndex = -1;\n    }\n\n    if (this._activeElement) {\n      if (!this._focusAlignment || forceAlignemnt) {\n        this.setFocusAlignment(element, true, true);\n      }\n\n      this._activeElement.tabIndex = 0;\n    }\n  }\n\n  preventDefaultWhenHandled(ev: React.KeyboardEvent<HTMLElement>): void {\n    this.props.preventDefaultWhenHandled && ev.preventDefault();\n  }\n\n  /**\n   * Handle the keystrokes.\n   */\n  _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): boolean | undefined => {\n    const { direction, disabled, shouldEnterInnerZone, pagingSupportDisabled } = this.props;\n\n    if (disabled) {\n      return undefined;\n    }\n\n    const doc = getDocument(this._root.current);\n\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // @ts-ignore\n    if (doc.activeElement === this._root.current && this._isInnerZone) {\n      // If this element has focus, it is being controlled by a parent.\n      // Ignore the keystroke.\n      return undefined;\n    }\n\n    // If the default has been prevented, do not process keyboard events.\n    if (ev.isDefaultPrevented()) {\n      return undefined;\n    }\n\n    if (\n      shouldEnterInnerZone &&\n      shouldEnterInnerZone(ev) &&\n      this.isImmediateDescendantOfZone(ev.target as HTMLElement)\n    ) {\n      // Try to focus\n      const innerZone = this.getFirstInnerZone();\n\n      if (innerZone) {\n        if (!innerZone.focus(true)) {\n          return undefined;\n        }\n      } else if (isElementFocusSubZone(ev.target as HTMLElement)) {\n        if (\n          !this.focusElement(\n            getNextElement(\n              ev.target as HTMLElement,\n              (ev.target as HTMLElement).firstChild as HTMLElement,\n              true,\n            ) as HTMLElement,\n          )\n        ) {\n          return undefined;\n        }\n      } else {\n        return undefined;\n      }\n    } else if (ev.altKey) {\n      return undefined;\n    } else {\n      switch (getCode(ev)) {\n        case SpacebarKey:\n          // @ts-ignore\n          if (this.tryInvokeClickForFocusable(ev.target as HTMLElement)) {\n            break;\n          }\n          return undefined;\n\n        case keyboardKey.ArrowLeft:\n          if (direction !== FocusZoneDirection.vertical) {\n            this.preventDefaultWhenHandled(ev);\n            if (this.moveFocusLeft()) {\n              break;\n            }\n          }\n          return undefined;\n\n        case keyboardKey.ArrowRight:\n          if (direction !== FocusZoneDirection.vertical) {\n            this.preventDefaultWhenHandled(ev);\n            if (this.moveFocusRight()) {\n              break;\n            }\n          }\n          return undefined;\n\n        case keyboardKey.ArrowUp:\n          if (direction !== FocusZoneDirection.horizontal) {\n            this.preventDefaultWhenHandled(ev);\n            if (this.moveFocusUp()) {\n              break;\n            }\n          }\n          return undefined;\n\n        case keyboardKey.ArrowDown:\n          if (direction !== FocusZoneDirection.horizontal) {\n            this.preventDefaultWhenHandled(ev);\n            if (this.moveFocusDown()) {\n              break;\n            }\n          }\n          return undefined;\n\n        case keyboardKey.PageDown:\n          if (!pagingSupportDisabled && this.moveFocusPaging(true)) {\n            break;\n          }\n          return undefined;\n\n        case keyboardKey.PageUp:\n          if (!pagingSupportDisabled && this.moveFocusPaging(false)) {\n            break;\n          }\n          return undefined;\n\n        case keyboardKey.Tab:\n          if (\n            this.props.handleTabKey === FocusZoneTabbableElements.all ||\n            (this.props.handleTabKey === FocusZoneTabbableElements.inputOnly &&\n              this.isElementInput(ev.target as HTMLElement))\n          ) {\n            let focusChanged = false;\n            this._processingTabKey = true;\n            if (\n              direction === FocusZoneDirection.vertical ||\n              !this.shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP)\n            ) {\n              focusChanged = ev.shiftKey ? this.moveFocusUp() : this.moveFocusDown();\n            } else {\n              const tabWithDirection = this.props.isRtl ? !ev.shiftKey : ev.shiftKey;\n              focusChanged = tabWithDirection ? this.moveFocusLeft() : this.moveFocusRight();\n            }\n            this._processingTabKey = false;\n            if (focusChanged) {\n              break;\n            }\n          } else if (this.props.shouldResetActiveElementWhenTabFromZone) {\n            this._activeElement = null;\n          }\n          return undefined;\n\n        case keyboardKey.Home:\n          if (\n            this.isContentEditableElement(ev.target as HTMLElement) ||\n            (this.isElementInput(ev.target as HTMLElement) &&\n              !this.shouldInputLoseFocus(ev.target as HTMLInputElement, false))\n          ) {\n            return false;\n          }\n          const firstChild = this._root.current && (this._root.current.firstChild as HTMLElement | null);\n          if (\n            this._root.current &&\n            firstChild &&\n            this.focusElement(getNextElement(this._root.current, firstChild, true) as HTMLElement)\n          ) {\n            break;\n          }\n          return undefined;\n\n        case keyboardKey.End:\n          if (\n            this.isContentEditableElement(ev.target as HTMLElement) ||\n            (this.isElementInput(ev.target as HTMLElement) &&\n              !this.shouldInputLoseFocus(ev.target as HTMLInputElement, false))\n          ) {\n            return false;\n          }\n\n          const lastChild = this._root.current && (this._root.current.lastChild as HTMLElement | null);\n          if (\n            this._root.current &&\n            this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true) as HTMLElement)\n          ) {\n            break;\n          }\n          return undefined;\n\n        case keyboardKey.Enter:\n          // @ts-ignore\n          if (this.tryInvokeClickForFocusable(ev.target as HTMLElement)) {\n            break;\n          }\n          return undefined;\n\n        default:\n          return undefined;\n      }\n    }\n\n    ev.preventDefault();\n    ev.stopPropagation();\n\n    return undefined;\n  };\n\n  /**\n   * Walk up the dom try to find a focusable element.\n   */\n  tryInvokeClickForFocusable(targetElement: HTMLElement): boolean {\n    let target = targetElement;\n\n    if (target === this._root.current || !this.props.shouldRaiseClicks) {\n      return false;\n    }\n\n    do {\n      if (\n        target.tagName === 'BUTTON' ||\n        target.tagName === 'A' ||\n        target.tagName === 'INPUT' ||\n        target.tagName === 'TEXTAREA'\n      ) {\n        return false;\n      }\n\n      if (\n        this.isImmediateDescendantOfZone(target) &&\n        target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\n        target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== 'true'\n      ) {\n        raiseClick(target);\n        return true;\n      }\n\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n    } while (target !== this._root.current);\n\n    return false;\n  }\n\n  /**\n   * Traverse to find first child zone.\n   */\n  getFirstInnerZone(forRootElement?: HTMLElement | null): FocusZone | null {\n    const rootElement = forRootElement || this._activeElement || this._root.current;\n\n    if (!rootElement) {\n      return null;\n    }\n\n    if (isElementFocusZone(rootElement)) {\n      return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n    }\n\n    let child = rootElement.firstElementChild as HTMLElement | null;\n\n    while (child) {\n      if (isElementFocusZone(child)) {\n        return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n      }\n      const match = this.getFirstInnerZone(child);\n\n      if (match) {\n        return match;\n      }\n\n      child = child.nextElementSibling as HTMLElement | null;\n    }\n\n    return null;\n  }\n\n  moveFocus(\n    isForward: boolean,\n    getDistanceFromCenter: (activeRect: ClientRect, targetRect: ClientRect) => number,\n    // @ts-ignore\n    ev?: Event,\n    useDefaultWrap: boolean = true,\n  ): boolean {\n    let element = this._activeElement;\n    let candidateDistance = -1;\n    let candidateElement: HTMLElement | undefined = undefined;\n    let changedFocus = false;\n    const isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;\n\n    if (!element || !this._root.current) {\n      return false;\n    }\n\n    if (this.isElementInput(element)) {\n      if (!this.shouldInputLoseFocus(element as HTMLInputElement, isForward)) {\n        return false;\n      }\n    }\n\n    const activeRect = isBidirectional ? element.getBoundingClientRect() : null;\n\n    do {\n      element = (isForward\n        ? getNextElement(this._root.current, element)\n        : getPreviousElement(this._root.current, element)) as HTMLElement;\n\n      if (isBidirectional) {\n        if (element) {\n          const targetRect = element.getBoundingClientRect();\n          const elementDistance = getDistanceFromCenter(activeRect as ClientRect, targetRect);\n\n          if (elementDistance === -1 && candidateDistance === -1) {\n            candidateElement = element;\n            break;\n          }\n\n          if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n\n          if (candidateDistance >= 0 && elementDistance < 0) {\n            break;\n          }\n        }\n      } else {\n        candidateElement = element;\n        break;\n      }\n    } while (element);\n\n    // Focus the closest candidate\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(\n          getNextElement(this._root.current, this._root.current.firstElementChild as HTMLElement, true) as HTMLElement,\n        );\n      }\n      return this.focusElement(\n        getPreviousElement(\n          this._root.current,\n          this._root.current.lastElementChild as HTMLElement,\n          true,\n          true,\n          true,\n        ) as HTMLElement,\n      );\n    }\n\n    return changedFocus;\n  }\n\n  moveFocusDown(): boolean {\n    let targetTop = -1;\n    const leftAlignment = this._focusAlignment.left;\n\n    if (\n      this.moveFocus(true, (activeRect: ClientRect, targetRect: ClientRect) => {\n        let distance = -1;\n        // ClientRect values can be floats that differ by very small fractions of a decimal.\n        // If the difference between top and bottom are within a pixel then we should treat\n        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n        // but without Math.Floor they will be handled incorrectly.\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectBottom = Math.floor(activeRect.bottom);\n\n        if (targetRectTop < activeRectBottom) {\n          if (!this.shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return LARGE_DISTANCE_FROM_CENTER;\n        }\n\n        if ((targetTop === -1 && targetRectTop >= activeRectBottom) || targetRectTop === targetTop) {\n          targetTop = targetRectTop;\n          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n            distance = 0;\n          } else {\n            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n          }\n        }\n\n        return distance;\n      })\n    ) {\n      this.setFocusAlignment(this._activeElement as HTMLElement, true, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  moveFocusUp(): boolean {\n    let targetTop = -1;\n    const leftAlignment = this._focusAlignment.left;\n\n    if (\n      this.moveFocus(false, (activeRect: ClientRect, targetRect: ClientRect) => {\n        let distance = -1;\n        // ClientRect values can be floats that differ by very small fractions of a decimal.\n        // If the difference between top and bottom are within a pixel then we should treat\n        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n        // but without Math.Floor they will be handled incorrectly.\n        const targetRectBottom = Math.floor(targetRect.bottom);\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectTop = Math.floor(activeRect.top);\n\n        if (targetRectBottom > activeRectTop) {\n          if (!this.shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n          return LARGE_DISTANCE_FROM_CENTER;\n        }\n\n        if ((targetTop === -1 && targetRectBottom <= activeRectTop) || targetRectTop === targetTop) {\n          targetTop = targetRectTop;\n          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n            distance = 0;\n          } else {\n            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n          }\n        }\n\n        return distance;\n      })\n    ) {\n      this.setFocusAlignment(this._activeElement as HTMLElement, true, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  moveFocusLeft(): boolean {\n    const shouldWrap = this.shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP);\n    if (\n      this.moveFocus(\n        // @ts-ignore\n        this.props.isRtl,\n        (activeRect: ClientRect, targetRect: ClientRect) => {\n          let distance = -1;\n          let topBottomComparison;\n\n          if (this.props.isRtl) {\n            // When in RTL, this comparison should be the same as the one in moveFocusRight for LTR.\n            // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.\n            // This is important, because we want to be comparing the top of the target rect\n            // with the bottom of the active rect.\n            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n          } else {\n            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n          }\n\n          if (\n            topBottomComparison &&\n            targetRect.right <= activeRect.right &&\n            this.props.direction !== FocusZoneDirection.vertical\n          ) {\n            distance = activeRect.right - targetRect.right;\n          } else if (!shouldWrap) {\n            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return distance;\n        },\n        undefined /* ev */,\n        shouldWrap,\n      )\n    ) {\n      this.setFocusAlignment(this._activeElement as HTMLElement, true, false);\n      return true;\n    }\n\n    return false;\n  }\n\n  moveFocusRight(): boolean {\n    const shouldWrap = this.shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP);\n    if (\n      this.moveFocus(\n        !this.props.isRtl,\n        (activeRect: ClientRect, targetRect: ClientRect) => {\n          let distance = -1;\n          let topBottomComparison;\n\n          if (this.props.isRtl) {\n            // When in RTL, this comparison should be the same as the one in moveFocusLeft for LTR.\n            // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.\n            // This is important, because we want to be comparing the bottom of the target rect\n            // with the top of the active rect.\n            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n          } else {\n            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n          }\n\n          if (\n            topBottomComparison &&\n            targetRect.left >= activeRect.left &&\n            this.props.direction !== FocusZoneDirection.vertical\n          ) {\n            distance = targetRect.left - activeRect.left;\n          } else if (!shouldWrap) {\n            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return distance;\n        },\n        undefined /* ev */,\n        shouldWrap,\n      )\n    ) {\n      this.setFocusAlignment(this._activeElement as HTMLElement, true, false);\n      return true;\n    }\n\n    return false;\n  }\n\n  getHorizontalDistanceFromCenter = (isForward: boolean, activeRect: ClientRect, targetRect: ClientRect): number => {\n    const leftAlignment = this._focusAlignment.left;\n    // ClientRect values can be floats that differ by very small fractions of a decimal.\n    // If the difference between top and bottom are within a pixel then we should treat\n    // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n    // but without Math.Floor they will be handled incorrectly.\n    const targetRectTop = Math.floor(targetRect.top);\n    const activeRectBottom = Math.floor(activeRect.bottom);\n    const targetRectBottom = Math.floor(targetRect.bottom);\n    const activeRectTop = Math.floor(activeRect.top);\n    const isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;\n    const isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;\n\n    if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {\n      if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n        return 0;\n      }\n      return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n    }\n\n    if (!this.shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n      return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n    }\n    return LARGE_DISTANCE_FROM_CENTER;\n  };\n\n  moveFocusPaging(isForward: boolean, useDefaultWrap: boolean = true): boolean {\n    let element = this._activeElement;\n    if (!element || !this._root.current) {\n      return false;\n    }\n    if (this.isElementInput(element)) {\n      if (!this.shouldInputLoseFocus(element as HTMLInputElement, isForward)) {\n        return false;\n      }\n    }\n    const scrollableParent = findScrollableParent(element);\n    if (!scrollableParent) {\n      return false;\n    }\n    let candidateDistance = -1;\n    let candidateElement = undefined;\n    let targetTop = -1;\n    let targetBottom = -1;\n    const pagesize = (scrollableParent as HTMLElement).clientHeight;\n    const activeRect = element.getBoundingClientRect();\n    do {\n      element = isForward\n        ? getNextElement(this._root.current, element)\n        : getPreviousElement(this._root.current, element);\n      if (element) {\n        const targetRect = element.getBoundingClientRect();\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectBottom = Math.floor(activeRect.bottom);\n        const targetRectBottom = Math.floor(targetRect.bottom);\n        const activeRectTop = Math.floor(activeRect.top);\n        const elementDistance = this.getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);\n        const isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;\n        const isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;\n\n        if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {\n          break;\n        }\n        if (elementDistance > -1) {\n          // for paging down\n          if (isForward && targetRectTop > targetTop) {\n            targetTop = targetRectTop;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (!isForward && targetRectBottom < targetBottom) {\n            // for paging up\n            targetBottom = targetRectBottom;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (candidateDistance === -1 || elementDistance <= candidateDistance) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n        }\n      }\n    } while (element);\n\n    let changedFocus = false;\n    // Focus the closest candidate\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n      this.setFocusAlignment(candidateElement as HTMLElement, false, true);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(\n          getNextElement(this._root.current, this._root.current.firstElementChild as HTMLElement, true) as HTMLElement,\n        );\n      }\n      return this.focusElement(\n        getPreviousElement(\n          this._root.current,\n          this._root.current.lastElementChild as HTMLElement,\n          true,\n          true,\n          true,\n        ) as HTMLElement,\n      );\n    }\n    return changedFocus;\n  }\n\n  setFocusAlignment(element: HTMLElement, isHorizontal?: boolean, isVertical?: boolean) {\n    if (\n      this.props.direction === FocusZoneDirection.bidirectional &&\n      (!this._focusAlignment || isHorizontal || isVertical)\n    ) {\n      const rect = element.getBoundingClientRect();\n      const left = rect.left + rect.width / 2;\n      const top = rect.top + rect.height / 2;\n\n      if (!this._focusAlignment) {\n        this._focusAlignment = { left, top };\n      }\n\n      if (isHorizontal) {\n        this._focusAlignment.left = left;\n      }\n\n      if (isVertical) {\n        this._focusAlignment.top = top;\n      }\n    }\n  }\n\n  isImmediateDescendantOfZone(element?: HTMLElement): boolean {\n    return this.getOwnerZone(element) === this._root.current;\n  }\n\n  getOwnerZone(element?: HTMLElement): HTMLElement | null {\n    const doc = getDocument(this._root.current);\n    let parentElement = getParent(element as HTMLElement, ALLOW_VIRTUAL_ELEMENTS);\n\n    // @ts-ignore\n    while (parentElement && parentElement !== this._root.current && parentElement !== doc.body) {\n      if (isElementFocusZone(parentElement)) {\n        return parentElement;\n      }\n\n      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n    }\n\n    return this._root.current;\n  }\n\n  updateTabIndexes(onElement?: HTMLElement) {\n    let element = onElement;\n\n    if (\n      !this._activeElement &&\n      this.props.defaultTabbableElement &&\n      typeof this.props.defaultTabbableElement === 'function'\n    ) {\n      this._activeElement = this.props.defaultTabbableElement(this._root.current as HTMLElement);\n    }\n\n    if (!element && this._root.current) {\n      this._defaultFocusElement = null;\n      element = this._root.current;\n      if (this._activeElement && !elementContains(element, this._activeElement, ALLOW_VIRTUAL_ELEMENTS)) {\n        this._activeElement = null;\n      }\n    }\n\n    // If active element changes state to disabled, set it to null.\n    // Otherwise, we lose keyboard accessibility to other elements in focus zone.\n    if (this._activeElement && !isElementTabbable(this._activeElement)) {\n      this._activeElement = null;\n    }\n\n    const childNodes = element && element.children;\n\n    for (let childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {\n      const child = childNodes[childIndex] as HTMLElement;\n\n      if (!isElementFocusZone(child)) {\n        // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.\n        if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n\n        if (isElementTabbable(child)) {\n          if (this.props.disabled) {\n            child.setAttribute(TABINDEX, '-1');\n          } else if (\n            !this._isInnerZone &&\n            ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)\n          ) {\n            this._defaultFocusElement = child;\n            if (child.getAttribute(TABINDEX) !== '0') {\n              child.setAttribute(TABINDEX, '0');\n            }\n          } else if (child.getAttribute(TABINDEX) !== '-1') {\n            child.setAttribute(TABINDEX, '-1');\n          }\n        } else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {\n          // Disgusting IE hack. Sad face.\n          child.setAttribute('focusable', 'false');\n        }\n      } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {\n        if (\n          !this._isInnerZone &&\n          ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)\n        ) {\n          this._defaultFocusElement = child;\n          if (child.getAttribute(TABINDEX) !== '0') {\n            child.setAttribute(TABINDEX, '0');\n          }\n        } else if (child.getAttribute(TABINDEX) !== '-1') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n      }\n\n      this.updateTabIndexes(child);\n    }\n  }\n\n  isContentEditableElement(element: HTMLElement): boolean {\n    return element && element.getAttribute('contenteditable') === 'true';\n  }\n\n  isElementInput(element: HTMLElement): boolean {\n    if (\n      element &&\n      element.tagName &&\n      (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  shouldInputLoseFocus(element: HTMLInputElement, isForward?: boolean) {\n    // If a tab was used, we want to focus on the next element.\n    if (\n      !this._processingTabKey &&\n      element &&\n      element.type &&\n      ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1\n    ) {\n      const selectionStart = element.selectionStart;\n      const selectionEnd = element.selectionEnd;\n      const isRangeSelected = selectionStart !== selectionEnd;\n      const inputValue = element.value;\n      const isReadonly = element.readOnly;\n\n      // We shouldn't lose focus in the following cases:\n      // 1. There is range selected.\n      // 2. When selection start is larger than 0 and it is backward and not readOnly.\n      // 3. when selection start is not the end of length and it is forward and not readOnly.\n      // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit tab)\n      // and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is determined by calling the\n      // callback shouldInputLoseFocusOnArrowKey\n      if (\n        isRangeSelected ||\n        (selectionStart! > 0 && !isForward && !isReadonly) ||\n        (selectionStart !== inputValue.length && isForward && !isReadonly) ||\n        (!!this.props.handleTabKey &&\n          !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element)))\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  shouldWrapFocus(\n    element: HTMLElement,\n    noWrapDataAttribute: 'data-no-vertical-wrap' | 'data-no-horizontal-wrap',\n  ): boolean {\n    return !!this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;\n  }\n\n  getDocument(): Document {\n    return getDocument(this._root.current)!;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}