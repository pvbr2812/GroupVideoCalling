{"ast":null,"code":"import { appendClasses } from './appendClasses';\n/**\n * `createClassResolver` is a factory function which creates a state to classmap resolver for\n * slot specific class names. It can be used in conjunction with the `compose` option `classes` to\n * inject css modules without writing cx(...) logic manually distributing classnames.\n *\n * Class names which map to slots are automatically distributed to correct slot props.\n *\n * Class names with an underscore are interpretted as enum matchable classes. For example,\n * the class \"size_large\" would be applied to the `root` slot when the component's state contains\n * a prop `size` with a value `large`.\n *\n * Remaining class names would be interpretted as modifiers, applied to the `root` slot when\n * the component `state` contains a truthy matching prop name.\n */\n\nexport var createClassResolver = function (classes) {\n  // This is in creation time, so this will happen once per css file.\n  var _a = createResolvedMap(classes),\n      slots = _a.slots,\n      modifiers = _a.modifiers,\n      enums = _a.enums; // Everything in the function below will happen at runtime, so it's very critical that this\n  // code is as minimal as possible.\n\n\n  return function classResolver(state) {\n    var resolvedClasses = {};\n    var modifierClasses = '';\n\n    for (var _i = 0, _a = Object.keys(modifiers); _i < _a.length; _i++) {\n      var modifierName = _a[_i];\n\n      if (state[modifierName]) {\n        modifierClasses = appendClasses(modifierClasses, modifiers[modifierName]);\n      }\n    }\n\n    var enumClasses = '';\n\n    for (var _b = 0, _c = Object.keys(enums); _b < _c.length; _b++) {\n      var enumName = _c[_b];\n      var enumValues = enums[enumName]; // if we have a class which matches the enumName and current state value, add it.\n\n      if (enumValues[state[enumName]]) {\n        enumClasses = appendClasses(enumClasses, enumValues[state[enumName]]);\n      }\n    }\n\n    for (var _d = 0, _e = Object.keys(slots); _d < _e.length; _d++) {\n      var slotName = _e[_d];\n      resolvedClasses[slotName] = appendClasses(slots[slotName], modifierClasses, enumClasses);\n    }\n\n    return resolvedClasses;\n  };\n};\n/**\n * Helper to take a css module map and translate it into { slots, modifiers, enums } where\n * slots are a matched name in the slotNames array, enums have underscores splitting the matched\n * name/value, and modifiers are everything else. Creating this split definition keeps runtime\n * resolution work to a minimum.\n */\n\nfunction createResolvedMap(classes) {\n  var resolvedMap = {\n    slots: {},\n    modifiers: {},\n    enums: {}\n  };\n  var slots = resolvedMap.slots,\n      modifiers = resolvedMap.modifiers,\n      enums = resolvedMap.enums; // Iterate through classes\n\n  Object.keys(classes).forEach(function (key) {\n    var classValue = classes[key];\n\n    if (classValue) {\n      var classParts = key.split('_'); // If the class is named the same as a slot, add it to the slot.\n\n      switch (classParts.length) {\n        case 2:\n          // modifier (_modifierName)\n          modifiers[classParts[1]] = classValue;\n          break;\n\n        case 3:\n          // enum (_enumName_enumValue)\n          var enumName = classParts[1];\n          var enumValue = classParts[2];\n          var enumValues = enums[enumName] = enums[enumName] || {};\n          enumValues[enumValue] = classValue;\n          break;\n\n        default:\n          // slot (root)\n          slots[key] = classValue;\n      }\n    }\n  });\n  return resolvedMap;\n}","map":{"version":3,"sources":["createClassResolver.ts"],"names":[],"mappings":"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","sourcesContent":["import { GenericDictionary, ClassDictionary } from './types';\nimport { appendClasses } from './appendClasses';\n\n/**\n * `createClassResolver` is a factory function which creates a state to classmap resolver for\n * slot specific class names. It can be used in conjunction with the `compose` option `classes` to\n * inject css modules without writing cx(...) logic manually distributing classnames.\n *\n * Class names which map to slots are automatically distributed to correct slot props.\n *\n * Class names with an underscore are interpretted as enum matchable classes. For example,\n * the class \"size_large\" would be applied to the `root` slot when the component's state contains\n * a prop `size` with a value `large`.\n *\n * Remaining class names would be interpretted as modifiers, applied to the `root` slot when\n * the component `state` contains a truthy matching prop name.\n */\nexport const createClassResolver = (classes: ClassDictionary) => {\n  // This is in creation time, so this will happen once per css file.\n  const { slots, modifiers, enums } = createResolvedMap(classes);\n\n  // Everything in the function below will happen at runtime, so it's very critical that this\n  // code is as minimal as possible.\n  return function classResolver(state: GenericDictionary): ClassDictionary {\n    const resolvedClasses: Record<string, string> = {};\n\n    let modifierClasses = '';\n    for (const modifierName of Object.keys(modifiers)) {\n      if (state[modifierName]) {\n        modifierClasses = appendClasses(modifierClasses, modifiers[modifierName]);\n      }\n    }\n\n    let enumClasses = '';\n    for (const enumName of Object.keys(enums)) {\n      const enumValues = enums[enumName];\n      // if we have a class which matches the enumName and current state value, add it.\n      if (enumValues[state[enumName]]) {\n        enumClasses = appendClasses(enumClasses, enumValues[state[enumName]]);\n      }\n    }\n\n    for (const slotName of Object.keys(slots)) {\n      resolvedClasses[slotName] = appendClasses(slots[slotName], modifierClasses, enumClasses);\n    }\n    return resolvedClasses as ClassDictionary;\n  };\n};\n\ntype ResolvedMap = {\n  slots: Record<string, string>;\n  modifiers: Record<string, string>;\n  enums: Record<string, Record<string, string>>;\n};\n\n/**\n * Helper to take a css module map and translate it into { slots, modifiers, enums } where\n * slots are a matched name in the slotNames array, enums have underscores splitting the matched\n * name/value, and modifiers are everything else. Creating this split definition keeps runtime\n * resolution work to a minimum.\n */\nfunction createResolvedMap(classes: ClassDictionary): ResolvedMap {\n  const resolvedMap: ResolvedMap = {\n    slots: {},\n    modifiers: {},\n    enums: {},\n  };\n  const { slots, modifiers, enums } = resolvedMap;\n\n  // Iterate through classes\n  Object.keys(classes).forEach((key: string) => {\n    const classValue = classes[key];\n\n    if (classValue) {\n      const classParts = key.split('_');\n\n      // If the class is named the same as a slot, add it to the slot.\n      switch (classParts.length) {\n        case 2: // modifier (_modifierName)\n          modifiers[classParts[1]] = classValue;\n          break;\n\n        case 3: // enum (_enumName_enumValue)\n          const enumName = classParts[1];\n          const enumValue = classParts[2];\n          const enumValues = (enums[enumName] = enums[enumName] || {});\n\n          enumValues[enumValue] = classValue;\n          break;\n\n        default:\n          // slot (root)\n          slots[key] = classValue;\n      }\n    }\n  });\n\n  return resolvedMap;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}