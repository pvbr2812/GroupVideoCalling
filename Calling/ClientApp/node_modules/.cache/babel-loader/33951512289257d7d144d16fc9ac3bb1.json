{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __awaiter } from \"tslib\";\nimport { parseToken } from \"./tokenParser\";\nconst expiredToken = {\n  token: \"\",\n  expiresOnTimestamp: -10\n};\n\nconst minutesToMs = minutes => minutes * 1000 * 60;\n\nconst defaultRefreshingInterval = minutesToMs(10);\nexport class AutoRefreshTokenCredential {\n  constructor(refreshArgs) {\n    this.refreshingIntervalInMs = defaultRefreshingInterval;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.disposed = false;\n    const {\n      tokenRefresher,\n      token,\n      refreshProactively\n    } = refreshArgs;\n    this.refresh = tokenRefresher;\n    this.currentToken = token ? parseToken(token) : expiredToken;\n    this.refreshProactively = refreshProactively !== null && refreshProactively !== void 0 ? refreshProactively : false;\n\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  getToken(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isCurrentTokenExpiringSoon) {\n        return this.currentToken;\n      }\n\n      const updatePromise = this.updateTokenAndReschedule(options === null || options === void 0 ? void 0 : options.abortSignal);\n\n      if (!this.isCurrentTokenValid) {\n        yield updatePromise;\n      }\n\n      return this.currentToken;\n    });\n  }\n\n  dispose() {\n    this.disposed = true;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.currentToken = expiredToken;\n\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n  }\n\n  updateTokenAndReschedule(abortSignal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.activeTokenUpdating) {\n        return this.activeTokenUpdating;\n      }\n\n      this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);\n\n      try {\n        yield this.activeTokenUpdating;\n      } finally {\n        this.activeTokenUpdating = null;\n      }\n    });\n  }\n\n  refreshTokenAndReschedule(abortSignal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.currentToken = yield this.refreshToken(abortSignal);\n\n      if (this.refreshProactively) {\n        this.scheduleRefresh();\n      }\n    });\n  }\n\n  refreshToken(abortSignal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!this.activeTokenFetching) {\n          this.activeTokenFetching = this.refresh(abortSignal);\n        }\n\n        return parseToken(yield this.activeTokenFetching);\n      } finally {\n        this.activeTokenFetching = null;\n      }\n    });\n  }\n\n  scheduleRefresh() {\n    if (this.disposed) {\n      return;\n    }\n\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n\n    const timespanInMs = this.currentToken.expiresOnTimestamp - Date.now() - this.refreshingIntervalInMs;\n    this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);\n  }\n\n  get isCurrentTokenValid() {\n    return this.currentToken && Date.now() < this.currentToken.expiresOnTimestamp;\n  }\n\n  get isCurrentTokenExpiringSoon() {\n    return !this.currentToken || Date.now() >= this.currentToken.expiresOnTimestamp - this.refreshingIntervalInMs;\n  }\n\n}","map":{"version":3,"sources":["../../src/autoRefreshTokenCredential.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike, AccessToken } from \"@azure/core-http\";\nimport { parseToken } from \"./tokenParser\";\nimport { TokenCredential, CommunicationGetTokenOptions } from \"./communicationTokenCredential\";\n\n/**\n * Options for auto-refreshing a Communication Token credential.\n */\nexport interface CommunicationTokenRefreshOptions {\n  /**\n   * Function that returns a token acquired from the Communication configuration SDK.\n   */\n  tokenRefresher: (abortSignal?: AbortSignalLike) => Promise<string>;\n\n  /**\n   * Optional token to initialize.\n   */\n  token?: string;\n\n  /**\n   * Indicates whether the token should be proactively renewed prior to expiry or only renew on demand.\n   * By default false.\n   */\n  refreshProactively?: boolean;\n}\n\nconst expiredToken = { token: \"\", expiresOnTimestamp: -10 };\nconst minutesToMs = (minutes: number): number => minutes * 1000 * 60;\nconst defaultRefreshingInterval = minutesToMs(10);\n\nexport class AutoRefreshTokenCredential implements TokenCredential {\n  private readonly refresh: (abortSignal?: AbortSignalLike) => Promise<string>;\n  private readonly refreshProactively: boolean;\n  private readonly refreshingIntervalInMs: number = defaultRefreshingInterval;\n\n  private currentToken: AccessToken;\n  private activeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private activeTokenFetching: Promise<string> | null = null;\n  private activeTokenUpdating: Promise<void> | null = null;\n  private disposed = false;\n\n  constructor(refreshArgs: CommunicationTokenRefreshOptions) {\n    const { tokenRefresher, token, refreshProactively } = refreshArgs;\n\n    this.refresh = tokenRefresher;\n    this.currentToken = token ? parseToken(token) : expiredToken;\n    this.refreshProactively = refreshProactively ?? false;\n\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  public async getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken> {\n    if (!this.isCurrentTokenExpiringSoon) {\n      return this.currentToken;\n    }\n\n    const updatePromise = this.updateTokenAndReschedule(options?.abortSignal);\n\n    if (!this.isCurrentTokenValid) {\n      await updatePromise;\n    }\n\n    return this.currentToken;\n  }\n\n  public dispose(): void {\n    this.disposed = true;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.currentToken = expiredToken;\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n  }\n\n  private async updateTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    if (this.activeTokenUpdating) {\n      return this.activeTokenUpdating;\n    }\n    this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);\n    try {\n      await this.activeTokenUpdating;\n    } finally {\n      this.activeTokenUpdating = null;\n    }\n  }\n\n  private async refreshTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    this.currentToken = await this.refreshToken(abortSignal);\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  private async refreshToken(abortSignal?: AbortSignalLike): Promise<AccessToken> {\n    try {\n      if (!this.activeTokenFetching) {\n        this.activeTokenFetching = this.refresh(abortSignal);\n      }\n      return parseToken(await this.activeTokenFetching);\n    } finally {\n      this.activeTokenFetching = null;\n    }\n  }\n\n  private scheduleRefresh(): void {\n    if (this.disposed) {\n      return;\n    }\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n    const timespanInMs =\n      this.currentToken.expiresOnTimestamp - Date.now() - this.refreshingIntervalInMs;\n    this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);\n  }\n\n  private get isCurrentTokenValid(): boolean {\n    return this.currentToken && Date.now() < this.currentToken.expiresOnTimestamp;\n  }\n\n  private get isCurrentTokenExpiringSoon(): boolean {\n    return (\n      !this.currentToken ||\n      Date.now() >= this.currentToken.expiresOnTimestamp - this.refreshingIntervalInMs\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}